algebraic.gd:#O  GroupGraph( <G>, <Grp>, <act> )
algebraic.gd:#O  GroupGraph( <G>, <Grp> )
algebraic.gd:#O  CayleyGraph( <Grp>, <elms> )
algebraic.gd:#O  CayleyGraph( <Grp> )
algebraic.gd:#O  RingGraph( <Rng>, <elms> )
algebraic.gd:#O  Circulant( <n>, <jumps> )
algebraic.gd:#O  CuadraticRingGraph( <Rng> )
algebraic.gd:#O  UnitsRingGraph( <Rng> )
algebraic.gi:#M  GroupGraph( <G>, <Grp>, <act> )
algebraic.gi:#M  GroupGraph( <G>, <Grp> )
algebraic.gi:#M  CayleyGraph( <Grp>, <elms> )
algebraic.gi:#M  CayleyGraph( <Grp> )
algebraic.gi:#M  RingGraph( <Rng>, <elms> )
algebraic.gi:#M  Circulant( <n>, <jumps> )
algebraic.gi:#M  CuadraticRingGraph( <Rng> )
algebraic.gi:#M  UnitsRingGraph( <Rng> )
backtrack.gd:#O  BackTrack( <L>, <opts>, <chk>, <done>, <extra> )
backtrack.gd:#0  BackTrackBag( <opts>, <chk>, <done>, <extra> )
backtrack.gi:#M  BackTrackBag( <opts>, <chk>, <done>, <extra> )
backtrack.gi:#M  BackTrack( <L>, <opts>, <chk>, <done>, <extra> )
basics.gd:#F  IsBoolean( <O> )
basics.gd:#O  DumpObject( <O> )
basics.gd:#F  DeclareQtfyProperty( <N>, <F> )
basics.gi:#F  IsBoolean( <x> )
basics.gi:#M  DumpObject( <Obj> )
binaryop.gd:#O  BoxProduct( <G>, <H> );
binaryop.gd:#O  TimesProduct( <G>, <H> )
binaryop.gd:#O  BoxTimesProduct( <G>, <H> )
binaryop.gd:#O  DisjointUnion( <G>, <H> )
binaryop.gd:#O  Join( <G>, <H> )
binaryop.gd:#O  GraphSum( <G>, <L> )
binaryop.gd:#O  Composition( <G>, <H> )
binaryop.gi:#M  BoxProduct( <G>, <H> )
binaryop.gi:#M  TimesProduct( <G>, <H> )
binaryop.gi:#M  BoxTimesProduct( <G>, <H> )
binaryop.gi:#M  Union( <G>, <H> )#FIXME: Union is a function in gap!
binaryop.gi:#M  DisjointUnion( <G>, <H> )
binaryop.gi:#M  Join( <G>, <H> )
binaryop.gi:#M  GraphSum( <G>, <L> )
binaryop.gi:#M  Composition( <G>, <H> )
classes.gd:#O  IsDiamondFree( <G>, <qtfy> )
classes.gi:#M  IsDiamondFree( <G>, <qtfy> )
cliques.gd:#A  CliqueNumber( <G> )
cliques.gd:#O  IsCliqueHelly( <G>, <qtfy> )
cliques.gd:#A  CliqueGraph( <G> )
cliques.gd:#O  CliqueGraph( <G>, <MaxNumCli> )
cliques.gd:#A  Cliques( <G> )
cliques.gd:#O  Cliques( <G>, <MaxNumCli> )
cliques.gd:#O  Basement( <G>, <KnG>, <x> )
cliques.gd:#O  Basement( <G>, <KnG>, <V> )
cliques.gd:#O  CompletesOfGivenOrder( <G>, <Ord> )
cliques.gd:#O  IsCliqueGated( <G>, <qtfy> )
cliques.gi:#M  CliqueNumber( <G> )
cliques.gi:#M  IsCliqueHelly( <G>, <qtfy> )
cliques.gi:#M  CliqueGraph( <G> )
cliques.gi:#M  CliqueGraph( <G>, <MaxNumCli> )
cliques.gi:#M  Cliques( <G> )
cliques.gi:#M  Cliques( <G>, <MaxNumCli> )
cliques.gi:#M  Basement( <G>, <KnG>, <x> )
cliques.gi:#M  Basement( <G>, <KnG>, <V> )
cliques.gi:#M  CompletesOfGivenOrder( <G>, <Ord> )
cliques.gi:#M  IsCliqueGated( <G>, <qtfy> )
digraphs.gd:#O  InNeigh( <G>, <v> )
digraphs.gd:#O  OutNeigh( <G>, <v> )
digraphs.gd:#O  IsTournament( <G> )
digraphs.gd:#O  IsTransitiveTournament( <G> )
digraphs.gi:#M  InNeigh( <G>, <v> )
digraphs.gi:#M  OutNeigh( <G>, <v> )
digraphs.gi:#M  IsTournament( <G> ) 
digraphs.gi:#M  IsTransitiveTournament( <G> ) 
distances.gd:#A  DistanceMatrix( <G> )
distances.gd:#A  Diameter( <G> )
distances.gd:#A  Radius( <G> )
distances.gd:#O  Distance( <G>, <x>, <y> )
distances.gd:#O  Distances( <G>, <A>, <B> )
distances.gd:#O  DistanceSet( <G>, <A>, <B> )
distances.gd:#O  DistanceGraph( <G>, <Dist> )
distances.gd:#O  PowerGraph( <G>, <exp> )
distances.gd:#F  Excentricity( <G>, <x> )
distances.gi:#M  DistanceMatrix( <G> )
distances.gi:#M  Diameter( <G> )
distances.gi:#M  Radius( <G> )
distances.gi:#M  Distance( <G>, <x>, <y> )
distances.gi:#M  Distances( <G>, <A>, <B> )
distances.gi:#M  DistanceSet( <G>, <A>, <B> )
distances.gi:#M  DistanceGraph( <G>, <Dist> )
distances.gi:#M  PowerGraph( <G>, <exp> )
distances.gi:#F  Excentricity( <G>, <x> )
families.gd:#F  DiscreteGraph( <N> )
families.gd:#F  CompleteGraph( <N> )
families.gd:#F  PathGraph( <N> )
families.gd:#F  CycleGraph( <N> )
families.gd:#F  CubeGraph( <n> )
families.gd:#F  OctahedralGraph( <n> )
families.gd:#F  JohnsonGraph( <n>, <r> )
families.gd:#F  CompleteBipartiteGraph( <n>, <m> )
families.gd:#F  CompleteMultipartiteGraph( <n1>, <n2> [, <n3> ...] )
families.gd:#F  RandomGraph( <n>, <p> )
families.gd:#F  WheelGraph( <N> )
families.gd:#F  FanGraph( <N> )
families.gd:#F  SunGraph( <N> )
families.gd:#F  SpikyGraph( <N> )
families.gd:#F  TrivialGraph( <N> )
families.gd:#F  DiamondGraph( <N> )
families.gd:#F  ClawGraph( <N> )
families.gd:#F  PawGraph( <N> )
families.gd:#F  HouseGraph( <N> )
families.gd:#F  BullGraph( <N> )
families.gd:#F  AntennaGraph( <N> )
families.gd:#F  KiteGraph( <N> )
families.gd:#F  Tetrahedron( <N> )
families.gd:#F  Octahedron( <N> )
families.gd:#F  Cube( <N> )
families.gd:#F  Icosahedron( <N> )
families.gd:#F  Dodecahedron( <N> )
families.gi:#F  DiscreteGraph( <N> )
families.gi:#F  CompleteGraph( <N> )
families.gi:#F  PathGraph( <N> )
families.gi:#F  CycleGraph( <N> )
families.gi:#F  CubeGraph( <n> )
families.gi:#F  OctahedralGraph( <n> )
families.gi:#F  JohnsonGraph( <n>, <r> )
families.gi:#F  CompleteBipartiteGraph( <n>, <m> )
families.gi:#F  CompleteMultipartiteGraph( <n1>, <n2> [, <n3> ...] )
families.gi:#F  RandomGraph( <n>, <p> )
families.gi:#F  WheelGraph( <N> )
families.gi:#F  FanGraph( <N> )
families.gi:#F  SunGraph( <N> )
families.gi:#F  SpikyGraph( <N> )
iso.gd:#O  NextIsoMorphism( <G>, <H>, <morph> );
iso.gd:#O  IsoMorphism( <G>, <H> )
iso.gd:#O  IsoMorphisms( <G>, <H> )
iso.gd:#O  IsIsomorphicGraph( <G>, <H> )
iso.gd:#O  AutomorphismGroup( <G> )
iso.gi:#I  CHQ_ISO( <L>, <extra> ) ... intended for internal use
iso.gi:#M  NextIsoMorphism( <G>, <H>, <morph> )
iso.gi:#M  IsoMorphism( <G>, <H> )
iso.gi:#M  IsoMorphisms( <G>, <H> )
iso.gi:#M  IsIsomorphicGraph( <G>, <H> )
iso.gi:#M  AutomorphismGroup( <G> )
kernel.gd:#1
kernel.gd:#C  Graphs()
kernel.gd:#C  LooplessGraphs()
kernel.gd:#C  UndirectedGraphs()
kernel.gd:#C  OrientedGraphs()
kernel.gd:#C  SimpleGraphs()
kernel.gd:#F              SetDefaultGraphCategory( <C> )
kernel.gd:#F  GraphCategory( [<G>, ... ] );
kernel.gd:#F  TargetGraphCategory( [<G>, ... ] );
kernel.gd:#O  in(<G>,<C>)
kernel.gd:#A  AdjMatrix(<G>)
kernel.gd:#A  Order(<G>)
kernel.gd:#A  Size(<G>)
kernel.gd:#A  VertexNames(<G>)
kernel.gd:#Q  IsCompleteGraph(<G>)
kernel.gd:#Q  IsLoopless(<G>)
kernel.gd:#Q  IsUndirected(<G>)
kernel.gd:#Q  IsOriented(<G>)
kernel.gd:#O  IsSimple(<G>)
kernel.gd:#O  QtfyIsSimple( <G> )
kernel.gd:#O  IsComplete( <G>, <L> )
kernel.gd:#O  Vertices( <G> )
kernel.gd:#O  IsEdge( <G> , <List>)
kernel.gd:#O  Adjacency( <G>, <V> )
kernel.gd:#O  Adjacencies( <G> )
kernel.gd:#O  VertexDegree( <G>, <V> )
kernel.gd:#O  VertexDegrees( <G> )
kernel.gd:#O  MaxDegree( <G> )
kernel.gd:#O  MinDegree( <G> )
kernel.gd:#O  Edges( <G> )
kernel.gd:#O  Graph( <R> )
kernel.gd:#F  AdjMatrixGraph( <M> )
kernel.gd:#F  AdjacencyGraph( <A> )
kernel.gd:#F  CompleteCoverGraph( <C> )
kernel.gd:#F  RelationGraph( <V>, <R> )
kernel.gd:#F  RelationGraph( <N>, <R> )
kernel.gd:#F  IntersectionGraph( <L> )
kernel.gd:#O  CopyGraph( <G> ) 
kernel.gd:#O  InducedSubgraph( <G>, <V> )
kernel.gd:#O  RemoveVertices( <G>, <V> )
kernel.gd:#O  AddEdges( <G>, <E> )
kernel.gd:#O  RemoveEdges( <G>, <E> )
kernel.gi:#F  SetDefaultGraphCategory( <Catgy> );
kernel.gi:#F  GraphCategory( [, <Graph>, ... ] );
kernel.gi:#F  TargetGraphCategory( [, <Graph>, ... ] );
kernel.gi:#M  PrintObj( <G> )
kernel.gi:#M  ViewObj( <G> )
kernel.gi:#M  DumpObject( <Obj> )
kernel.gi:#M  IsInternallyConsistent( <G> )   ...  For Debugging
kernel.gi:#A  Order( <G> )
kernel.gi:#A  Size( <G> )
kernel.gi:#A  VertexNames( <G> )
kernel.gi:#M  IsCompleteGraph( <G>, <qtfy> )
kernel.gi:#M  IsLoopless( <G>, <qtfy> )
kernel.gi:#M  IsUndirected( <G>, <qtfy> ) 
kernel.gi:#M  IsOriented( <G>, <qtfy> )
kernel.gi:#M  IsSimple( <G> )
kernel.gi:#M  QtfyIsSimple( <G> )
kernel.gi:#M  IsComplete( <G>, <L> )
kernel.gi:#M  Vertices( <G> )
kernel.gi:#M  IsEdge( <G>, <e> )
kernel.gi:#M  Adjacency( <G>, <x> )
kernel.gi:#M  Adjacencies( <G> )
kernel.gi:#M  VertexDegree( <G>, <x> )
kernel.gi:#M  VertexDegrees( <G> )
kernel.gi:#M  MaxDegree( <G> )
kernel.gi:#M  MinDegree( <G> )
kernel.gi:#M  Edges( <G> )
kernel.gi:#M  Graph( <Rec> )
kernel.gi:#F  AdjMatrixGraph( <M> )
kernel.gi:#F  AdjacencyGraph( <Adj> )
kernel.gi:#F  CompleteCoverGraph( <Cover> )
kernel.gi:#F  RelationGraph( <V>, <rel> )
kernel.gi:#F  RelationGraph( <N>, <rel> )
kernel.gi:#F  IntersectionGraph( <L> )
kernel.gi:#M  CopyGraph( <G> ) 
kernel.gi:#M  InducedSubgraph( <G>, <V> )
kernel.gi:#M  RemoveVertices( <G>, <V> )
kernel.gi:#M  AddEdges( <G>, <Edgs> )
kernel.gi:#M  RemoveEdges( <G>, <Edgs> )
morph_chq.g:#FIXME: mejorar este también (ver abajo)
morph_chq.g:#FIXME: mejorar este usando grados, 
morph_chq.g:#Think:  Morph(K_100,C_4,EPI);
morph_chq.g:#FIXME: write CHQ_FULL function.
morph.gd:#O  NextPropertyMorphism( <G1>, <G2>, <morph>, <chks> )
morph.gd:#O  PropertyMorphism( <G1>, <G2>, <chks> )
morph.gd:#O  PropertyMorphisms( <G1>, <G2>, <chks> )
morph.gi:#M  NextPropertyMorphism( <G1>, <G2>, <morph>, <chks> )
morph.gi:#M  PropertyMorphism( <G1>, <G2>, <chks> )
morph.gi:#M  PropertyMorphisms( <G1>, <G2>, <chks> )
operators.g:#M  \=( <G>, <H> )
operators.g:#M  \{\}( <G>, <V> )
operators.g:#M  \+( <G>, <E> )
operators.g:#M  \-( <G>, <VE> )
operators.g:#M  \^( <G>, <N> )
operators.g:#M  \^( <G>, <L> )
operators.gd:#O  \=( <G>, <H> )
operators.gd:#O  \{\}( <G>, <V> )
operators.gd:#O  \+( <G>, <E> )
operators.gd:#O  \-( <G>, <VE> )
operators.gd:#O  \^( <G>, <N> )
operators.gd:#O  \^( <G>, <L> )
operators.gi:#M  \=( <G>, <H> )
operators.gi:#M  \{\}( <G>, <V> )
operators.gi:#M  \+( <G>, <E> )
operators.gi:#M  \-( <G>, <VE> )
operators.gi:#M  \^( <G>, <N> )
operators.gi:#M  \^( <G>, <L> )
unaryop.gd:#M  LineGraph( <G> )
unaryop.gd:#M  ComplementGraph( <G> )
unaryop.gd:#M  QuotientGraph( <G>, <EC> )
unaryop.gi:#M  LineGraph( <G> )
unaryop.gi:#M  ComplementGraph( <G> )
unaryop.gi:#M  QuotientGraph( <G>, <EC> )
