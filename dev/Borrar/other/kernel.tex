% This file was created automatically from kernel.msk.
% DO NOT EDIT!
\Chapter{Kernel}

The kernel contains definitions and the core functions that handle
graphs.

\Section{Categories}

Using {\GAP} category facilities \YAGS \ defines a hierarchy of
graphs. The categories defined are as follows.

\>Graphs( ) C

Graphs are the base category used by \YAGS. This category contains
all graphs that can be represented in \YAGS. 



Among them we can find:

$$
\xymatrix{
   {\bullet} \ar@(dr,dl)[d] \ar[dr] \\
   {\bullet} \ar@(ul,ur)[u] \ar[r] & {\bullet}
} 
\ 
\xymatrix{
   {\bullet} \ar@{-}[dr] & {\bullet} \ar[dl]\\
   {\bullet} & {\bullet} \ar@(ur,dr)[]\ar[l]
} 
$$
$$
\xymatrix{
   {\bullet} \ar@(ul,dl)[] \ar[dr] & & {\bullet} \ar@(l,d)[dl]\\
   & {\bullet} \ar@(r,u)[ur] & 
} 
\xymatrix{
   & {\bullet} \ar@{-}[dl] \ar@{-}[dr] & & {\bullet} \ar@{-}[dl] \\
   {\bullet} & & {\bullet} \ar@{-}[dr] \\
   & {\bullet} \ar@{-}[ur] \ar@{-}[ul] & & {\bullet} \ar@{-}[uu] \\
}
$$

\>LooplessGraphs( ) C

Loopless Graphs are graphs which have no loops.



A loop is an arrow that starts and finishes on the same
vertex. 

$$
\xymatrix{
   {\bullet} \ar@(ur,dr)[]
} 
$$

Loopless graphs have no such arrows.

$$
\xymatrix{
   {\bullet} \ar[dr] & & {\bullet} \ar@(l,d)[dl]\\
   & {\bullet} \ar@(r,u)[ur] & 
} 
$$

\>UndirectedGraphs( ) C

Undirected Graphs are graphs which have no directed arrows.



Given two vertex $i,j$ in graph $G$ we will say that graph $G$ has an
*edge* $\{i,j\}$ if there is an arrow $(i,j)$ and and arrow $(j,i).$ 

$$
\xymatrix{
   {\bullet} \ar@(ur,dr)[r] & {\bullet} \ar@(dl,ul)[l]
} 
\xymatrix{
   {\bullet} \ar@{-}[r] &  {\bullet}
} 
$$

Undirected graphs have no arrows but only edges.

$$
\xymatrix{
   {\bullet} \ar@(ul,dl)[] \ar@(r,d)[dr] & & {\bullet} \ar@(l,d)[dl]\\
   & {\bullet} \ar@(r,u)[ur] \ar@(l,u)[ul] & 
} 
\equiv\hskip20pt
\xymatrix{
   {\bullet} \ar@(ul,dl){-} \ar@{-}[dr] & & {\bullet} \ar@{-}[dl]\\
   & {\bullet} & 
}  
$$

\>OrientedGraphs( ) C

Oriented Graphs are graphs which have arrows in only one direction
between any two vertices. 



Oriented graphs have no edges but only arrows. 

$$
\xymatrix{
   {\bullet} \ar[dr] & & {\bullet} \ar[ll]\\
   & {\bullet} \ar[ur] & 
} 
$$

\>SimpleGraphs( ) C

Simple Graphs are graphs with no loops and undirected.


$$
\xymatrix{
   & {\bullet} \ar@{-}[dl] \ar@{-}[dr] & & {\bullet} \ar@{-}[dl] \\
   {\bullet} & & {\bullet} \ar@{-}[dr] \\
   & {\bullet} \ar@{-}[ur] \ar@{-}[ul] & & {\bullet} \ar@{-}[uu] \\
}
$$

Figure shows the relationship among categories.

$$
\pstree[nodesep=5pt]{\Tr{Graphs}}
{
  \pstree{\Tr{Loopless}}
  {
         \Tr{Oriented}
         \Tr[name=S]{Simple Graphs}
  }
  \Tr[name=U]{Undirected}
}
\ncline[nodesep=5pt]{S}{U}
$$

This relationship is important because when a graph is created it is
normalized in the category it belongs. For instance, if we create a
graph such as 
$$
\xymatrix{
   {\bullet} \ar[dr] & & {\bullet} \ar[ll]\\
   & {\bullet} \ar[ur] & 
}
$$
as a simple graph \YAGS\  will normalize the graph as
$$
\xymatrix{
   {\bullet} \ar@{-}[dr] & & {\bullet} \ar@{-}[ll]\\
   & {\bullet} \ar@{-}[ur] & 
}
$$
For further examples see the following section.


\Section{Default Category}

There are several means to specify the category in which a new graph
will be created. There exists a <DefaultCategory> which tells \YAGS\  to
which category belongs any new graph by default. The <DefaultCategory> can be
changed using the following function.

\>SetDefaultGraphCategory( <C> ) F

Sets category C to be the default category for graphs. The default
category is used, for instance, when constructing new graphs. 

\beginexample
gap> SetDefaultGraphCategory(Graphs);
gap> g:=RandomGraph(4);
Graph( Category := Graphs, Order := 4, Size := 8, Adjacencies :=
[ [ 3, 4 ], [ 4 ], [ 1, 2, 3, 4 ], [ 2 ] ] )
\endexample

$$
\xymatrix{
   {\bullet} \ar@(dr,dl)[d] \ar[dr] & {\bullet} \ar[d]\\
   {\bullet} \ar@(ul,ur)[u] \ar[ur] & {\bullet} \ar[l] 
}
$$

RandomGraph creates a random graphs belonging to the category
graphs. The above graph has loops which are not permitted in
simple graphs.

\beginexample
gap> SetDefaultGraphCategory(SimpleGraphs);
gap> g:=CopyGraph(g);
Graph( Category := SimpleGraphs, Order := 4, Size := 5, Adjacencies :=
[ [ 3, 4 ], [ 3, 4 ], [ 1, 2, 4 ], [ 1, 2, 3 ] ] )
\endexample

Now G is a simple graph.

$$
\xymatrix{
   {\bullet} \ar[dr] & & {\bullet} \ar[ll]\\
   & {\bullet} \ar[ur] & 
}
$$




In order to handle graphs with different categories there two
functions available.

\>GraphCategory( [<G>, ... ] ) F

Returns the minimal common category to a list of graphs. See
Section "Categories" for the relationship among categories.
 
If the list is empty the default category is returned. 



\>TargetGraphCategory( [<G>, ... ] ) F

Returns the category which will be used to process a list of
graphs. If an option category has been given it will return that
category. Otherwise it will behave as Function <GraphCategory>
("GraphCategory"). See Section "Categories" for the relationship
among categories. 



Finally we can test if a single graph belongs to a given category.

\>in( <G>, <C> ) O

Returns `true' if graph <G> belongs to category <C> and `false' otherwise.



\Section{Atributes and properties of graphs}

The following are functions to obtain atributes and properties of
graphs.

\>AdjMatrix( <G> ) A

Returns the adjacency matrix of graph <G>.

\beginexample
gap> AdjMatrix(CycleGraph(4));
[ [ false, true, false, true ], [ true, false, true, false ], 
  [ false, true, false, true ], [ true, false, true, false ] ]
\endexample

--map

\>Order( <G> ) A

Returns the number of vertices, of graph <G>.

\beginexample
gap> Order(Icosahedron);
12
\endexample

--map

\>Size( <G> ) A

Returns the number of edges of graph <G>.

\beginexample
gap> Size(Icosahedron);
30
\endexample

--map

\>VertexNames( <G> ) A

Return the list of names of the vertices of <G>. The vertices of a graph in \YAGS\ are always 
$\{1,2, \ldots, Order(G)\}$, but depending on how the graph was constructed, its vertices may 
have also some <names>, that help us identify the origin of the vertices. \YAGS\ will always try 
to store meaninful names for the vertices. For example, in the case of the LineGraph, the vertex 
names of the new graph are the edges of the old graph.

\beginexample
gap> g:=LineGraph(DiamondGraph);          
Graph( Category := SimpleGraphs, Order := 5, Size := 8, Adjacencies := 
[ [ 2, 3, 4 ], [ 1, 3, 4, 5 ], [ 1, 2, 5 ], [ 1, 2, 5 ], [ 2, 3, 4 ] ] )
gap> VertexNames(g);
[ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 2, 3 ], [ 3, 4 ] ]
gap> Edges(DiamondGraph);
[ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 2, 3 ], [ 3, 4 ] ]
\endexample

--map

\>IsCompleteGraph( <G> ) P

Returns `true' if graph <G> is a complete graph, `false' otherwise.
In a complete graph every pair of vertices is an edge.

--map

\>IsLoopless( <G> ) P

Returns `true' if graph <G> have no loops, `false' otherwise. Loops are edges 
from a vertex to itself.

--map

\>IsUndirected( <G> ) P

Returns `true' if graph <G> is an undirected graph, `false' otherwise.
Regardless of the categories that <G> belongs to, <G> is undirected if 
whenever `[x,y]' is an edge of <G>, `[y,x]' is also an egde of <G>.

--map

\>IsOriented( <G> ) P
\>QtfyIsOriented( <G> ) A

Returns `true' if graph <G> is an oriented graph, `false' otherwise.
Regardless of the categories that <G> belongs to, <G> is oriented if 
whenever `[x,y]' is an edge of <G>, `[y,x]' is not.

--map


\Section{Information about graphs}

The following functions give information regarding graphs.

\>IsSimple( <G> ) O

Returns `true' if graph <G> is a simple graph, `false' otherwise.
Regardless of the categories that <G> belongs to, <G> is simple if and only if 
<G> is undirected and loopless.

Returns `true' if the graph <G> is simple regardless of its category.

--map

\>QtfyIsSimple( <G> ) O

Returns how far is graph <G> from being simple.


\>Adjacency( <G>, <v> ) O

Returns the adjacency list of vertex <v> in <G>.

\beginexample
gap> g:=PathGraph(3);
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
gap> Adjacency(g,1);           
[ 2 ]
gap> Adjacency(g,2);
[ 1, 3 ]
\endexample

--map

\>Adjacencies( <G> ) O

Returns the adjacency lists of graph <G>.

\beginexample
gap> g:=PathGraph(3);
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
gap> Adjacencies(g);  
[ [ 2 ], [ 1, 3 ], [ 2 ] ]
\endexample

--map

\>VertexDegree( <G>, <v> ) O

Returns the degree of vertex <v> in Graph <G>. 

\beginexample
gap> g:=PathGraph(3);
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
gap> VertexDegree(g,1);
1
gap> VertexDegree(g,2);
2
\endexample

--map

\>VertexDegrees( <G> ) O

Returns the list of degrees of the vertices in graph <G>.

\beginexample
gap> g:=GemGraph;
Graph( Category := SimpleGraphs, Order := 5, Size := 7, Adjacencies := 
[ [ 2, 3, 4, 5 ], [ 1, 3 ], [ 1, 2, 4 ], [ 1, 3, 5 ], [ 1, 4 ] ] )
gap> VertexDegrees(g);
[ 4, 2, 3, 3, 2 ]
\endexample

--map

\>Edges( <G> ) O

Returns the list of edges of graph <G>.  

\beginexample
gap> Edges(CompleteGraph(4));
[ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 2, 3 ], [ 2, 4 ], [ 3, 4 ] ]
\endexample

--map


\Section{Creating graphs}

The following functions create new graphs from a variety of sources.

\>Graph( <R> ) O

Returns a new graph created from the record <R>. The record must provide the field <Category> 
and either the field <Adjacencies> or the field <AdjMatrix>

\beginexample
gap> Graph(rec(Category:=SimpleGraphs,Adjacencies:=[[2],[1]]));
Graph( Category := SimpleGraphs, Order := 2, Size := 1, Adjacencies := [ [ 2 ], [ 1 ] ] )
gap> Graph(rec(Category:=SimpleGraphs,AdjMatrix:=[[false, true],[true, false]]));
Graph( Category := SimpleGraphs, Order := 2, Size := 1, Adjacencies := [ [ 2 ], [ 1 ] ] )
\endexample

Its main purpose is to import graphs from files, which could have been 
previously exported using `PrintTo'.

\beginexample
gap> g:=CycleGraph(4);
Graph( Category := SimpleGraphs, Order := 4, Size := 4, Adjacencies := 
[ [ 2, 4 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3 ] ] )
gap> PrintTo("aux.g","h1:=",g,";");
gap> Read("aux.g");
gap> h1;
Graph( Category := SimpleGraphs, Order := 4, Size := 4, Adjacencies := 
[ [ 2, 4 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3 ] ] )
\endexample

--map

\>GraphByAdjMatrix( <M> ) F

Returns a new graph created from an adjacency matrix <M>. The matrix <M> must
be a square boolean matrix.

\beginexample
gap> m:=[ [ false, true, false ], [ true, false, true ], [ false, true, false ] ];;
gap> g:=GraphByAdjMatrix(m);
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
gap> AdjMatrix(g);
[ [ false, true, false ], [ true, false, true ], [ false, true, false ] ]
\endexample

Note, however, that the graph is forced to comply with the `TargetGraphCategory'.

\beginexample
gap> m:=[ [ true, true], [ false, false ] ];;
gap> g:=GraphByAdjMatrix(m);                
Graph( Category := SimpleGraphs, Order := 2, Size := 1, Adjacencies := [ [ 2 ], [ 1 ] ] )
gap> AdjMatrix(g);                          
[ [ false, true ], [ true, false ] ]
\endexample

--map

\>GraphByAdjacencies( <A> ) F

Returns a new graph having <A> as its list of adjacencies. The order of the created graph is 
`Length(A)', and the set of neighbors of vertex $x$ is $A[x]$. 

\beginexample
gap> GraphByAdjacencies([[2],[1,3],[2]]);      
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
\endexample

Note, however, that the graph is forced to comply with the `TargetGraphCategory'.

\beginexample
gap> GraphByAdjacencies([[1,2,3],[],[]]);
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2, 3 ], [ 1 ], [ 1 ] ] )
\endexample

--map

\>GraphByCompleteCover( <C> ) F

Returns the minimal graph where the elements of <C> are 
(the vertex sets of) complete subgraphs.

\beginexample
gap> GraphByCompleteCover([[1,2,3,4],[4,6,7]]); 
Graph( Category := SimpleGraphs, Order := 7, Size := 9, Adjacencies := 
[ [ 2, 3, 4 ], [ 1, 3, 4 ], [ 1, 2, 4 ], [ 1, 2, 3, 6, 7 ], [  ], [ 4, 7 ], 
  [ 4, 6 ] ] )
\endexample

--map

\>GraphByRelation( <V>, <R> ) F
\>GraphByRelation( <N>, <R> ) F

Returns a new graph created from a set of vertices $V$ and a binary relation $R$, 
where $x\sim y$ iff $R(x,y)=true$. In the second form, $N$ is an integer
and $V$ is assumed to be $\{1, 2, \ldots, N\}$.

\beginexample
gap> R:=function(x,y) return Intersection(x,y)<>[]; end;;          
gap> GraphByRelation([[1,2,3],[3,4,5],[5,6,7]],R);               
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
gap> GraphByRelation(8,function(x,y) return AbsInt(x-y)<=2; end); 
Graph( Category := SimpleGraphs, Order := 8, Size := 13, Adjacencies := 
[ [ 2, 3 ], [ 1, 3, 4 ], [ 1, 2, 4, 5 ], [ 2, 3, 5, 6 ], [ 3, 4, 6, 7 ], 
  [ 4, 5, 7, 8 ], [ 5, 6, 8 ], [ 6, 7 ] ] )
\endexample

--map

\>IntersectionGraph( <L> ) F

Returns the intersection graph of the family of sets <L>. This graph has a vertex for 
every set in <L>, and two such vertices are adjacent iff the corresponding sets have non-empty intersection.

\beginexample
gap> IntersectionGraph([[1,2,3],[3,4,5],[5,6,7]]);
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
\endexample

--map


The following functions create graphs from existing graphs

\>CopyGraph( <G> ) O

Returns a fresh copy of graph <G>. Only the order and adjacency information is copied, 
all other known attributes of <G> are not. Mainly used to transform a graph from one category 
to another. The new graph will be forced to comply with the `TargetGraphCategory'.

\beginexample
gap> g:=CompleteGraph(4);                         
Graph( Category := SimpleGraphs, Order := 4, Size := 6, Adjacencies := 
[ [ 2, 3, 4 ], [ 1, 3, 4 ], [ 1, 2, 4 ], [ 1, 2, 3 ] ] )
gap> g1:=CopyGraph(g:GraphCategory:=OrientedGraphs);
Graph( Category := OrientedGraphs, Order := 4, Size := 6, Adjacencies := 
[ [ 2, 3, 4 ], [ 3, 4 ], [ 4 ], [  ] ] )
gap> CopyGraph(g1:GraphCategory:=SimpleGraphs);     
Graph( Category := SimpleGraphs, Order := 4, Size := 6, Adjacencies := 
[ [ 2, 3, 4 ], [ 1, 3, 4 ], [ 1, 2, 4 ], [ 1, 2, 3 ] ] )
\endexample

--map

\>InducedSubgraph( <G>, <V> ) O

Returns the subgraph of graph <G> induced by the vertex set <V>.

\beginexample
gap> g:=CycleGraph(6);          
Graph( Category := SimpleGraphs, Order := 6, Size := 6, Adjacencies := 
[ [ 2, 6 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 4, 6 ], [ 1, 5 ] ] )
gap> InducedSubgraph(g,[3,4,6]);  
Graph( Category := SimpleGraphs, Order := 3, Size := 1, Adjacencies := 
[ [ 2 ], [ 1 ], [  ] ] )
\endexample

The order of the elements in <V> does matter.

\beginexample
gap> InducedSubgraph(g,[6,3,4]);  
Graph( Category := SimpleGraphs, Order := 3, Size := 1, Adjacencies := 
[ [  ], [ 3 ], [ 2 ] ] )
\endexample

--map

\>RemoveVertices( <G>, <V> ) O

Returns a new graph created from graph <G> by removing the vertices in list <V>.

\beginexample
gap> g:=PathGraph(5);
Graph( Category := SimpleGraphs, Order := 5, Size := 4, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 4 ] ] )
gap> RemoveVertices(g,[3]);
Graph( Category := SimpleGraphs, Order := 4, Size := 2, Adjacencies := 
[ [ 2 ], [ 1 ], [ 4 ], [ 3 ] ] )
gap> RemoveVertices(g,[1,3]);
Graph( Category := SimpleGraphs, Order := 3, Size := 1, Adjacencies := 
[ [  ], [ 3 ], [ 2 ] ] )
\endexample

--map

\>AddEdges( <G>, <E> ) O

Returns a new graph created from graph <G> by adding the edges in list <E>.

\beginexample
gap> g:=CycleGraph(4);   
Graph( Category := SimpleGraphs, Order := 4, Size := 4, Adjacencies := 
[ [ 2, 4 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3 ] ] )
gap> AddEdges(g,[[1,3]]);
Graph( Category := SimpleGraphs, Order := 4, Size := 5, Adjacencies := 
[ [ 2, 3, 4 ], [ 1, 3 ], [ 1, 2, 4 ], [ 1, 3 ] ] )
gap> AddEdges(g,[[1,3],[2,4]]);
Graph( Category := SimpleGraphs, Order := 4, Size := 6, Adjacencies := 
[ [ 2, 3, 4 ], [ 1, 3, 4 ], [ 1, 2, 4 ], [ 1, 2, 3 ] ] )
\endexample

--map

\>RemoveEdges( <G>, <E> ) O

Returns a new graph created from graph <G> by removing the edges in list <E>.

\beginexample
gap> g:=CompleteGraph(4);
Graph( Category := SimpleGraphs, Order := 4, Size := 6, Adjacencies := 
[ [ 2, 3, 4 ], [ 1, 3, 4 ], [ 1, 2, 4 ], [ 1, 2, 3 ] ] )
gap> RemoveEdges(g,[[1,2]]);
Graph( Category := SimpleGraphs, Order := 4, Size := 5, Adjacencies := 
[ [ 3, 4 ], [ 3, 4 ], [ 1, 2, 4 ], [ 1, 2, 3 ] ] )
gap> RemoveEdges(g,[[1,2],[3,4]]);
Graph( Category := SimpleGraphs, Order := 4, Size := 4, Adjacencies := 
[ [ 3, 4 ], [ 3, 4 ], [ 1, 2 ], [ 1, 2 ] ] )
\endexample

--map






