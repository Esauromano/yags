% This file was created automatically from allalpha.msk.
% DO NOT EDIT!
\Chapter{YAGS Functions Reference}

This chapter contains a complete list of all {\YAGS}'s functions, with definitions, in alphabetical order.

%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{AddEdges()}
%enddisplay
\>AddEdges( <G>, <E> ) O

Returns a new graph created from graph <G> by adding the edges in list <E>.

\beginexample
gap> g:=CycleGraph(4);   
Graph( Category := SimpleGraphs, Order := 4, Size := 4, Adjacencies := 
[ [ 2, 4 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3 ] ] )
gap> AddEdges(g,[[1,3]]);
Graph( Category := SimpleGraphs, Order := 4, Size := 5, Adjacencies := 
[ [ 2, 3, 4 ], [ 1, 3 ], [ 1, 2, 4 ], [ 1, 3 ] ] )
gap> AddEdges(g,[[1,3],[2,4]]);
Graph( Category := SimpleGraphs, Order := 4, Size := 6, Adjacencies := 
[ [ 2, 3, 4 ], [ 1, 3, 4 ], [ 1, 2, 4 ], [ 1, 2, 3 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{AddVerticesByAdjacencies()}
%enddisplay
\>AddVerticesByAdjacencies( <G>, <NewAdjList> ) O

Returns a new graph created from graph <G> by adding as many new vertices 
as `Length(<NewAdjList>)'. Each entry in <NewAdjList> is also a list: the list  
of neighbors of the corresponding new vertex.

\beginexample
gap> g:=PathGraph(5);
Graph( Category := SimpleGraphs, Order := 5, Size := 4, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 4 ] ] )
gap> AddVerticesByAdjacencies(g,[[1,2],[4,5]]); 
Graph( Category := SimpleGraphs, Order := 7, Size := 8, Adjacencies := 
[ [ 2, 6 ], [ 1, 3, 6 ], [ 2, 4 ], [ 3, 5, 7 ], [ 4, 7 ], [ 1, 2 ], [ 4, 5 ] ] )
gap> AddVerticesByAdjacencies(g,[[1,2,7],[4,5]]);
Graph( Category := SimpleGraphs, Order := 7, Size := 9, Adjacencies := 
[ [ 2, 6 ], [ 1, 3, 6 ], [ 2, 4 ], [ 3, 5, 7 ], [ 4, 7 ], [ 1, 2, 7 ], [ 4, 5, 6 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{Adjacencies()}
%enddisplay
\>Adjacencies( <G> ) O

Returns the adjacency lists of graph <G>.

\beginexample
gap> g:=PathGraph(3);
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
gap> Adjacencies(g);  
[ [ 2 ], [ 1, 3 ], [ 2 ] ]
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{Adjacency()}
%enddisplay
\>Adjacency( <G>, <x> ) O

Returns the adjacency list of vertex <x> in <G>.

\beginexample
gap> g:=PathGraph(3);
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
gap> Adjacency(g,1);           
[ 2 ]
gap> Adjacency(g,2);
[ 1, 3 ]
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{AdjMatrix()}
%enddisplay
\>AdjMatrix( <G> ) A

Returns the adjacency matrix of graph <G>.

\beginexample
gap> AdjMatrix(CycleGraph(4));
[ [ false, true, false, true ], [ true, false, true, false ], 
  [ false, true, false, true ], [ true, false, true, false ] ]
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{AGraph}
%enddisplay
\>`AGraph' V

A 4-cycle with two pendant vertices on consecutive vertices of the cycle.

\beginexample
gap> AGraph;
Graph( Category := SimpleGraphs, Order := 6, Size := 6, Adjacencies := 
[ [ 2 ], [ 1, 3, 5 ], [ 2, 4 ], [ 3, 5 ], [ 2, 4, 6 ], [ 5 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{AntennaGraph}
%enddisplay
\>`AntennaGraph' V

A `HouseGraph' with a pendant vertex (antenna) on the roof.

\beginexample
gap> AntennaGraph;
Graph( Category := SimpleGraphs, Order := 6, Size := 7, Adjacencies := 
[ [ 2, 4, 5 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3, 5 ], [ 1, 4, 6 ], [ 5 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{AutGroupGraph()}
%enddisplay
\>AutGroupGraph( <G> ) A

\indextt{AutomorphismGroup}
Returns the group of automorphisms of the graph <G>. 
There is also a synonym for this attribute which 
is `AutomorphismGroup( <G> )'.

\beginexample
gap> AutGroupGraph(Icosahedron);
Group([ (1,3,2,10,9,12,8,7,5,4)(6,11), (1,7,9)(2,4,12)(3,11,10)(5,8,6) ])
gap> AutomorphismGroup(Icosahedron);
Group([ (1,3,2,10,9,12,8,7,5,4)(6,11), (1,7,9)(2,4,12)(3,11,10)(5,8,6) ])
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{BackTrack()}
%enddisplay
\>BackTrack( <L>, <Opts>, <Chk>, <Done>, <Extra> ) O

Generic, user-customizable backtracking algorithm.

A backtraking algorithm explores a decision tree in search for solutions to a 
combinatorial problem. The combinatorial problem and the search strategy are specified 
by the parameters:

<L> is just a list that `BackTrack' uses to keep track of solutions and partial solutions. 
It is usually set to the empty list as a starting point. 
After a solution is found, it is returned *and* stored in <L>. This value of <L> is then used 
as a starting point to search for the next solution in case `BackTrack' is called again. 
Partial solutions are also stored in <L> during the execution of `BackTrack'.

<Extra> may be any object, list, record, etc. `BackTrack' only uses it to pass this data to 
the user-defined functions <Opts>, <Chk> and <Done>, therefore offering you a way to share data 
between your functions.

<Opts>`:=function(L,extra)' must return the list of continuation options (childs) one has after some 
partial solution (node) <L> has been reached within the decision tree (<Opts> may use the extra data 
<Extra> as needed). Each of the values in the list returned by <Opts>`(L,extra)' will be tried as 
possible continuations of the partial solution <L>. If <Opts>`(L,extra)' always returns the same list, 
you can put that list in place of the parameter <Opts>.

<Chk>`:=function(L,extra)' must evaluate the partial solution <L> possibly using the extra data 
<Extra> and must return `false' when it knows that <L> can not be extended to a solution 
of the problem. Otherwise it returns `true'. <Chk> may assume that <L>`{[1..Length(L)-1]}' already 
passed the test.

<Done>`:=function(L,extra)' returns `true' if <L> is already a complete solution and `false' otherwise. 
In many combinatorial problems, any partial solution of certain length <n> is also a solution 
(and viceversa), so if this is your case, you can put that length in place of the parameter <Done>.

The following example uses `BackTrack' in its simplest form to compute derrangements 
(permutations of a set, where none of the elements appears in its original position).

\beginexample
gap> N:=4;;L:=[];;extra:=[];;opts:=[1..N];;done:=N;;
gap> chk:=function(L,extra) local i; i:=Length(L); 
>           return not L[i] in L{[1..i-1]} and L[i]<> i; end;;
gap> BackTrack(L,opts,chk,done,extra);
[ 2, 1, 4, 3 ]
gap> BackTrack(L,opts,chk,done,extra);
[ 2, 3, 4, 1 ]
gap> BackTrack(L,opts,chk,done,extra);
[ 2, 4, 1, 3 ]
gap> BackTrack(L,opts,chk,done,extra);
[ 3, 1, 4, 2 ]
gap> BackTrack(L,opts,chk,done,extra);
[ 3, 4, 1, 2 ]
gap> BackTrack(L,opts,chk,done,extra);
[ 3, 4, 2, 1 ]
gap> BackTrack(L,opts,chk,done,extra);
[ 4, 1, 2, 3 ]
gap> BackTrack(L,opts,chk,done,extra);
[ 4, 3, 1, 2 ]
gap> BackTrack(L,opts,chk,done,extra);
[ 4, 3, 2, 1 ]
gap> BackTrack(L,opts,chk,done,extra);
fail
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{BackTrackBag()}
%enddisplay
\>BackTrackBag( <Opts>, <Chk>, <Done>, <Extra> ) O

Returns the list of all solutions that would be returned one at a time by 
`Backtrack'.

The following example computes all derrangements of order 4.

\beginexample
gap> N:=4;;
gap> chk:=function(L,extra) local i; i:=Length(L); 
>           return not L[i] in L{[1..i-1]} and L[i]<> i; end;;
gap> BackTrackBag([1..N],chk,N,[]);
[ [ 2, 1, 4, 3 ], [ 2, 3, 4, 1 ], [ 2, 4, 1, 3 ], [ 3, 1, 4, 2 ], 
  [ 3, 4, 1, 2 ], [ 3, 4, 2, 1 ], [ 4, 1, 2, 3 ], [ 4, 3, 1, 2 ], 
  [ 4, 3, 2, 1 ] ]
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{Basement()}
%enddisplay
\>Basement( <G>, <KnG>, <x> ) O
\>Basement( <G>, <KnG>, <V> ) O

Given a graph <G>, some iterated clique graph <KnG> of <G> and a vertex <x> of <KnG>,
the operation returns the <basement> of <x> with respect to <G> \cite{Piz04}. 
Loosely speaking, the basement of <x> is the set of vertices of <G> that constitutes 
the iterated clique <x>.

\beginexample
gap> g:=Icosahedron;;Cliques(g);
[ [ 1, 2, 3 ], [ 1, 2, 6 ], [ 1, 3, 4 ], [ 1, 4, 5 ], [ 1, 5, 6 ], 
  [ 4, 5, 7 ], [ 4, 7, 11 ], [ 5, 7, 8 ], [ 7, 8, 12 ], [ 7, 11, 12 ], 
  [ 5, 6, 8 ], [ 6, 8, 9 ], [ 8, 9, 12 ], [ 2, 6, 9 ], [ 2, 9, 10 ], 
  [ 9, 10, 12 ], [ 2, 3, 10 ], [ 3, 10, 11 ], [ 10, 11, 12 ], [ 3, 4, 11 ] ]
gap> kg:=CliqueGraph(g);; k2g:=CliqueGraph(kg);;
gap> Basement(g,k2g,1);Basement(g,k2g,2);
[ 1, 2, 3, 4, 5, 6 ]
[ 1, 2, 3, 4, 6, 10 ]
\endexample

In its second form, <V> is a set of vertices of <KnG>, in that case, the basement is 
simply the union of the basements of the vertices in <V>.

\beginexample
gap> Basement(g,k2g,[1,2]);              
[ 1, 2, 3, 4, 5, 6, 10 ]
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{BoxProduct()}
%enddisplay
\>BoxProduct( <G>, <H> ) O

Returns the box product, <G> $\square$ <H>, of two graphs <G> and <H> 
(also known as the cartesian product).

The box product is calculated as follows:

For each pair of vertices $x \in G, y \in H$ we create a vertex
$(x,y)$. Given two such vertices $(x,y)$ and $(x',y')$ they are
adjacent <iff> $x = x'$ and $y \sim y'$ or $x \sim x'$ and $y = y'$.

\beginexample
gap> g:=PathGraph(3);h:=CycleGraph(4);
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
Graph( Category := SimpleGraphs, Order := 4, Size := 4, Adjacencies := 
[ [ 2, 4 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3 ] ] )
gap> gh:=BoxProduct(g,h);           
Graph( Category := SimpleGraphs, Order := 12, Size := 20, Adjacencies := 
[ [ 2, 4, 5 ], [ 1, 3, 6 ], [ 2, 4, 7 ], [ 1, 3, 8 ], [ 1, 6, 8, 9 ], 
  [ 2, 5, 7, 10 ], [ 3, 6, 8, 11 ], [ 4, 5, 7, 12 ], [ 5, 10, 12 ], 
  [ 6, 9, 11 ], [ 7, 10, 12 ], [ 8, 9, 11 ] ] )
gap> VertexNames(gh);
[ [ 1, 1 ], [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 2, 1 ], [ 2, 2 ], [ 2, 3 ], 
  [ 2, 4 ], [ 3, 1 ], [ 3, 2 ], [ 3, 3 ], [ 3, 4 ] ]
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{BoxTimesProduct()}
%enddisplay
\>BoxTimesProduct( <G>, <H> ) O

Returns the boxtimes product of two graphs <G> and <H>, <G>
$\boxtimes$ <H> (also known as the strong product). 

The boxtimes product is calculated as follows:

For each pair of vertices $x \in G, y \in H$ we create a vertex
$(x,y)$. Given two such vertices $(x,y)$ and $(x',y')$ such that
$(x,y) \neq (x',y')$ they are adjacent <iff> $x \simeq x'$ and $y
\simeq y'$. 

\beginexample
gap> g:=PathGraph(3);h:=CycleGraph(4);
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
Graph( Category := SimpleGraphs, Order := 4, Size := 4, Adjacencies := 
[ [ 2, 4 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3 ] ] )
gap> gh:=BoxTimesProduct(g,h);      
Graph( Category := SimpleGraphs, Order := 12, Size := 36, Adjacencies := 
[ [ 2, 4, 5, 6, 8 ], [ 1, 3, 5, 6, 7 ], [ 2, 4, 6, 7, 8 ], [ 1, 3, 5, 7, 8 ], 
  [ 1, 2, 4, 6, 8, 9, 10, 12 ], [ 1, 2, 3, 5, 7, 9, 10, 11 ], 
  [ 2, 3, 4, 6, 8, 10, 11, 12 ], [ 1, 3, 4, 5, 7, 9, 11, 12 ], 
  [ 5, 6, 8, 10, 12 ], [ 5, 6, 7, 9, 11 ], [ 6, 7, 8, 10, 12 ], 
  [ 5, 7, 8, 9, 11 ] ] )
gap> VertexNames(gh);                 
[ [ 1, 1 ], [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 2, 1 ], [ 2, 2 ], [ 2, 3 ], 
  [ 2, 4 ], [ 3, 1 ], [ 3, 2 ], [ 3, 3 ], [ 3, 4 ] ]
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{BullGraph}
%enddisplay
\>`BullGraph' V

A triangle with two pendant vertices (horns).

\beginexample
gap> BullGraph;    
Graph( Category := SimpleGraphs, Order := 5, Size := 5, Adjacencies := 
[ [ 2 ], [ 1, 3, 4 ], [ 2, 4 ], [ 2, 3, 5 ], [ 4 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{CayleyGraph()}
%enddisplay
\>CayleyGraph( <Grp>, <Elms> ) O
\>CayleyGraph( <Grp> ) O

Returns the graph $G$ whose vertices are the elements of the group <Grp> 
such that $x$ is adjacent to $y$ iff $x*g=y$ for some $g$ in the list <Elms>.
if <Elms> is not provided, then the generators of <G> are used instead.

\beginexample
gap> grp:=Group((1,2,3),(1,2));    
Group([ (1,2,3), (1,2) ])
gap> CayleyGraph(grp);             
Graph( Category := SimpleGraphs, Order := 6, Size := 9, Adjacencies := 
[ [ 3, 4, 5 ], [ 3, 5, 6 ], [ 1, 2, 6 ], [ 1, 5, 6 ], [ 1, 2, 4 ], 
  [ 2, 3, 4 ] ] )
gap> CayleyGraph(grp,[(1,2),(2,3)]);
Graph( Category := SimpleGraphs, Order := 6, Size := 6, Adjacencies := 
[ [ 2, 3 ], [ 1, 5 ], [ 1, 4 ], [ 3, 6 ], [ 2, 6 ], [ 4, 5 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{ChairGraph}
%enddisplay
\>`ChairGraph' V

A tree with degree sequence 3,2,1,1,1.

\beginexample
gap> ChairGraph;
Graph( Category := SimpleGraphs, Order := 5, Size := 4, Adjacencies := 
[ [ 2 ], [ 1, 3, 4 ], [ 2 ], [ 2, 5 ], [ 4 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{Circulant()}
%enddisplay
\>Circulant( <n>, <Jumps> ) O

Returns the graph G whose vertices are [1..n] such that x is adjacent 
to y iff x+z=y mod n for some z the list of <Jumps>.

\beginexample
gap> Circulant(6,[1,2]);   
Graph( Category := SimpleGraphs, Order := 6, Size := 12, Adjacencies := 
[ [ 2, 3, 5, 6 ], [ 1, 3, 4, 6 ], [ 1, 2, 4, 5 ], [ 2, 3, 5, 6 ], 
  [ 1, 3, 4, 6 ], [ 1, 2, 4, 5 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{ClawGraph}
%enddisplay
\>`ClawGraph' V

The graph on 4 vertices, 3 edges, and maximum degree 3. 

\beginexample
gap> ClawGraph;
Graph( Category := SimpleGraphs, Order := 4, Size := 3, Adjacencies :=
[ [ 2, 3, 4 ], [ 1 ], [ 1 ], [ 1 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{CliqueGraph()}
%enddisplay
\>CliqueGraph( <G> ) A
\>CliqueGraph( <G>, <maxNumCli> ) O

Returns the intersection graph of all the (maximal) cliques of <G>.

The additional parameter <maxNumCli> aborts the computation when <maxNumCli> 
cliques are found, even if they are all the cliques of <G>. 
If the bound <maxNumCli> is reached, <fail> is returned.

\beginexample
gap> CliqueGraph(Octahedron);   
Graph( Category := SimpleGraphs, Order := 8, Size := 24, Adjacencies := 
[ [ 2, 3, 4, 5, 6, 7 ], [ 1, 3, 4, 5, 6, 8 ], [ 1, 2, 4, 5, 7, 8 ], 
  [ 1, 2, 3, 6, 7, 8 ], [ 1, 2, 3, 6, 7, 8 ], [ 1, 2, 4, 5, 7, 8 ], 
  [ 1, 3, 4, 5, 6, 8 ], [ 2, 3, 4, 5, 6, 7 ] ] )
gap> CliqueGraph(Octahedron,9); 
Graph( Category := SimpleGraphs, Order := 8, Size := 24, Adjacencies := 
[ [ 2, 3, 4, 5, 6, 7 ], [ 1, 3, 4, 5, 6, 8 ], [ 1, 2, 4, 5, 7, 8 ], 
  [ 1, 2, 3, 6, 7, 8 ], [ 1, 2, 3, 6, 7, 8 ], [ 1, 2, 4, 5, 7, 8 ], 
  [ 1, 3, 4, 5, 6, 8 ], [ 2, 3, 4, 5, 6, 7 ] ] )
gap> CliqueGraph(Octahedron,8);
fail
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{CliqueNumber()}
%enddisplay
\>CliqueNumber( <G> ) A

Returns the order, $\omega(G)$, of a maximum clique of <G>. 

\beginexample
gap> g:=SunGraph(4);
Graph( Category := SimpleGraphs, Order := 8, Size := 14, Adjacencies := 
[ [ 2, 8 ], [ 1, 3, 4, 6, 8 ], [ 2, 4 ], [ 2, 3, 5, 6, 8 ], [ 4, 6 ], 
  [ 2, 4, 5, 7, 8 ], [ 6, 8 ], [ 1, 2, 4, 6, 7 ] ] )
gap> CliqueNumber(g);
4
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{Cliques()}
%enddisplay
\>Cliques( <G> ) A
\>Cliques( <G>, <maxNumCli> ) O

Returns the set of all (maximal) cliques of a graph <G>. A clique is a maximal complete subgraph.
Here, we use the Bron-Kerbosch algorithm \cite{BK73}.
 
In the second form, It stops computing cliques after <maxNumCli> of them have been found.

\beginexample
gap> Cliques(Octahedron);  
[ [ 1, 3, 5 ], [ 1, 3, 6 ], [ 1, 4, 5 ], [ 1, 4, 6 ], [ 2, 3, 5 ], 
  [ 2, 3, 6 ], [ 2, 4, 5 ], [ 2, 4, 6 ] ]
gap> Cliques(Octahedron,4);
[ [ 1, 3, 5 ], [ 1, 3, 6 ], [ 1, 4, 5 ], [ 1, 4, 6 ] ]
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{ComplementGraph()}
%enddisplay
\>ComplementGraph( <G> ) A

Returns the new graph <H> such that  $V(H)=V(G)$ and 
$xy\in E(H) \iff xy \not\in E(G)$.

\beginexample 
gap> g:=ClawGraph;
Graph( Category := SimpleGraphs, Order := 4, Size := 3, Adjacencies :=
[ [ 2, 3, 4 ], [ 1 ], [ 1 ], [ 1 ] ] )
gap> ComplementGraph(g);
Graph( Category := SimpleGraphs, Order := 4, Size := 3, Adjacencies :=
[ [  ], [ 3, 4 ], [ 2, 4 ], [ 2, 3 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{CompleteBipartiteGraph()}
%enddisplay
\>CompleteBipartiteGraph( <n>, <m> ) F

Returns the complete bipartite whose parts have order <n> and <m> respectively. 
This is the joint (Zykov sum) of two discrete graphs of order <n> and <m>. 

\beginexample
gap> CompleteBipartiteGraph(2,3);
Graph( Category := SimpleGraphs, Order := 5, Size := 6, Adjacencies :=
[ [ 3, 4, 5 ], [ 3, 4, 5 ], [ 1, 2 ], [ 1, 2 ], [ 1, 2 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{CompleteGraph()}
%enddisplay
\>CompleteGraph( <n> ) F

Returns the complete graph of order <n>. A complete graph is a graph
where all vertices are connected to each other.

\beginexample
gap> CompleteGraph(4);
Graph( Category := SimpleGraphs, Order := 4, Size := 6, Adjacencies :=
[ [ 2, 3, 4 ], [ 1, 3, 4 ], [ 1, 2, 4 ], [ 1, 2, 3 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{CompletelyParedGraph()}
%enddisplay
\>CompletelyParedGraph( <G> ) O

Returns the completely pared graph of <G>, which is obtained by repeatedly applying 
`ParedGraph' until no more dominated vertices remain. 

\beginexample
gap> g:=PathGraph(6);
Graph( Category := SimpleGraphs, Order := 6, Size := 5, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 4, 6 ], [ 5 ] ] )
gap> CompletelyParedGraph(g);
Graph( Category := SimpleGraphs, Order := 1, Size := 0, Adjacencies := 
[ [  ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{CompleteMultipartiteGraph()}
%enddisplay
\>CompleteMultipartiteGraph( <n1>, <n2> [, <n3> ...] ) F

Returns the complete multipartite graph where the orders of the parts are 
<n1>, <n2>, ... It is also the Zykov sum of discrete graphs of order <n1>, <n2>, ...

\beginexample
gap> CompleteMultipartiteGraph(2,2,2);
Graph( Category := SimpleGraphs, Order := 6, Size := 12, Adjacencies :=
[ [ 3, 4, 5, 6 ], [ 3, 4, 5, 6 ], [ 1, 2, 5, 6 ], [ 1, 2, 5, 6 ],
 [ 1, 2, 3, 4 ], [ 1, 2, 3, 4 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{CompletesOfGivenOrder()}
%enddisplay
\>CompletesOfGivenOrder( <G>, <Ord> ) O

Returns the list of vertex sets of all complete subgraphs of order <Ord> of <G>.

\beginexample
gap> g:=SunGraph(4);
Graph( Category := SimpleGraphs, Order := 8, Size := 14, Adjacencies :=
[ [ 2, 8 ], [ 1, 3, 4, 6, 8 ], [ 2, 4 ], [ 2, 3, 5, 6, 8 ], [ 4, 6 ],
  [ 2, 4, 5, 7, 8 ], [ 6, 8 ], [ 1, 2, 4, 6, 7 ] ] )
gap> CompletesOfGivenOrder(g,3);
[ [ 1, 2, 8 ], [ 2, 3, 4 ], [ 2, 4, 6 ], [ 2, 4, 8 ], [ 2, 6, 8 ],
  [ 4, 5, 6 ], [ 4, 6, 8 ], [ 6, 7, 8 ] ]
gap> CompletesOfGivenOrder(g,4);
[ [ 2, 4, 6, 8 ] ]
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{Composition()}
%enddisplay
\>Composition( <G>, <H> ) O

Returns the composition $G[H]$ of two graphs <G> and <H>.

A composition of graphs is obtained by calculating the GraphSum
of <G> with <Order(G)> copies of <H>, $G[H] = GraphSum(G, [H, \ldots, H])$.

\beginexample
gap> g:=CycleGraph(4);;h:=DiscreteGraph(2);;                  
gap> Composition(g,h);                      
Graph( Category := SimpleGraphs, Order := 8, Size := 16, Adjacencies := 
[ [ 3, 4, 7, 8 ], [ 3, 4, 7, 8 ], [ 1, 2, 5, 6 ], [ 1, 2, 5, 6 ], 
  [ 3, 4, 7, 8 ], [ 3, 4, 7, 8 ], [ 1, 2, 5, 6 ], [ 1, 2, 5, 6 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{Cone()}
%enddisplay
\>Cone( <G> ) O

Returns the cone of graph <G>. The cone of <G> is the graph 
obtained from <G> by adding a new vertex which is adjacent to every 
vertex of <G>. The new vertex is the first one in the new graph.

\beginexample 
gap> Cone(CycleGraph(4));
Graph( Category := SimpleGraphs, Order := 5, Size := 8, Adjacencies := 
[ [ 2, 3, 4, 5 ], [ 1, 3, 5 ], [ 1, 2, 4 ], [ 1, 3, 5 ], [ 1, 2, 4 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{ConnectedComponents()}
%enddisplay
\>ConnectedComponents( <G> ) A

Returns the connected components of <G>.


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{ConnectedGraphsOfGivenOrder()}
%enddisplay
\>ConnectedGraphsOfGivenOrder( <n> ) O

Returns the list of all connected graphs of order <n> (upto isomorphism).
This operation uses Brendan McKay's data published here: 
\URL{https://cs.anu.edu.au/people/Brendan.McKay/data/graphs.html}. 

These data are included with the {\YAGS} distribution in its `data' directory.
Hence this operation simply reads the corresponding file in that directory using
`ImportGraph6( <Filename> )'. Therefore, the integer <n> must be in the range 
from 1 upto 9. Data for graphs on 10 vertices is also available, but not included 
with {\YAGS}, it may not be practical to use that data, but if you would like to try, 
all you have to do is to copy (and to uncompress) the corresponding file into the 
directory `<YAGS-Directory>/data'.

\beginexample
gap> ConnectedGraphsOfGivenOrder(3);
[ Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
    [ [ 3 ], [ 3 ], [ 1, 2 ] ] ), Graph( Category := SimpleGraphs, Order := 
    3, Size := 3, Adjacencies := [ [ 2, 3 ], [ 1, 3 ], [ 1, 2 ] ] ) ]
gap> ConnectedGraphsOfGivenOrder(4);
[ Graph( Category := SimpleGraphs, Order := 4, Size := 3, Adjacencies := 
    [ [ 4 ], [ 4 ], [ 4 ], [ 1, 2, 3 ] ] ), 
  Graph( Category := SimpleGraphs, Order := 4, Size := 3, Adjacencies := 
    [ [ 3, 4 ], [ 4 ], [ 1 ], [ 1, 2 ] ] ), 
  Graph( Category := SimpleGraphs, Order := 4, Size := 4, Adjacencies := 
    [ [ 3, 4 ], [ 4 ], [ 1, 4 ], [ 1, 2, 3 ] ] ), 
  Graph( Category := SimpleGraphs, Order := 4, Size := 4, Adjacencies := 
    [ [ 3, 4 ], [ 3, 4 ], [ 1, 2 ], [ 1, 2 ] ] ), 
  Graph( Category := SimpleGraphs, Order := 4, Size := 5, Adjacencies := 
    [ [ 3, 4 ], [ 3, 4 ], [ 1, 2, 4 ], [ 1, 2, 3 ] ] ), 
  Graph( Category := SimpleGraphs, Order := 4, Size := 6, Adjacencies := 
    [ [ 2, 3, 4 ], [ 1, 3, 4 ], [ 1, 2, 4 ], [ 1, 2, 3 ] ] ) ]
gap> Length(ConnectedGraphsOfGivenOrder(9));
261080
gap> ConnectedGraphsOfGivenOrder(10);       
#W Unreadable File: /opt/gap4r7/pkg/yags/data/graph10c.g6
fail
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{Coordinates()}
%enddisplay
\>Coordinates( <G> ) O

Gets the coordinates of the vertices of <G>, which are used to draw <G> 
by `Draw( <G> )'. If the coordinates have not been previously set, `Coordinates' 
returns <fail>.


\beginexample
gap> g:=CycleGraph(4);;
gap> Coordinates(g);
fail
gap> SetCoordinates(g,[[-10,-10 ],[-10,20],[20,-10 ], [20,20]]);
gap> Coordinates(g);
[ [ -10, -10 ], [ -10, 20 ], [ 20, -10 ], [ 20, 20 ] ]
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{CopyGraph()}
%enddisplay
\>CopyGraph( <G> ) O

Returns a fresh copy of graph <G>. Only the order and adjacency information is copied, 
all other known attributes of <G> are not. Mainly used to transform a graph from one category 
to another. The new graph will be forced to comply with the `TargetGraphCategory'.

\beginexample
gap> g:=CompleteGraph(4);                         
Graph( Category := SimpleGraphs, Order := 4, Size := 6, Adjacencies := 
[ [ 2, 3, 4 ], [ 1, 3, 4 ], [ 1, 2, 4 ], [ 1, 2, 3 ] ] )
gap> g1:=CopyGraph(g:GraphCategory:=OrientedGraphs);
Graph( Category := OrientedGraphs, Order := 4, Size := 6, Adjacencies := 
[ [ 2, 3, 4 ], [ 3, 4 ], [ 4 ], [  ] ] )
gap> CopyGraph(g1:GraphCategory:=SimpleGraphs);     
Graph( Category := SimpleGraphs, Order := 4, Size := 6, Adjacencies := 
[ [ 2, 3, 4 ], [ 1, 3, 4 ], [ 1, 2, 4 ], [ 1, 2, 3 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{CuadraticRingGraph()}
%enddisplay
\>CuadraticRingGraph( <Rng> ) O

Returns the graph G whose vertices are the elements of <Rng> 
such that x is adjacent to y iff x+z^2=y for some z in <Rng>.

\beginexample
gap> CuadraticRingGraph(ZmodnZ(8));
Graph( Category := SimpleGraphs, Order := 8, Size := 12, Adjacencies := 
[ [ 2, 5, 8 ], [ 1, 3, 6 ], [ 2, 4, 7 ], [ 3, 5, 8 ], [ 1, 4, 6 ], 
  [ 2, 5, 7 ], [ 3, 6, 8 ], [ 1, 4, 7 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{Cube}
%enddisplay
\>`Cube' V

The 1-skeleton of Plato's cube.

\beginexample
gap> Cube;
Graph( Category := SimpleGraphs, Order := 8, Size := 12, Adjacencies :=
[ [ 2, 3, 5 ], [ 1, 4, 6 ], [ 1, 4, 7 ], [ 2, 3, 8 ], [ 1, 6, 7 ],
 [ 2, 5, 8 ], [ 3, 5, 8 ], [ 4, 6, 7 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{CubeGraph()}
%enddisplay
\>CubeGraph( <n> ) F

Returns the hypercube of dimension <n>. This is the box product (cartesian product) 
of $n$ copies of $K_2$ (an edge).

\beginexample
gap> CubeGraph(3);
Graph( Category := SimpleGraphs, Order := 8, Size := 12, Adjacencies :=
[ [ 2, 3, 5 ], [ 1, 4, 6 ], [ 1, 4, 7 ], [ 2, 3, 8 ], [ 1, 6, 7 ],
[ 2, 5, 8 ], [ 3, 5, 8 ], [ 4, 6, 7 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{CycleGraph()}
%enddisplay
\>CycleGraph( <n> ) F

Returns the cyclic graph on <n> vertices. 

\beginexample
gap> CycleGraph(5);
Graph( Category := SimpleGraphs, Order := 5, Size := 5, Adjacencies :=
[ [ 2, 5 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 1, 4 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{CylinderGraph()}
%enddisplay
\>CylinderGraph( <b>, <h> ) F

Returns a cylinder of base <b> and height <h>. 
The order of this graph is <b>(<h>+1) and it is constructed by taking 
<h>+1 copies of the cyclic graph on <b> vertices, ordering these cycles linearly and then 
joining consecutive cycles by a zigzagging (2<b>)-cycle. This graph is a triangulation of the 
cylinder where all internal vertices are of degree 6 and the border vertices are of degree 4.

\beginexample
gap> g:=CylinderGraph(4,1);
Graph( Category := SimpleGraphs, Order := 8, Size := 16, Adjacencies := 
[ [ 2, 4, 5, 6 ], [ 1, 3, 6, 7 ], [ 2, 4, 7, 8 ], [ 1, 3, 5, 8 ], 
  [ 1, 4, 6, 8 ], [ 1, 2, 5, 7 ], [ 2, 3, 6, 8 ], [ 3, 4, 5, 7 ] ] )
gap> g:=CylinderGraph(4,2);
Graph( Category := SimpleGraphs, Order := 12, Size := 28, Adjacencies := 
[ [ 2, 4, 5, 6 ], [ 1, 3, 6, 7 ], [ 2, 4, 7, 8 ], [ 1, 3, 5, 8 ], 
  [ 1, 4, 6, 8, 9, 10 ], [ 1, 2, 5, 7, 10, 11 ], [ 2, 3, 6, 8, 11, 12 ], 
  [ 3, 4, 5, 7, 9, 12 ], [ 5, 8, 10, 12 ], [ 5, 6, 9, 11 ], [ 6, 7, 10, 12 ], 
  [ 7, 8, 9, 11 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{DartGraph}
%enddisplay
\>`DartGraph' V

A diamond with a pendant vertex and maximum degree 4.

\beginexample
gap> DartGraph; 
Graph( Category := SimpleGraphs, Order := 5, Size := 6, Adjacencies := 
[ [ 2 ], [ 1, 3, 4, 5 ], [ 2, 4, 5 ], [ 2, 3 ], [ 2, 3 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{DeclareQtfyProperty()}
%enddisplay
\>DeclareQtfyProperty( <Name>, <Filter> ) F

For internal use. 

Declares a {\YAGS} quantifiable property named <Name> for filter <Filter>. 
This in turns, declares a boolean {\GAP} property <Name> and an integer {\GAP} attribute <QtfyName>.  

The user must provide the method <Name>(<Obj>, <qtfy>). If <qtfy> is false,
the method must return a boolean indicating whether the property holds, otherwise,
the method must return a non-negative integer quantifying how far is the object from satisfying the property. 
In the latter case, returning 0 actually means that the object does satisfy the property.

\beginexample
gap> DeclareQtfyProperty("Is2Regular",Graphs);
gap> InstallMethod(Is2Regular,"for graphs",true,[Graphs,IsBool],0,
> function(G,qtfy)
>   local x,count;
>   count:=0;
>   for x in Vertices(G) do
>     if VertexDegree(G,x)<> 2 then 
>       if not qtfy then
>         return false;
>       fi;
>         count:=count+1;
>     fi;
>   od;
>   if not qtfy then return true; fi;
>   return count;
> end);
gap> Is2Regular(CycleGraph(4));
true
gap> QtfyIs2Regular(CycleGraph(4));
0
gap> Is2Regular(DiamondGraph);     
false
gap> QtfyIs2Regular(DiamondGraph);
2
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{Diameter()}
%enddisplay
\>Diameter( <G> ) A

Returns the maximum among the distances between pairs of
vertices of <G>.

\beginexample
gap> g:=CycleGraph(5);
Graph( Category := SimpleGraphs, Order := 5, Size := 5, Adjacencies :=
[ [ 2, 5 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 1, 4 ] ] )
gap> Diameter(g);
2
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{DiamondGraph}
%enddisplay
\>`DiamondGraph' V

The graph on 4 vertices and 5 edges.

\beginexample
gap> DiamondGraph;
Graph( Category := SimpleGraphs, Order := 4, Size := 5, Adjacencies :=
[ [ 2, 3, 4 ], [ 1, 3 ], [ 1, 2, 4 ], [ 1, 3 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{DiscreteGraph()}
%enddisplay
\>DiscreteGraph( <n> ) F

Returns the discrete graph of order <n>. A discrete graph is a graph
without edges.

\beginexample
gap> DiscreteGraph(4);
Graph( Category := SimpleGraphs, Order := 4, Size := 0, Adjacencies :=
[ [  ], [  ], [  ], [  ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{DisjointUnion()}
%enddisplay
\>DisjointUnion( <G>, <H> ) O

Returns the disjoint union of two graphs <G> and <H>, <G> $\dot{\cup}$ <H>.

\beginexample
gap> g:=PathGraph(3);h:=PathGraph(2); 
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
Graph( Category := SimpleGraphs, Order := 2, Size := 1, Adjacencies := 
[ [ 2 ], [ 1 ] ] )
gap> DisjointUnion(g,h);
Graph( Category := SimpleGraphs, Order := 5, Size := 3, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ], [ 5 ], [ 4 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{Distance()}
%enddisplay
\>Distance( <G>, <x>, <y> ) O

Returns the length of a minimal path connecting <x> to <y> in <G>.

\beginexample
gap> Distance(CycleGraph(5),1,3);
2
gap> Distance(CycleGraph(5),1,5);
1
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{Distances()}
%enddisplay
\>Distances( <G>, <A>, <B> ) O

Given two lists of vertices <A>, <B> of a graph <G>, `Distances' returns the
list of distances for every pair in the cartesian product of <A>
and <B>. The order of the vertices in lists <A> and <B> affects the order
of the list of distances returned.

\beginexample
gap> g:=CycleGraph(5);;
gap> Distances(g, [1,3], [2,4]);
[ 1, 2, 1, 1 ]
gap> Distances(g, [3,1], [2,4]);
[ 1, 1, 1, 2 ]
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{DistanceGraph()}
%enddisplay
\>DistanceGraph( <G>, <Dist> ) O

Given a graph <G> and list of distances <Dist>, `DistanceGraph' returns the new graph
constructed on the vertices of <G> where two vertices are
adjacent iff the distance (in <G>) between them belongs to the list <Dist>.

\beginexample
gap> g:=CycleGraph(5);            
Graph( Category := SimpleGraphs, Order := 5, Size := 5, Adjacencies := 
[ [ 2, 5 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 1, 4 ] ] )
gap> DistanceGraph(g,[2]);
Graph( Category := SimpleGraphs, Order := 5, Size := 5, Adjacencies := 
[ [ 3, 4 ], [ 4, 5 ], [ 1, 5 ], [ 1, 2 ], [ 2, 3 ] ] )
gap> DistanceGraph(g,[1,2]);
Graph( Category := SimpleGraphs, Order := 5, Size := 10, Adjacencies := 
[ [ 2, 3, 4, 5 ], [ 1, 3, 4, 5 ], [ 1, 2, 4, 5 ], [ 1, 2, 3, 5 ], 
  [ 1, 2, 3, 4 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{DistanceMatrix()}
%enddisplay
\>DistanceMatrix( <G> ) A

Returns the distance matrix <D> of a graph <G>: D[x][y] is the distance in <G> 
from vertex <x> to vertex <y>. The matrix may be asymmetric if the graph is not simple. 
An infinite entry in the matrix means that there is no path between the vertices. 
Floyd's algorithm is used to compute the matrix.

\beginexample
gap> g:=PathGraph(4);
Graph( Category := SimpleGraphs, Order := 4, Size := 3, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2, 4 ], [ 3 ] ] )
gap> Display(DistanceMatrix(g));
[ [  0,  1,  2,  3 ],
  [  1,  0,  1,  2 ],
  [  2,  1,  0,  1 ],
  [  3,  2,  1,  0 ] ]
gap> g:=PathGraph(4:GraphCategory:=OrientedGraphs);
Graph( Category := OrientedGraphs, Order := 4, Size := 3, Adjacencies := 
[ [ 2 ], [ 3 ], [ 4 ], [  ] ] )
gap> Display(DistanceMatrix(g));                   
[ [         0,         1,         2,         3 ],
  [  infinity,         0,         1,         2 ],
  [  infinity,  infinity,         0,         1 ],
  [  infinity,  infinity,  infinity,         0 ] ]
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{DistanceSet()}
%enddisplay
\>DistanceSet( <G>, <A>, <B> ) O

Given two subsets of vertices <A>, <B> of a graph <G>, `DistanceSet' returns the
set of distances for every pair in the cartesian product of <A> and <B>.  

\beginexample
gap> g:=CycleGraph(5);;         
gap> DistanceSet(g, [1,3], [2,4]);
[ 1, 2 ]
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{Dodecahedron}
%enddisplay
\>`Dodecahedron' V

The 1-skeleton of Plato's Dodecahedron.

\beginexample
gap> Dodecahedron;
Graph( Category := SimpleGraphs, Order := 20, Size := 30, Adjacencies := 
[ [ 2, 5, 6 ], [ 1, 3, 7 ], [ 2, 4, 8 ], [ 3, 5, 9 ], [ 1, 4, 10 ], 
  [ 1, 11, 15 ], [ 2, 11, 12 ], [ 3, 12, 13 ], [ 4, 13, 14 ], [ 5, 14, 15 ], 
  [ 6, 7, 16 ], [ 7, 8, 17 ], [ 8, 9, 18 ], [ 9, 10, 19 ], [ 6, 10, 20 ], 
  [ 11, 17, 20 ], [ 12, 16, 18 ], [ 13, 17, 19 ], [ 14, 18, 20 ], 
  [ 15, 16, 19 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{DominatedVertices()}
%enddisplay
\>DominatedVertices( <G> ) A

Returns the set of dominated vertices of <G>. 

A vertex <x> is dominated by another vertex <y> when the closed neighborhood
of <x> is contained in that of <y>. However, when there are twin vertices 
(mutually dominated vertices), exactly one of them (in each equivalent class 
of mutually dominated vertices) does not appear in the returned set.

\beginexample
gap> g1:=PathGraph(3);     
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
gap> DominatedVertices(g1);
[ 1, 3 ]
gap> g2:=PathGraph(2);
Graph( Category := SimpleGraphs, Order := 2, Size := 1, Adjacencies := 
[ [ 2 ], [ 1 ] ] )
gap> DominatedVertices(g2);
[ 2 ]
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{DominoGraph}
%enddisplay
\>`DominoGraph' V

Two squares glued by an edge.

\beginexample
gap> DominoGraph;
Graph( Category := SimpleGraphs, Order := 6, Size := 7, Adjacencies := 
[ [ 2, 4, 6 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3, 5 ], [ 4, 6 ], [ 1, 5 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{Draw()}
%enddisplay
\>Draw( <G> ) O

Takes a graph <G> and makes a drawing of it in a separate window. 
The user can then view and modify the drawing and finaly save the vertex 
coordinates of the drawing into the graph <G>.

Within the separate window, type h to toggle on/off the help menu. Besides the 
keyword commands indicated in the help menu, the user may also move vertices 
(by dragging them), move the whole drawing (by dragging the background) and 
scale the drawing (by using the mouse wheel).

\beginexample
gap> Coordinates(Icosahedron);
fail
gap> Draw(Icosahedron);
gap> Coordinates(Icosahedron);
[ [ 29, -107 ], [ 65, -239 ], [ 240, -62 ], [ 78, 79 ], [ -107, 28 ], 
  [ -174, -176 ], [ -65, 239 ], [ -239, 62 ], [ -78, -79 ], [ 107, -28 ], 
  [ 174, 176 ], [ -29, 107 ] ]
\endexample

This preliminary version, should work fine on GNU/Linux and Mac OS X. For other plataforms,
you should probably (at least) set up correctly the variable `drawproc'
which should point to the correct external program binary. Java binaries are provided for 
GNU/Linux, Mac OS X and MS Windows. 

\beginexample
gap> drawproc;
"/usr/share/gap/pkg/yags/bin/draw/application.linux64/draw"
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{DumpObject()}
%enddisplay
\>DumpObject( <Obj> ) O

Dumps all information available for object <Obj>. This information
includes to which categories it belongs as well as its type and 
hashing information used by {\GAP}.

\beginexample
gap> DumpObject( true );
Object( TypeObj := NewType( NewFamily( "BooleanFamily", [ 11 ], [ 11 ] ),
[ 11, 34 ] ), Categories := [ "IS_BOOL" ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{EasyExec()}
%enddisplay
\>EasyExec( <Dir>, <ProgName>, <InString> ) O
\>EasyExec( <ProgName>, <InString> ) O

Calls external program <ProgName> located in directory <Dir>, feeding it with
<InString> as input and returning the output of the external program as a 
string. <Dir> must be a directory object or a list of diretory objects. 
If <Dir> is not provided, <ProgName> must be in the system's binary PATH.
'fail' is returned if the program could not be located.

\beginexample
gap> s:=EasyExec("date","");;
gap> s;
"Sun Nov  9 10:36:16 CST 2014\n"
gap> s:=EasyExec("sort","4\n2\n3\n1");;
gap> s;
"1\n2\n3\n4\n"
\endexample

Currently, this operation is not working on MS Windows.


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{Eccentricity()}
%enddisplay
\>Eccentricity( <G>, <x> ) F

Returns the distance from a vertex <x> in graph <G> to its
most distant vertex in <G>.

\beginexample
gap> g:=PathGraph(5);
Graph( Category := SimpleGraphs, Order := 5, Size := 4, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 4 ] ] )
gap> Eccentricity(g,1);           
4
gap> Eccentricity(g,3);
2
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{Edges()}
%enddisplay
\>Edges( <G> ) O

Returns the list of edges of graph <G> in the case of `SimpleGraphs'.

\beginexample
gap> g1:=CompleteGraph(3);     
Graph( Category := SimpleGraphs, Order := 3, Size := 3, Adjacencies := 
[ [ 2, 3 ], [ 1, 3 ], [ 1, 2 ] ] )
gap> Edges(g1);
[ [ 1, 2 ], [ 1, 3 ], [ 2, 3 ] ]
\endexample

In the case of `UndirectedGraphs', it also returns the loops. While in the 
other categories, `Edges' actually does not return the edges, but the loops 
and arrows of <G>.

\beginexample
gap> g2:=CompleteGraph(3:GraphCategory:=UndirectedGraphs);
Graph( Category := UndirectedGraphs, Order := 3, Size := 6, Adjacencies := 
[ [ 1, 2, 3 ], [ 1, 2, 3 ], [ 1, 2, 3 ] ] )
gap> Edges(g2);
[ [ 1, 1 ], [ 1, 2 ], [ 1, 3 ], [ 2, 2 ], [ 2, 3 ], [ 3, 3 ] ]
gap> g3:=CompleteGraph(3:GraphCategory:=Graphs);          
Graph( Category := Graphs, Order := 3, Size := 9, Adjacencies := 
[ [ 1, 2, 3 ], [ 1, 2, 3 ], [ 1, 2, 3 ] ] )
gap> Edges(g3);                                 
[ [ 1, 1 ], [ 1, 2 ], [ 1, 3 ], [ 2, 1 ], [ 2, 2 ], [ 2, 3 ], [ 3, 1 ], 
  [ 3, 2 ], [ 3, 3 ] ]
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{FanGraph()}
%enddisplay
\>FanGraph( <n> ) F

Returns the <n>-Fan: The join of a vertex and a <(N+1)>-path.

\beginexample
gap> FanGraph(4);
Graph( Category := SimpleGraphs, Order := 6, Size := 9, Adjacencies :=
[ [ 2, 3, 4, 5, 6 ], [ 1, 3 ], [ 1, 2, 4 ], [ 1, 3, 5 ], [ 1, 4, 6 ],
[ 1, 5 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{FishGraph}
%enddisplay
\>`FishGraph' V

A square and a triangle glued by a vertex.

\beginexample
gap> FishGraph;
Graph( Category := SimpleGraphs, Order := 6, Size := 7, Adjacencies := 
[ [ 2, 3, 4, 6 ], [ 1, 3 ], [ 1, 2 ], [ 1, 5 ], [ 4, 6 ], [ 1, 5 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{GemGraph}
%enddisplay
\>`GemGraph' V

The 3-Fan graph.

\beginexample
gap> GemGraph;
Graph( Category := SimpleGraphs, Order := 5, Size := 7, Adjacencies := 
[ [ 2, 3, 4, 5 ], [ 1, 3 ], [ 1, 2, 4 ], [ 1, 3, 5 ], [ 1, 4 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{Girth()}
%enddisplay
\>Girth( <G> ) A

Returns the length of the minimum induced cycle in <G>. At this time, 
this works only when <G> belongs to the graph categories `SimpleGraphs' or 
`UndirectedGraphs'. If <G> has loops, its girth is 1 by definition.

\beginexample
gap> Girth(Octahedron);
3
gap> Girth(PetersenGraph);         
5
gap> Girth(Cube);
4
gap> Girth(PathGraph(5));
infinity
gap> g:=AddEdges(CycleGraph(4),[[3,3]]:GraphCategory:=UndirectedGraphs);
Graph( Category := UndirectedGraphs, Order := 4, Size := 5, Adjacencies := 
[ [ 2, 4 ], [ 1, 3 ], [ 2, 3, 4 ], [ 1, 3 ] ] )
gap> Girth(g);            
1
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{Graph()}
%enddisplay
\>Graph( <Rec> ) O

Returns a new graph created from the record <Rec>. The record must provide the field <Category> 
and either the field <Adjacencies> or the field <AdjMatrix>.

\beginexample
gap> Graph(rec(Category:=SimpleGraphs,Adjacencies:=[[2],[1]]));
Graph( Category := SimpleGraphs, Order := 2, Size := 1, Adjacencies := [ [ 2 ], [ 1 ] ] )
gap> Graph(rec(Category:=SimpleGraphs,AdjMatrix:=[[false, true],[true, false]]));
Graph( Category := SimpleGraphs, Order := 2, Size := 1, Adjacencies := [ [ 2 ], [ 1 ] ] )
\endexample

Its main purpose is to import graphs from files, which could have been 
previously exported using `PrintTo'.

\beginexample
gap> g:=CycleGraph(4);
Graph( Category := SimpleGraphs, Order := 4, Size := 4, Adjacencies := 
[ [ 2, 4 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3 ] ] )
gap> PrintTo("aux.g","h1:=",g,";");
gap> Read("aux.g");
gap> h1;
Graph( Category := SimpleGraphs, Order := 4, Size := 4, Adjacencies := 
[ [ 2, 4 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{Graph6ToGraph()}
%enddisplay
\>Graph6ToGraph( <String> ) O

Returns the graph represented by <String> which is encoded using 
Brendan McKay's graph6 format. This operation allows us to read data in 
databases which use this format. Several such databases can be found here:
\URL{https://cs.anu.edu.au/people/Brendan.McKay/data/graphs.html}.

The graph6 format is described here: 
\URL{https://cs.anu.edu.au/people/Brendan.McKay/data/formats.txt}.

\beginexample
gap> Graph6ToGraph("D?{");    
Graph( Category := SimpleGraphs, Order := 5, Size := 4, Adjacencies := 
[ [ 5 ], [ 5 ], [ 5 ], [ 5 ], [ 1, 2, 3, 4 ] ] )
gap> Graph6ToGraph("FUzvW");  
Graph( Category := SimpleGraphs, Order := 7, Size := 15, Adjacencies := 
[ [ 3, 4, 5, 6, 7 ], [ 4, 5, 6, 7 ], [ 1, 5, 6, 7 ], [ 1, 2, 6 ], 
  [ 1, 2, 3, 7 ], [ 1, 2, 3, 4, 7 ], [ 1, 2, 3, 5, 6 ] ] )
gap> Graph6ToGraph("HUzv~z}");
Graph( Category := SimpleGraphs, Order := 9, Size := 29, Adjacencies := 
[ [ 3, 4, 5, 6, 7, 8, 9 ], [ 4, 5, 6, 7, 8, 9 ], [ 1, 5, 6, 7, 8, 9 ], 
  [ 1, 2, 6, 7, 8, 9 ], [ 1, 2, 3, 7, 8, 9 ], [ 1, 2, 3, 4, 7, 8, 9 ], 
  [ 1, 2, 3, 4, 5, 6, 9 ], [ 1, 2, 3, 4, 5, 6 ], [ 1, 2, 3, 4, 5, 6, 7 ] ] )
\endexample

See also `ImportGraph6( <Filename> )'.

%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{GraphByAdjacencies()}
%enddisplay
\>GraphByAdjacencies( <AdjList> ) F

Returns a new graph having <AdjList> as its list of adjacencies. The order of the created graph is 
`Length(A)', and the set of neighbors of vertex <x> is $A[x]$. 

\beginexample
gap> GraphByAdjacencies([[2],[1,3],[2]]);      
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
\endexample

Note, however, that the graph is forced to comply with the `TargetGraphCategory'.

\beginexample
gap> GraphByAdjacencies([[1,2,3],[],[]]);
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2, 3 ], [ 1 ], [ 1 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{GraphByAdjMatrix()}
%enddisplay
\>GraphByAdjMatrix( <Mat> ) F

Returns a new graph created from an adjacency matrix <Mat>. The matrix <Mat> must
be a square boolean matrix.

\beginexample
gap> m:=[ [ false, true, false ], [ true, false, true ], [ false, true, false ] ];;
gap> g:=GraphByAdjMatrix(m);
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
gap> AdjMatrix(g);
[ [ false, true, false ], [ true, false, true ], [ false, true, false ] ]
\endexample

Note, however, that the graph is forced to comply with the `TargetGraphCategory'.

\beginexample
gap> m:=[ [ true, true], [ false, false ] ];;
gap> g:=GraphByAdjMatrix(m);                
Graph( Category := SimpleGraphs, Order := 2, Size := 1, Adjacencies := [ [ 2 ], [ 1 ] ] )
gap> AdjMatrix(g);                          
[ [ false, true ], [ true, false ] ]
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{GraphByCompleteCover()}
%enddisplay
\>GraphByCompleteCover( <Cover> ) F

Returns the minimal graph where the elements of <Cover> are 
(the vertex sets of) complete subgraphs.

\beginexample
gap> GraphByCompleteCover([[1,2,3,4],[4,6,7]]); 
Graph( Category := SimpleGraphs, Order := 7, Size := 9, Adjacencies := 
[ [ 2, 3, 4 ], [ 1, 3, 4 ], [ 1, 2, 4 ], [ 1, 2, 3, 6, 7 ], [  ], [ 4, 7 ], 
  [ 4, 6 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{GraphByEdges()}
%enddisplay
\>GraphByEdges( <L> ) F

Returns the minimal graph such that the pairs in <L> are edges.

\beginexample
gap> GraphByEdges([[1,2],[1,3],[1,4],[4,5]]);
Graph( Category := SimpleGraphs, Order := 5, Size := 4, Adjacencies := 
[ [ 2, 3, 4 ], [ 1 ], [ 1 ], [ 1, 5 ], [ 4 ] ] )
\endexample

The vertices of the constructed graph range from 1 to the maximum of the
numbers appearing in <L>.

\beginexample
gap> GraphByEdges([[4,3],[4,5]]);
Graph( Category := SimpleGraphs, Order := 5, Size := 2, Adjacencies := 
[ [  ], [  ], [ 4 ], [ 3, 5 ], [ 4 ] ] )
\endexample

Note that `GraphByWalks' has an even greater functionality.


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{GraphByRelation()}
%enddisplay
\>GraphByRelation( <V>, <Rel> ) F
\>GraphByRelation( <n>, <Rel> ) F

Returns a new graph created from a set of vertices <V> and a binary relation <Rel>, 
where $x\sim y$ iff `<Rel>(x,y)=true'. In the second form, <n> is an integer
and $V$ is assumed to be $\{1, 2, \ldots, n\}$.

\beginexample
gap> Rel:=function(x,y) return Intersection(x,y)<>[]; end;;          
gap> GraphByRelation([[1,2,3],[3,4,5],[5,6,7]],Rel);               
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
gap> GraphByRelation(8,function(x,y) return AbsInt(x-y)<=2; end); 
Graph( Category := SimpleGraphs, Order := 8, Size := 13, Adjacencies := 
[ [ 2, 3 ], [ 1, 3, 4 ], [ 1, 2, 4, 5 ], [ 2, 3, 5, 6 ], [ 3, 4, 6, 7 ], 
  [ 4, 5, 7, 8 ], [ 5, 6, 8 ], [ 6, 7 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{GraphByWalks()}
%enddisplay
\>GraphByWalks( <Walk1>, <Walk2>, ... ) F

Returns the minimal graph such that <Walk1>, <Walk2>, etc are Walks.

\beginexample
gap> GraphByWalks([1,2,3,4,1],[1,5,6]);
Graph( Category := SimpleGraphs, Order := 6, Size := 6, Adjacencies := 
[ [ 2, 4, 5 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3 ], [ 1, 6 ], [ 5 ] ] )
\endexample

Walks can be <nested>, which greatly improves the versatility of this function.
 
\beginexample
gap> GraphByWalks([1,[2,3,4],5],[5,6]);
Graph( Category := SimpleGraphs, Order := 6, Size := 9, Adjacencies := 
[ [ 2, 3, 4 ], [ 1, 3, 5 ], [ 1, 2, 4, 5 ], [ 1, 3, 5 ], [ 2, 3, 4, 6 ], [ 5 ] ] )
\endexample

The vertices in the constructed graph range from 1 to the maximum of the numbers
appearing in <Walk1>, <Walk2>, ... etc.

\beginexample
gap> GraphByWalks([4,2],[3,6]);
Graph( Category := SimpleGraphs, Order := 6, Size := 2, Adjacencies := 
[ [  ], [ 4 ], [ 6 ], [ 2 ], [  ], [ 3 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{GraphCategory()}
%enddisplay
\>GraphCategory( [ <G>, ... ] ) F

For internal use. Returns the minimal common category to a list of graphs.
If the list of graphs is empty, the default category is returned.

The partial order (by inclusion) among graph categories is as follows: 
%%FIXME: Wrong spacing in the pdf manual.
$$
`SimpleGraphs' \<  `UndirectedGraphs' \< `Graphs',
$$
$$
`OrientedGraphs' \< `LooplessGraphs' \< `Graphs',
$$
$$
`SimpleGraphs' \< `LooplessGraphs' \< `Graphs'
$$
 
\beginexample
gap> g1:=CompleteGraph(2:GraphCategory:=SimpleGraphs);  
Graph( Category := SimpleGraphs, Order := 2, Size := 1, Adjacencies := 
[ [ 2 ], [ 1 ] ] )
gap> g2:=CompleteGraph(2:GraphCategory:=OrientedGraphs);
Graph( Category := OrientedGraphs, Order := 2, Size := 1, Adjacencies := 
[ [ 2 ], [  ] ] )
gap> g3:=CompleteGraph(2:GraphCategory:=UndirectedGraphs);
Graph( Category := UndirectedGraphs, Order := 2, Size := 3, Adjacencies := 
[ [ 1, 2 ], [ 1, 2 ] ] )
gap> GraphCategory([g1,g2,g3]);
<Operation "Graphs">
gap> GraphCategory([g1,g2]);   
<Operation "LooplessGraphs">
gap> GraphCategory([g1,g3]);
<Operation "UndirectedGraphs">
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{Graphs()}
%enddisplay
\>Graphs( ) C

`Graphs' is the most general graph category in {\YAGS}. This category contains
all graphs that can be represented in {\YAGS}. A graph in this category may 
contain loops, arrows and edges (which in {\YAGS} are exactly the same as two opposite 
arrows between some pair of vertices). This graph category has no parent category.

\beginexample
gap> GraphByWalks([1,1],[1,2],[2,1],[3,2]:GraphCategory:=Graphs);
Graph( Category := Graphs, Order := 3, Size := 4, Adjacencies := 
[ [ 1, 2 ], [ 1 ], [ 2 ] ] )
gap> GraphByWalks([1,1],[1,2],[2,1],[3,2]:GraphCategory:=SimpleGraphs);  
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{GraphsOfGivenOrder()}
%enddisplay
\>GraphsOfGivenOrder( <n> ) O

Returns the list of all graphs of order <n> (upto isomorphism). 
This operation uses Brendan McKay's data published here: 
\URL{https://cs.anu.edu.au/people/Brendan.McKay/data/graphs.html}. 

These data are included with the {\YAGS} distribution in its `data' directory.
Hence this operation simply reads the corresponding file in that directory using
`ImportGraph6( <Filename> )'. Therefore, the integer <n> must be in the range 
from 1 upto 9. Data for graphs on 10 vertices is also available, but not included 
with {\YAGS}, it may not be practical to use that data, but if you would like to try, 
all you have to do is to copy (and to uncompress) the corresponding file into the 
directory `<YAGS-Directory>/data'.

\beginexample
gap> GraphsOfGivenOrder(2);          
[ Graph( Category := SimpleGraphs, Order := 2, Size := 0, Adjacencies := 
    [ [  ], [  ] ] ), Graph( Category := SimpleGraphs, Order := 2, Size := 
    1, Adjacencies := [ [ 2 ], [ 1 ] ] ) ]
gap> GraphsOfGivenOrder(3);
[ Graph( Category := SimpleGraphs, Order := 3, Size := 0, Adjacencies := 
    [ [  ], [  ], [  ] ] ), Graph( Category := SimpleGraphs, Order := 
    3, Size := 1, Adjacencies := [ [ 3 ], [  ], [ 1 ] ] ), 
  Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
    [ [ 3 ], [ 3 ], [ 1, 2 ] ] ), Graph( Category := SimpleGraphs, Order := 
    3, Size := 3, Adjacencies := [ [ 2, 3 ], [ 1, 3 ], [ 1, 2 ] ] ) ]
gap> Length(GraphsOfGivenOrder(9));
274668
gap> GraphsOfGivenOrder(10);       
#W Unreadable File: /opt/gap4r7/pkg/yags/data/graph10.g6
fail
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{GraphSum()}
%enddisplay
\>GraphSum( <G>, <L> ) O

Returns the lexicographic sum of a list of graphs <L> over a graph <G>.

The lexicographic sum is computed as follows:

Given <G>, with $Order(G)=n$ and a list of <n> graphs $L = [G_1, \ldots, G_n]$,
We take the disjoint union of $G_1,G_2, \ldots,G_n$ and then we add all the 
edges between $G_i$ and $G_j$ whenever $[i,j]$ is and edge of $G$.

If <L> contains holes, the trivial graph is used in place.

\beginexample
gap> t:=TrivialGraph;; g:=CycleGraph(4);;
gap> GraphSum(PathGraph(3),[t,g,t]);
Graph( Category := SimpleGraphs, Order := 6, Size := 12, Adjacencies := 
[ [ 2, 3, 4, 5 ], [ 1, 3, 5, 6 ], [ 1, 2, 4, 6 ], [ 1, 3, 5, 6 ], 
  [ 1, 2, 4, 6 ], [ 2, 3, 4, 5 ] ] )
gap> GraphSum(PathGraph(3),[,g,]);  
Graph( Category := SimpleGraphs, Order := 6, Size := 12, Adjacencies := 
[ [ 2, 3, 4, 5 ], [ 1, 3, 5, 6 ], [ 1, 2, 4, 6 ], [ 1, 3, 5, 6 ], 
  [ 1, 2, 4, 6 ], [ 2, 3, 4, 5 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{GraphToRaw()}
%enddisplay
\>GraphToRaw( <FileName>, <G> ) O

Converts a {\YAGS} graph <G> into a raw format (number of vertices, coordinates and 
adjacency matrix) and writes the converted data to the file <FileName>. 
For use by the external program `draw' (see `Draw(<G>)' ).

\beginexample
gap> g:=CycleGraph(4);;
gap> GraphToRaw("mygraph.raw",g);
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{GraphUpdateFromRaw()}
%enddisplay
\>GraphUpdateFromRaw( <FileName>, <G> ) O

Updates the coordinates of <G> from a file <FileName> in raw format. 
Intended for internal use only.


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{GroupGraph()}
%enddisplay
\>GroupGraph( <G>, <Grp>, <Act> ) O
\>GroupGraph( <G>, <Grp> ) O

Given a graph <G>, a group <Grp> and an action <Act> of <Grp> in some 
set S which contains Vertices( <G> ), GroupGraph returns a new graph 
with vertex set $\{act(v,g) : g \in Grp, v \in Vertices( G )\}$ 
and edge set $\{\{act(v,g),act(u,g)\}: g\ in Grp \{u,v\}\in Edges( G )\}$.

If <Act> is omited, the standard {\GAP} action `OnPoints' is used.

\beginexample
gap> GroupGraph(GraphByWalks([1,2]),Group([(1,2,3,4,5),(2,5)(3,4)]));
Graph( Category := SimpleGraphs, Order := 5, Size := 5, Adjacencies := 
[ [ 2, 5 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 1, 4 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{HouseGraph}
%enddisplay
\>`HouseGraph' V

A 4-Cycle and a triangle glued by an edge.

\beginexample
gap> HouseGraph;
Graph( Category := SimpleGraphs, Order := 5, Size := 6, Adjacencies := 
[ [ 2, 4, 5 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3, 5 ], [ 1, 4 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{Icosahedron}
%enddisplay
\>`Icosahedron' V

The 1-skeleton of Plato's icosahedron.

\beginexample
gap> Icosahedron;
Graph( Category := SimpleGraphs, Order := 12, Size := 30, Adjacencies :=
[ [ 2, 3, 4, 5, 6 ], [ 1, 3, 6, 9, 10 ], [ 1, 2, 4, 10, 11 ],
  [ 1, 3, 5, 7, 11 ], [ 1, 4, 6, 7, 8 ], [ 1, 2, 5, 8, 9 ],
  [ 4, 5, 8, 11, 12 ], [ 5, 6, 7, 9, 12 ], [ 2, 6, 8, 10, 12 ],
  [ 2, 3, 9, 11, 12 ], [ 3, 4, 7, 10, 12 ], [ 7, 8, 9, 10, 11 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{ImportGraph6()}
%enddisplay
\>ImportGraph6( <Filename> ) O

Returns the list of graphs represented in <Filename> which are encoded using 
Brendan McKay's graph6 format. This operation allows us to read data in 
databases which use this format. Several such databases can be found here:
\URL{https://cs.anu.edu.au/people/Brendan.McKay/data/graphs.html}.

The graph6 format is described here: 
\URL{https://cs.anu.edu.au/people/Brendan.McKay/data/formats.txt}.

The following example assumes that you have a file named `graph3.g6' 
in your working directory which encodes graphs in graph6 format; 
the contents of this file is assumed to be as indicated after the first 
command in the example.

\beginexample
gap> Exec("cat graph3.g6");
B?
BO
BW
Bw
gap> ImportGraph6("graph3.g6");
[ Graph( Category := SimpleGraphs, Order := 3, Size := 0, Adjacencies := 
    [ [  ], [  ], [  ] ] ), Graph( Category := SimpleGraphs, Order := 
    3, Size := 1, Adjacencies := [ [ 3 ], [  ], [ 1 ] ] ), 
  Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
    [ [ 3 ], [ 3 ], [ 1, 2 ] ] ), Graph( Category := SimpleGraphs, Order := 
   3, Size := 3, Adjacencies := [ [ 2, 3 ], [ 1, 3 ], [ 1, 2 ] ] ) ]
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{in()}
%enddisplay
\>in( <G>, <Catgy> ) O

Returns `true' if graph <G> belongs to category <Catgy> and `false' otherwise.


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{InducedSubgraph()}
%enddisplay
\>InducedSubgraph( <G>, <V> ) O

Returns the subgraph of graph <G> induced by the vertex set <V>.

\beginexample
gap> g:=CycleGraph(6);          
Graph( Category := SimpleGraphs, Order := 6, Size := 6, Adjacencies := 
[ [ 2, 6 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 4, 6 ], [ 1, 5 ] ] )
gap> InducedSubgraph(g,[3,4,6]);  
Graph( Category := SimpleGraphs, Order := 3, Size := 1, Adjacencies := 
[ [ 2 ], [ 1 ], [  ] ] )
\endexample

The order of the elements in <V> does matter.

\beginexample
gap> InducedSubgraph(g,[6,3,4]);  
Graph( Category := SimpleGraphs, Order := 3, Size := 1, Adjacencies := 
[ [  ], [ 3 ], [ 2 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{InNeigh()}
%enddisplay
\>InNeigh( <G>, <x> ) O

Returns the list of in-neighbors of <x> in <G>.

\beginexample
gap> tt:=CompleteGraph(5:GraphCategory:=OrientedGraphs);
Graph( Category := OrientedGraphs, Order := 5, Size := 10, Adjacencies := 
[ [ 2, 3, 4, 5 ], [ 3, 4, 5 ], [ 4, 5 ], [ 5 ], [  ] ] )
gap> InNeigh(tt,3);                                     
[ 1, 2 ]
gap> OutNeigh(tt,3);                                    
[ 4, 5 ]
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{IntersectionGraph()}
%enddisplay
\>IntersectionGraph( <L> ) F

Returns the intersection graph of the family of sets <L>. This graph has a 
vertex for every set in <L>, and two such vertices are adjacent iff the 
corresponding sets have non-empty intersection.

\beginexample
gap> IntersectionGraph([[1,2,3],[3,4,5],[5,6,7]]);
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{IsBoolean()}
%enddisplay
\>IsBoolean( <Obj> ) F

Returns `true' if object <Obj> is `true' or `false' and `false' otherwise.

\beginexample
gap> IsBoolean( true ); IsBoolean( fail ); IsBoolean ( false );
true
false
true
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{IsCliqueGated()}
%enddisplay
\>IsCliqueGated( <G> ) P

Returns `true' if <G> is a clique gated graph \cite{HK96}.


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{IsCliqueHelly()}
%enddisplay
\>IsCliqueHelly( <G> ) P

Returns `true' if the set of (maximal) cliques <G> satisfy
the <Helly> property.

The Helly property is defined as follows:

A non-empty family $\Cal{F}$ of non-empty sets satisfies the Helly property if
every pairwise intersecting subfamily of $\Cal{F}$ has a non-empty total intersection.

Here we use the Dragan-Szwarcfiter characterization \cite{Dra89,Szw97} to compute the Helly property.

\beginexample
gap> g:=SunGraph(3);
Graph( Category := SimpleGraphs, Order := 6, Size := 9, Adjacencies :=
[ [ 2, 6 ], [ 1, 3, 4, 6 ], [ 2, 4 ], [ 2, 3, 5, 6 ], [ 4, 6 ],
  [ 1, 2, 4, 5 ] ] )
gap> IsCliqueHelly(g);
false
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{IsComplete()}
%enddisplay
\>IsComplete( <G>, <L> ) O

Returns `true' if <L> induces a complete subgraph of <G>.

\beginexample
gap> IsComplete(DiamondGraph,[1,2,3]);
true
gap> IsComplete(DiamondGraph,[1,2,4]);
false
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{IsCompleteGraph()}
%enddisplay
\>IsCompleteGraph( <G> ) P

Returns `true' if graph <G> is a complete graph, `false' otherwise.
In a complete graph every pair of vertices is an edge.


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{IsDiamondFree()}
%enddisplay
\>IsDiamondFree( <G> ) P

Returns `true' if <G> is free from induced diamonds, `false' otherwise.

\beginexample
gap> IsDiamondFree(Cube);
true
gap> IsDiamondFree(Octahedron);
false
\endexample
                                    

%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{IsEdge()}
%enddisplay
\>IsEdge( <G> , [x, y] ) O

Returns `true' if [x,y] is an edge of <G>.

\beginexample
gap> IsEdge(PathGraph(3),[1,2]);
true
gap> IsEdge(PathGraph(3),[1,3]);
false
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{IsIsomorphicGraph()}
%enddisplay
\>IsIsomorphicGraph( <G>, <H> ) O

Returns `true' when <G> is isomorphic to <H> and `false' otherwise.

\beginexample
gap> g:=PowerGraph(CycleGraph(6),2);;h:=Octahedron;;
gap> IsIsomorphicGraph(g,h);
true
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{IsLoopless()}
%enddisplay
\>IsLoopless( <G> ) P

Returns `true' if graph <G> have no loops, `false' otherwise. Loops are edges 
from a vertex to itself.


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{IsoMorphism()}
%enddisplay
\>IsoMorphism( <G>, <H> ) O

Returns one isomorphism from <G> to <H> or `fail' if none exists. If <G> has <n> vertices, 
an isomorphisms $f : G\rightarrow H$ is represented as the list `<F>=[f(1), f(2), ..., f(n)]'.

\beginexample
gap> g:=CycleGraph(4);;h:=CompleteBipartiteGraph(2,2);;
gap> f:=IsoMorphism(g,h);
[ 1, 3, 2, 4 ]
\endexample

See `NextIsoMorphism( <G>, <H>, <F> )'.


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{IsoMorphisms()}
%enddisplay
\>IsoMorphisms( <G>, <H> ) O

Returns the list of all isomorphism from <G> to <H>. If <G> has <n> vertices, 
an isomorphisms $f : G\rightarrow H$ is represented as the list `<F>=[f(1), f(2), ..., f(n)]'.

\beginexample
gap> g:=CycleGraph(4);;h:=CompleteBipartiteGraph(2,2);;
gap> IsoMorphisms(g,h);
[ [ 1, 3, 2, 4 ], [ 1, 4, 2, 3 ], [ 2, 3, 1, 4 ], [ 2, 4, 1, 3 ], 
  [ 3, 1, 4, 2 ], [ 3, 2, 4, 1 ], [ 4, 1, 3, 2 ], [ 4, 2, 3, 1 ] ]
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{IsOriented()}
%enddisplay
\>IsOriented( <G> ) P
\>QtfyIsOriented( <G> ) A

Returns `true' if graph <G> is an oriented graph, `false' otherwise.
Regardless of the categories that <G> belongs to, <G> is oriented if 
whenever `[x,y]' is an edge of <G>, `[y,x]' is not.


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{IsSimple()}
%enddisplay
\>IsSimple( <G> ) P

Returns `true' if graph <G> is a simple graph, `false' otherwise.
Regardless of the categories that <G> belongs to, <G> is simple if and only if 
<G> is undirected and loopless.

Returns `true' if the graph <G> is simple regardless of its category.


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{IsTournament()}
%enddisplay
\>IsTournament( <G> ) P

Returns `true' if <G> is a tournament.

\beginexample
gap> tt:=CompleteGraph(5:GraphCategory:=OrientedGraphs);
Graph( Category := OrientedGraphs, Order := 5, Size := 10, Adjacencies := 
[ [ 2, 3, 4, 5 ], [ 3, 4, 5 ], [ 4, 5 ], [ 5 ], [  ] ] )
gap> IsTournament(tt);                                  
true
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{IsTransitiveTournament()}
%enddisplay
\>IsTransitiveTournament( <G> ) P

Returns `true' if <G> is a transitive tournament.

\beginexample
gap> tt:=CompleteGraph(5:GraphCategory:=OrientedGraphs);
Graph( Category := OrientedGraphs, Order := 5, Size := 10, Adjacencies := 
[ [ 2, 3, 4, 5 ], [ 3, 4, 5 ], [ 4, 5 ], [ 5 ], [  ] ] )
gap> IsTransitiveTournament(tt);
true
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{IsUndirected()}
%enddisplay
\>IsUndirected( <G> ) P

Returns `true' if graph <G> is an undirected graph, `false' otherwise.
Regardless of the categories that <G> belongs to, <G> is undirected if 
whenever `[x,y]' is an edge of <G>, `[y,x]' is also an egde of <G>.


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{JohnsonGraph()}
%enddisplay
\>JohnsonGraph( <n>, <r> ) F

Returns the Johnson graph $J(n,r)$. The Johnson Graph is the
graph whose vertices are <r>-subset of the set $\{1, 2, \ldots, n\}$, 
two of them being adjacent iff they intersect in exactly <r>-1 elements.

\beginexample
gap> g:=JohnsonGraph(4,2);                                            
Graph( Category := SimpleGraphs, Order := 6, Size := 12, Adjacencies := 
[ [ 2, 3, 4, 5 ], [ 1, 3, 4, 6 ], [ 1, 2, 5, 6 ], [ 1, 2, 5, 6 ], 
 [ 1, 3, 4, 6 ], [ 2, 3, 4, 5 ] ] )
gap> VertexNames(g);
[ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 2, 3 ], [ 2, 4 ], [ 3, 4 ] ]
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{Join()}
%enddisplay
\>Join( <G>, <H> ) O

\index{Zykov sum}
Returns the join graph <G> + <H> of <G> and <H>  (also known as the Zykov sum);
it is the graph obtained from the disjoint union of <G> and <H> by
adding every possible edge from every vertex in <G> to every vertex in <H>.

\beginexample
gap> g:=DiscreteGraph(2);h:=CycleGraph(4);
Graph( Category := SimpleGraphs, Order := 2, Size := 0, Adjacencies := 
[ [  ], [  ] ] )
Graph( Category := SimpleGraphs, Order := 4, Size := 4, Adjacencies := 
[ [ 2, 4 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3 ] ] )
gap> Join(g,h);                           
Graph( Category := SimpleGraphs, Order := 6, Size := 12, Adjacencies := 
[ [ 3, 4, 5, 6 ], [ 3, 4, 5, 6 ], [ 1, 2, 4, 6 ], [ 1, 2, 3, 5 ], 
  [ 1, 2, 4, 6 ], [ 1, 2, 3, 5 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{KiteGraph}
%enddisplay
\>`KiteGraph' V

A diamond with a pendant vertex and maximum degree 3.

\beginexample
gap> KiteGraph;
Graph( Category := SimpleGraphs, Order := 5, Size := 6, Adjacencies := 
[ [ 2 ], [ 1, 3, 4 ], [ 2, 4, 5 ], [ 2, 3, 5 ], [ 3, 4 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{LineGraph()}
%enddisplay
\>LineGraph( <G> ) O

Returns the line graph <L(G)> of graph <G>. The line graph is the
intersection graph of the edges of <G>, <i.e.> the vertices of
$L(G)$ are the edges of <G> two of them being adjacent iff they
are incident. 

\beginexample 
gap> g:=Tetrahedron;
Graph( Category := SimpleGraphs, Order := 4, Size := 6, Adjacencies :=
[ [ 2, 3, 4 ], [ 1, 3, 4 ], [ 1, 2, 4 ], [ 1, 2, 3 ] ] )
gap> LineGraph(g);
Graph( Category := SimpleGraphs, Order := 6, Size := 12, Adjacencies :=
[ [ 2, 3, 4, 5 ], [ 1, 3, 4, 6 ], [ 1, 2, 5, 6 ], [ 1, 2, 5, 6 ],
  [ 1, 3, 4, 6 ], [ 2, 3, 4, 5 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{Link()}
%enddisplay
\>Link( <G>, <x> ) O

Returns the subgraph of <G> induced by the neighbors of <x>.

\beginexample
gap> Link(SnubDisphenoid,1);
Graph( Category := SimpleGraphs, Order := 5, Size := 5, Adjacencies := 
[ [ 2, 5 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 1, 4 ] ] )
gap> Link(SnubDisphenoid,3);
Graph( Category := SimpleGraphs, Order := 4, Size := 4, Adjacencies := 
[ [ 2, 3 ], [ 1, 4 ], [ 1, 4 ], [ 2, 3 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{Links()}
%enddisplay
\>Links( <G> ) A

Returns the list of subgraphs of <G> induced by the neighbors of each vertex of <G>.

\beginexample
gap> Links(SnubDisphenoid); 
[ Graph( Category := SimpleGraphs, Order := 5, Size := 5, Adjacencies := 
    [ [ 2, 5 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 1, 4 ] ] ), 
  Graph( Category := SimpleGraphs, Order := 5, Size := 5, Adjacencies := 
    [ [ 2, 5 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 1, 4 ] ] ), 
  Graph( Category := SimpleGraphs, Order := 4, Size := 4, Adjacencies := 
    [ [ 2, 3 ], [ 1, 4 ], [ 1, 4 ], [ 2, 3 ] ] ), 
  Graph( Category := SimpleGraphs, Order := 4, Size := 4, Adjacencies := 
    [ [ 2, 3 ], [ 1, 4 ], [ 1, 4 ], [ 2, 3 ] ] ), 
  Graph( Category := SimpleGraphs, Order := 5, Size := 5, Adjacencies := 
    [ [ 2, 5 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 1, 4 ] ] ), 
  Graph( Category := SimpleGraphs, Order := 5, Size := 5, Adjacencies := 
    [ [ 2, 5 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 1, 4 ] ] ), 
  Graph( Category := SimpleGraphs, Order := 4, Size := 4, Adjacencies := 
    [ [ 3, 4 ], [ 3, 4 ], [ 1, 2 ], [ 1, 2 ] ] ), 
  Graph( Category := SimpleGraphs, Order := 4, Size := 4, Adjacencies := 
    [ [ 2, 3 ], [ 1, 4 ], [ 1, 4 ], [ 2, 3 ] ] ) ]
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{LooplessGraphs()}
%enddisplay
\>LooplessGraphs( ) C

`LooplessGraphs' is a graph category in {\YAGS}. A graph in this category may 
contain arrows and edges but no loops. The parent of this category is `Graphs'.

\beginexample
gap> GraphByWalks([1,1],[1,2],[2,1],[3,2]:GraphCategory:=Graphs);
Graph( Category := Graphs, Order := 3, Size := 4, Adjacencies := 
[ [ 1, 2 ], [ 1 ], [ 2 ] ] )
gap> GraphByWalks([1,1],[1,2],[2,1],[3,2]:GraphCategory:=LooplessGraphs);  
Graph( Category := LooplessGraphs, Order := 3, Size := 3, Adjacencies := 
[ [ 2 ], [ 1 ], [ 2 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{MaxDegree()}
%enddisplay
\>MaxDegree( <G> ) O

Returns the maximum degree in graph <G>.

\beginexample
gap> g:=GemGraph;
Graph( Category := SimpleGraphs, Order := 5, Size := 7, Adjacencies := 
[ [ 2, 3, 4, 5 ], [ 1, 3 ], [ 1, 2, 4 ], [ 1, 3, 5 ], [ 1, 4 ] ] )
gap> MaxDegree(g);
4
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{MinDegree()}
%enddisplay
\>MinDegree( <G> ) O

Returns the minimum degree in graph <G>.

\beginexample
gap> g:=GemGraph;
Graph( Category := SimpleGraphs, Order := 5, Size := 7, Adjacencies := 
[ [ 2, 3, 4, 5 ], [ 1, 3 ], [ 1, 2, 4 ], [ 1, 3, 5 ], [ 1, 4 ] ] )
gap> MinDegree(g);
2
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{NextIsoMorphism()}
%enddisplay
\>NextIsoMorphism( <G>, <H>, <F> ) O

Returns the next isomorphism (after <F>) from <G> to <H> in the lexicographic 
order; returns `fail' if there are no more isomorphisms. If <G> has <n> vertices, 
an isomorphisms $f : G\rightarrow H$ is represented as the list `<F>=[f(1), f(2), ..., f(n)]'.

\beginexample
gap> g:=CycleGraph(4);;h:=CompleteBipartiteGraph(2,2);;
gap> f:=IsoMorphism(g,h);
[ 1, 3, 2, 4 ]
gap> NextIsoMorphism(g,h,f);
[ 1, 4, 2, 3 ]
gap> NextIsoMorphism(g,h,f);
[ 2, 3, 1, 4 ]
gap> NextIsoMorphism(g,h,f);
[ 2, 4, 1, 3 ]
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{NextPropertyMorphism()}
%enddisplay
\>NextPropertyMorphism( <G>, <H>, <F>, <PropList> ) O

Returns the next morphism (in lexicographic order) from <G> to <H> 
satisfying the list of properties <PropList> starting with (possibly incomplete) 
morphism <F>. The morphism found will me returned *and* stored in <F>
in order to use it as the next starting point, in case `NextPropertyMorphism'
is called again. The operation returns `fail' if there are no more morphisms of 
the specified type.

A number of preprogrammed properties are provided by {\YAGS}, and the user may create 
additional ones. The properties provided are: `CHK_WEAK', `CHK_MORPH', `CHK_METRIC', 
`CHK_CMPLT', `CHK_MONO' and `CHK_EPI'.

If <G> has <n> vertices and $f:G\rightarrow H$ is a morphism, it is 
represented as `<F>=[f(1), f(2), ..., f(n)]'. 

\beginexample
gap> g:=CycleGraph(4);;h:=CompleteBipartiteGraph(2,2);;
gap> f:=[];; PropList:=[CHK_MORPH,CHK_MONO];;                   
gap> NextPropertyMorphism(g,h,f,PropList);                    
[ 1, 3, 2, 4 ]
gap> NextPropertyMorphism(g,h,f,PropList);
[ 1, 4, 2, 3 ]
gap> NextPropertyMorphism(g,h,f,PropList);
[ 2, 3, 1, 4 ]
gap> NextPropertyMorphism(g,h,f,PropList);
[ 2, 4, 1, 3 ]
gap> NextPropertyMorphism(g,h,f,PropList);
[ 3, 1, 4, 2 ]
gap> NextPropertyMorphism(g,h,f,PropList);
[ 3, 2, 4, 1 ]
gap> NextPropertyMorphism(g,h,f,PropList);
[ 4, 1, 3, 2 ]
gap> NextPropertyMorphism(g,h,f,PropList);
[ 4, 2, 3, 1 ]
gap> NextPropertyMorphism(g,h,f,PropList);
fail
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{NumberOfCliques()}
%enddisplay
\>NumberOfCliques( <G> ) A
\>NumberOfCliques( <G>, <maxNumCli> ) O

Returns the number of (maximal) cliques of <G>.  
In the second form, It stops computing cliques after <maxNumCli> of them have been counted and 
returns <maxNumCli> in case <G> has <maxNumCli> or more cliques.

\beginexample
gap> NumberOfCliques(Icosahedron);
20
gap> NumberOfCliques(Icosahedron,15);
15
gap> NumberOfCliques(Icosahedron,50);
20
\endexample

This implementation discards the cliques once counted hence, given enough time, 
it can compute the number of cliques of <G> even if the set of cliques does not fit in memory.

\beginexample
gap> NumberOfCliques(OctahedralGraph(30));
1073741824
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{NumberOfConnectedComponents()}
%enddisplay
\>NumberOfConnectedComponents( <G> ) A

Returns the number of connected components of <G>.


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{OctahedralGraph()}
%enddisplay
\>OctahedralGraph( <n> ) F

Return the <n>-dimensional octahedron. This is the complement of <n> copies
of $K_2$ (an edge). It is also the <(2n-2)>-regular graph on $2n$ vertices.

\beginexample
gap> OctahedralGraph(3);
Graph( Category := SimpleGraphs, Order := 6, Size := 12, Adjacencies :=
[ [ 3, 4, 5, 6 ], [ 3, 4, 5, 6 ], [ 1, 2, 5, 6 ], [ 1, 2, 5, 6 ],
[ 1, 2, 3, 4 ], [ 1, 2, 3, 4 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{Octahedron}
%enddisplay
\>`Octahedron' V

The 1-skeleton of Plato's octahedron.

\beginexample
gap> Octahedron;
Graph( Category := SimpleGraphs, Order := 6, Size := 12, Adjacencies :=
[ [ 3, 4, 5, 6 ], [ 3, 4, 5, 6 ], [ 1, 2, 5, 6 ], [ 1, 2, 5, 6 ],
  [ 1, 2, 3, 4 ], [ 1, 2, 3, 4 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{Order()}
%enddisplay
\>Order( <G> ) A

Returns the number of vertices, of graph <G>.

\beginexample
gap> Order(Icosahedron);
12
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{OrientedGraphs()}
%enddisplay
\>OrientedGraphs( ) C

`OrientedGraphs' is a graph category in {\YAGS}. A graph in this category may 
contain arrows, but no loops or edges. The parent of this category is `LooplessGraphs'.

\beginexample
gap> GraphByWalks([1,1],[1,2],[2,1],[3,2]:GraphCategory:=Graphs);
Graph( Category := Graphs, Order := 3, Size := 4, Adjacencies := 
[ [ 1, 2 ], [ 1 ], [ 2 ] ] )
gap> GraphByWalks([1,1],[1,2],[2,1],[3,2]:GraphCategory:=OrientedGraphs);
Graph( Category := OrientedGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [  ], [ 2 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{OutNeigh()}
%enddisplay
\>OutNeigh( <G>, <x> ) O

Returns the list of out-neighbors of <x> in <G>.

\beginexample
gap> tt:=CompleteGraph(5:GraphCategory:=OrientedGraphs);
Graph( Category := OrientedGraphs, Order := 5, Size := 10, Adjacencies := 
[ [ 2, 3, 4, 5 ], [ 3, 4, 5 ], [ 4, 5 ], [ 5 ], [  ] ] )
gap> InNeigh(tt,3);                                     
[ 1, 2 ]
gap> OutNeigh(tt,3);                                    
[ 4, 5 ]
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{ParachuteGraph}
%enddisplay
\>`ParachuteGraph' V

The complement of a `ParapluieGraph'; The suspension of a 4-path with a 
pendant vertex attached to the south pole.

\beginexample
gap> ParachuteGraph;
Graph( Category := SimpleGraphs, Order := 7, Size := 12, Adjacencies := 
[ [ 2 ], [ 1, 3, 4, 5, 6 ], [ 2, 4, 7 ], [ 2, 3, 5, 7 ], [ 2, 4, 6, 7 ], 
  [ 2, 5, 7 ], [ 3, 4, 5, 6 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{ParapluieGraph}
%enddisplay
\>`ParapluieGraph' V

A 3-Fan graph with a 3-path attached to the universal vertex.

\beginexample
gap> ParapluieGraph;
Graph( Category := SimpleGraphs, Order := 7, Size := 9, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2, 4, 5, 6, 7 ], [ 3, 5 ], [ 3, 4, 6 ], [ 3, 5, 7 ], 
  [ 3, 6 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{ParedGraph()}
%enddisplay
\>ParedGraph( <G> ) O

Returns the pared graph of <G>. This is the induced subgraph obtained from 
<G> by removing its dominated vertices. When there are twin vertices 
(mutually dominated vertices), exactly one of them survives the paring in 
each equivalent class of mutually dominated vertices.

\beginexample
gap> g1:=PathGraph(4);
Graph( Category := SimpleGraphs, Order := 4, Size := 3, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2, 4 ], [ 3 ] ] )
gap> ParedGraph(g1);  
Graph( Category := SimpleGraphs, Order := 2, Size := 1, Adjacencies := 
[ [ 2 ], [ 1 ] ] )
gap> g2:=PathGraph(2);
Graph( Category := SimpleGraphs, Order := 2, Size := 1, Adjacencies := 
[ [ 2 ], [ 1 ] ] )
gap> ParedGraph(g2);  
Graph( Category := SimpleGraphs, Order := 1, Size := 0, Adjacencies := 
[ [  ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{PathGraph()}
%enddisplay
\>PathGraph( <n> ) F

Returns the path graph on <n> vertices.

\beginexample
gap> PathGraph(4);
Graph( Category := SimpleGraphs, Order := 4, Size := 3, Adjacencies :=
[ [ 2 ], [ 1, 3 ], [ 2, 4 ], [ 3 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{PawGraph}
%enddisplay
\>`PawGraph' V

The graph on 4 vertices, 4 edges and maximum degree 3: A triangle with a pendant vertex.

\beginexample
gap> PawGraph;
Graph( Category := SimpleGraphs, Order := 4, Size := 4, Adjacencies :=
[ [ 2 ], [ 1, 3, 4 ], [ 2, 4 ], [ 2, 3 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{PetersenGraph}
%enddisplay
\>`PetersenGraph' V

The 3-regular graph on 10 vertices having girth 5. 

\beginexample
gap> PetersenGraph;  
Graph( Category := SimpleGraphs, Order := 10, Size := 15, Adjacencies := 
[ [ 2, 5, 6 ], [ 1, 3, 7 ], [ 2, 4, 8 ], [ 3, 5, 9 ], [ 1, 4, 10 ], 
  [ 1, 8, 9 ], [ 2, 9, 10 ], [ 3, 6, 10 ], [ 4, 6, 7 ], [ 5, 7, 8 ] ] )  
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{PowerGraph()}
%enddisplay
\>PowerGraph( <G>, <exp> ) O

Returns the `DistanceGraph' of <G> using `[0, 1, ..., <exp>]' as the list of distances. 
Note that the distance `0' in the list produces loops in the new graph only when the 
`TargetGraphCategory' admits loops.

\beginexample
gap> g:=PathGraph(5);
Graph( Category := SimpleGraphs, Order := 5, Size := 4, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 4 ] ] )
gap> PowerGraph(g,1);                      
Graph( Category := SimpleGraphs, Order := 5, Size := 4, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 4 ] ] )
gap> PowerGraph(g,1:GraphCategory:=Graphs);
Graph( Category := Graphs, Order := 5, Size := 13, Adjacencies := 
[ [ 1, 2 ], [ 1, 2, 3 ], [ 2, 3, 4 ], [ 3, 4, 5 ], [ 4, 5 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{PropertyMorphism()}
%enddisplay
\>PropertyMorphism( <G>, <H>, <PropList> ) O

Returns the first morphism (in lexicographic order) from <G> to <H> 
satisfying the list of properties <PropList>.

A number of preprogrammed properties are provided by {\YAGS}, and the user may create 
additional ones. The properties provided are: `CHK_WEAK', `CHK_MORPH', `CHK_METRIC', 
`CHK_CMPLT', `CHK_MONO' and `CHK_EPI'.

If <G> has <n> vertices and $f:G\rightarrow H$ is a morphism, it is 
represented as `<F>=[f(1), f(2), ..., f(n)]'. 

\beginexample
gap> g:=CycleGraph(4);;h:=CompleteBipartiteGraph(2,2);;
gap> PropList:=[CHK_MORPH];;                            
gap> PropertyMorphism(g,h,PropList);                          
[ 1, 3, 1, 3 ]
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{PropertyMorphisms()}
%enddisplay
\>PropertyMorphisms( <G>, <H>, <PropList> ) O

Returns all morphisms from <G> to <H> 
satisfying the list of properties <PropList>.

A number of preprogrammed properties are provided by {\YAGS}, and the user may create 
additional ones. The properties provided are: `CHK_WEAK', `CHK_MORPH', `CHK_METRIC', 
`CHK_CMPLT', `CHK_MONO' and `CHK_EPI'.

If <G> has <n> vertices and $f:G\rightarrow H$ is a morphism, it is 
represented as `<F>=[f(1), f(2), ..., f(n)]'. 

\beginexample
gap> g:=CycleGraph(4);;h:=CompleteBipartiteGraph(2,2);;
gap> PropList:=[CHK_WEAK,CHK_MONO];;                    
gap> PropertyMorphisms(g,h,PropList);
[ [ 1, 3, 2, 4 ], [ 1, 4, 2, 3 ], [ 2, 3, 1, 4 ], [ 2, 4, 1, 3 ], 
  [ 3, 1, 4, 2 ], [ 3, 2, 4, 1 ], [ 4, 1, 3, 2 ], [ 4, 2, 3, 1 ] ]
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{QtfyIsSimple()}
%enddisplay
\>QtfyIsSimple( <G> ) A

For internal use. Returns how far is graph <G> from being simple.


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{QuotientGraph()}
%enddisplay
\>QuotientGraph( <G>, <Part> ) O
\>QuotientGraph( <G>, <L1>, <L2> ) O

Returns the quotient graph of graph <G> given a vertex partition
<Part>, by identifying any two vertices in the same part. 
The vertices of the quotient
graph are the parts in the partition <Part> two of them
being adjacent iff any vertex in one part is adjacent to any vertex in the other part.
Singletons may be omited in <Part>.

\beginexample 
gap> g:=PathGraph(8);; 
gap> QuotientGraph(g,[[1,5,8],[2],[3],[4],[6],[7]]);
Graph( Category := SimpleGraphs, Order := 6, Size := 7, Adjacencies := 
[ [ 2, 4, 5, 6 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3 ], [ 1, 6 ], [ 1, 5 ] ] )
gap> QuotientGraph(g,[[1,5,8]]);  
Graph( Category := SimpleGraphs, Order := 6, Size := 7, Adjacencies := 
[ [ 2, 4, 5, 6 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3 ], [ 1, 6 ], [ 1, 5 ] ] )
\endexample

In its second form, `QuotientGraph' identifies each vertex in list <L1>, 
with the corresponding vertex in list <L2>. <L1> and <L2> must have the same length,
but any or both of them may have repetitions.

\beginexample 
gap> g:=PathGraph(8);; 
gap> QuotientGraph(g,[[1,7],[4,8]]);
Graph( Category := SimpleGraphs, Order := 6, Size := 7, Adjacencies := 
[ [ 2, 4, 6 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3, 5 ], [ 4, 6 ], [ 1, 5 ] ] )
gap> QuotientGraph(g,[1,4],[7,8]);  
Graph( Category := SimpleGraphs, Order := 6, Size := 7, Adjacencies := 
[ [ 2, 4, 6 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3, 5 ], [ 4, 6 ], [ 1, 5 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{Radius()}
%enddisplay
\>Radius( <G> ) A

Returns the minimal eccentricity among the vertices of graph <G>.

\beginexample
gap> Radius(PathGraph(5)); 
2
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{RandomGraph()}
%enddisplay
\>RandomGraph( <n>, <p> ) F
\>RandomGraph( <n> ) F

Returns a random graph of order <n> taking the rational $p\in [0,1]$ as the edge probability. 

\beginexample
gap> RandomGraph(5,1/3);
Graph( Category := SimpleGraphs, Order := 5, Size := 2, Adjacencies := 
[ [ 5 ], [ 5 ], [  ], [  ], [ 1, 2 ] ] )
gap> RandomGraph(5,2/3);
Graph( Category := SimpleGraphs, Order := 5, Size := 6, Adjacencies := 
[ [ 4, 5 ], [ 3, 4, 5 ], [ 2, 4 ], [ 1, 2, 3 ], [ 1, 2 ] ] )
gap> RandomGraph(5,1/2);
Graph( Category := SimpleGraphs, Order := 5, Size := 4, Adjacencies := 
[ [ 2, 5 ], [ 1, 3, 5 ], [ 2 ], [  ], [ 1, 2 ] ] )
\endexample

If <p> is ommited, the edge probability is taken to be 1/2.

\beginexample
gap> RandomGraph(5);    
Graph( Category := SimpleGraphs, Order := 5, Size := 5, Adjacencies := 
[ [ 2, 3 ], [ 1 ], [ 1, 4, 5 ], [ 3, 5 ], [ 3, 4 ] ] )
gap> RandomGraph(5);
Graph( Category := SimpleGraphs, Order := 5, Size := 3, Adjacencies := 
[ [ 2, 5 ], [ 1, 4 ], [  ], [ 2 ], [ 1 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{RandomlyPermuted()}
%enddisplay
\>RandomlyPermuted( <Obj> ) O

Returns a copy of <Obj> with the order of its elements permuted randomly.
Currently, the operation is implemented for lists and graphs.

\beginexample
gap> RandomlyPermuted([1..9]);
[ 9, 7, 5, 3, 1, 4, 8, 6, 2 ]
gap> g:=PathGraph(4);
Graph( Category := SimpleGraphs, Order := 4, Size := 3, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2, 4 ], [ 3 ] ] )
gap> RandomlyPermuted(g);           
Graph( Category := SimpleGraphs, Order := 4, Size := 3, Adjacencies := 
[ [ 4 ], [ 3, 4 ], [ 2 ], [ 1, 2 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{RandomPermutation()}
%enddisplay
\>RandomPermutation( <n> ) O

Returns a random permutation of the list `[1, 2, ... <n>]'.

\beginexample
gap> RandomPermutation(12);
(1,8,10)(2,7,9,12)(3,5,11)(4,6)
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{RemoveEdges()}
%enddisplay
\>RemoveEdges( <G>, <E> ) O

Returns a new graph created from graph <G> by removing the edges in list <E>.

\beginexample
gap> g:=CompleteGraph(4);
Graph( Category := SimpleGraphs, Order := 4, Size := 6, Adjacencies := 
[ [ 2, 3, 4 ], [ 1, 3, 4 ], [ 1, 2, 4 ], [ 1, 2, 3 ] ] )
gap> RemoveEdges(g,[[1,2]]);
Graph( Category := SimpleGraphs, Order := 4, Size := 5, Adjacencies := 
[ [ 3, 4 ], [ 3, 4 ], [ 1, 2, 4 ], [ 1, 2, 3 ] ] )
gap> RemoveEdges(g,[[1,2],[3,4]]);
Graph( Category := SimpleGraphs, Order := 4, Size := 4, Adjacencies := 
[ [ 3, 4 ], [ 3, 4 ], [ 1, 2 ], [ 1, 2 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{RemoveVertices()}
%enddisplay
\>RemoveVertices( <G>, <V> ) O

Returns a new graph created from graph <G> by removing the vertices in list <V>.

\beginexample
gap> g:=PathGraph(5);
Graph( Category := SimpleGraphs, Order := 5, Size := 4, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 4 ] ] )
gap> RemoveVertices(g,[3]);
Graph( Category := SimpleGraphs, Order := 4, Size := 2, Adjacencies := 
[ [ 2 ], [ 1 ], [ 4 ], [ 3 ] ] )
gap> RemoveVertices(g,[1,3]);
Graph( Category := SimpleGraphs, Order := 3, Size := 1, Adjacencies := 
[ [  ], [ 3 ], [ 2 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{RGraph}
%enddisplay
\>`RGraph' V

A square with two pendant vertices attached to the same vertex of the square.

\beginexample
gap> RGraph;
Graph( Category := SimpleGraphs, Order := 6, Size := 6, Adjacencies := 
[ [ 2 ], [ 1, 3, 5, 6 ], [ 2, 4 ], [ 3, 5 ], [ 2, 4 ], [ 2 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{RingGraph()}
%enddisplay
\>RingGraph( <Rng>, <Elms> ) O

Returns the graph G whose vertices are the elements of the ring <Rng> 
such that x is adjacent to y iff x+r=y for some r in <Elms>.

\beginexample
gap> r:=FiniteField(8);Elements(r); 
GF(2^3)
[ 0*Z(2), Z(2)^0, Z(2^3), Z(2^3)^2, Z(2^3)^3, Z(2^3)^4, Z(2^3)^5, Z(2^3)^6 ]
gap> RingGraph(r,[Z(2^3),Z(2^3)^4]);
Graph( Category := SimpleGraphs, Order := 8, Size := 8, Adjacencies := 
[ [ 3, 6 ], [ 5, 7 ], [ 1, 4 ], [ 3, 6 ], [ 2, 8 ], [ 1, 4 ], [ 2, 8 ], 
  [ 5, 7 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{SetCoordinates()}
%enddisplay
\>SetCoordinates( <G>, <Coord> ) O

Sets the coordinates of the vertices of <G>, which are used to draw <G>
by `Draw( <G> )'. 

\beginexample
gap> g:=CycleGraph(4);;
gap> SetCoordinates(g,[[-10,-10 ],[-10,20],[20,-10 ], [20,20]]);
gap> Coordinates(g);
[ [ -10, -10 ], [ -10, 20 ], [ 20, -10 ], [ 20, 20 ] ]
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{SetDefaultGraphCategory()}
%enddisplay
\>SetDefaultGraphCategory( <Catgy> ) F

Sets the default graph category to <Catgy>. The default graph
category is used when constructing new graphs when no other graph category 
is indicated. New graphs are always forced to comply with the `TargetGraphCategory', 
so loops may be removed, and arrows may replaced by edges or viceversa, depending on 
the category that the new graph belongs to.

The available graph categories are:  `SimpleGraphs', `OrientedGraphs', 
`UndirectedGraphs', `LooplessGraphs', and `Graphs'.

\beginexample
gap> SetDefaultGraphCategory(Graphs);
gap> GraphByWalks([1,1],[1,2],[2,1],[3,2]);
Graph( Category := Graphs, Order := 3, Size := 4, Adjacencies := 
[ [ 1, 2 ], [ 1 ], [ 2 ] ] )
gap> SetDefaultGraphCategory(LooplessGraphs);
gap> GraphByWalks([1,1],[1,2],[2,1],[3,2]);  
Graph( Category := LooplessGraphs, Order := 3, Size := 3, Adjacencies := 
[ [ 2 ], [ 1 ], [ 2 ] ] )
gap> SetDefaultGraphCategory(UndirectedGraphs);
gap> GraphByWalks([1,1],[1,2],[2,1],[3,2]);    
Graph( Category := UndirectedGraphs, Order := 3, Size := 3, Adjacencies := 
[ [ 1, 2 ], [ 1, 3 ], [ 2 ] ] )
gap> SetDefaultGraphCategory(SimpleGraphs);    
gap> GraphByWalks([1,1],[1,2],[2,1],[3,2]);
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
gap> SetDefaultGraphCategory(OrientedGraphs);
gap> GraphByWalks([1,1],[1,2],[2,1],[3,2]);  
Graph( Category := OrientedGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [  ], [ 2 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{SimpleGraphs()}
%enddisplay
\>SimpleGraphs( ) C

`SimpleGraphs' is a graph category in {\YAGS}. A graph in this category may 
contain edges, but no loops or arrows. The category has two parents: `LooplessGraphs' 
and `UndirectedGraphs'.

\beginexample
gap> GraphByWalks([1,1],[1,2],[2,1],[3,2]:GraphCategory:=Graphs);
Graph( Category := Graphs, Order := 3, Size := 4, Adjacencies := 
[ [ 1, 2 ], [ 1 ], [ 2 ] ] )
gap> GraphByWalks([1,1],[1,2],[2,1],[3,2]:GraphCategory:=SimpleGraphs);  
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{Size()}
%enddisplay
\>Size( <G> ) A

Returns the number of edges of graph <G>.

\beginexample
gap> Size(Icosahedron);
30
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{SnubDisphenoid}
%enddisplay
\>`SnubDisphenoid' V

The 1-skeleton of the 84th Johnson solid. 

\beginexample
gap> SnubDisphenoid;
Graph( Category := SimpleGraphs, Order := 8, Size := 18, Adjacencies := 
[ [ 2, 3, 4, 5, 8 ], [ 1, 3, 6, 7, 8 ], [ 1, 2, 4, 6 ], [ 1, 3, 5, 6 ], 
  [ 1, 4, 6, 7, 8 ], [ 2, 3, 4, 5, 7 ], [ 2, 5, 6, 8 ], [ 1, 2, 5, 7 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{SpanningForest()}
%enddisplay
\>SpanningForest( <G> ) O

Returns a spanning forest of <G>.


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{SpanningForestEdges()}
%enddisplay
\>SpanningForestEdges( <G> ) O

Returns the edges of a spanning forest of <G>.


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{SpikyGraph()}
%enddisplay
\>SpikyGraph( <n> ) F

The spiky graph is constructed as follows: Take complete graph on <n> vertices, $K_N$, 
and then, for each the <n> subsets of $Vertices(K_n)$ of order <n>-1, add an additional vertex which
is adjacent precisely to this subset of $Vertices(K_n)$.

\beginexample
gap> SpikyGraph(3);
Graph( Category := SimpleGraphs, Order := 6, Size := 9, Adjacencies :=
[ [ 2, 3, 4, 5 ], [ 1, 3, 4, 6 ], [ 1, 2, 5, 6 ], [ 1, 2 ], [ 1, 3 ],
  [ 2, 3 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{SunGraph()}
%enddisplay
\>SunGraph( <n> ) F

Returns the <n>-Sun: A complete graph on <n> vertices, $K_N$, with a corona 
made with a zigzagging 2<n>-cycle glued to a <n>-cycle of the $K_N$.

\beginexample
gap> SunGraph(3);
Graph( Category := SimpleGraphs, Order := 6, Size := 9, Adjacencies := 
[ [ 2, 6 ], [ 1, 3, 4, 6 ], [ 2, 4 ], [ 2, 3, 5, 6 ], [ 4, 6 ], 
  [ 1, 2, 4, 5 ] ] )
gap> SunGraph(4);
Graph( Category := SimpleGraphs, Order := 8, Size := 14, Adjacencies := 
[ [ 2, 8 ], [ 1, 3, 4, 6, 8 ], [ 2, 4 ], [ 2, 3, 5, 6, 8 ], [ 4, 6 ], 
  [ 2, 4, 5, 7, 8 ], [ 6, 8 ], [ 1, 2, 4, 6, 7 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{Suspension()}
%enddisplay
\>Suspension( <G> ) O

Returns the suspension of graph <G>. The suspension of <G> is the graph 
obtained from <G> by adding two new vertices which are adjacent to every 
vertex of <G> but not to each other. The new vertices are the first ones 
in the new graph.

\beginexample 
gap> Suspension(CycleGraph(4));
Graph( Category := SimpleGraphs, Order := 6, Size := 12, Adjacencies := 
[ [ 3, 4, 5, 6 ], [ 3, 4, 5, 6 ], [ 1, 2, 4, 6 ], [ 1, 2, 3, 5 ], 
  [ 1, 2, 4, 6 ], [ 1, 2, 3, 5 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{TargetGraphCategory()}
%enddisplay
\>TargetGraphCategory( [ <G>, ... ] ) F

For internal use. Returns the graph category indicated in the <options stack> if any, 
otherwise if the list of graphs provided is not empty, returns the minimal common graph 
category for the graphs in the list, else returns the default graph category.

The partial order (by inclusion) among graph categories is as follows: 
$$`SimpleGraphs' \<  `UndirectedGraphs' \< `Graphs',$$
$$`OrientedGraphs' \< `LooplessGraphs' \< `Graphs'$$  
$$`SimpleGraphs' \< `LooplessGraphs' \< `Graphs'$$
 
This function is internally called by all graph constructing operations in {\YAGS} to decide the 
graph category that the newly constructed graph is going to belong. New graphs are always 
forced to comply with the `TargetGraphCategory', so loops may be removed, and arrows may 
replaced by edges or viceversa, depending on the category that the new graph belongs to.

The <options stack> is a mechanism provided by {\GAP} to pass implicit parameters 
and is used by `TargetGraphCategory' so that the user may indicate the graph 
category she/he wants for the new graph.

\beginexample
gap> SetDefaultGraphCategory(SimpleGraphs);             
gap> g1:=CompleteGraph(2);                              
Graph( Category := SimpleGraphs, Order := 2, Size := 1, Adjacencies := 
[ [ 2 ], [ 1 ] ] )
gap> g2:=CompleteGraph(2:GraphCategory:=OrientedGraphs);
Graph( Category := OrientedGraphs, Order := 2, Size := 1, Adjacencies := 
[ [ 2 ], [  ] ] )
gap> DisjointUnion(g1,g2);
Graph( Category := LooplessGraphs, Order := 4, Size := 3, Adjacencies := 
[ [ 2 ], [ 1 ], [ 4 ], [  ] ] )
gap> DisjointUnion(g1,g2:GraphCategory:=UndirectedGraphs);
Graph( Category := UndirectedGraphs, Order := 4, Size := 2, Adjacencies := 
[ [ 2 ], [ 1 ], [ 4 ], [ 3 ] ] )
\endexample

In the previous examples, `TargetGraphCategory' was called internally exactly once for 
each new graph constructed with the following parameters:

\beginexample
gap> TargetGraphCategory();
<Operation "SimpleGraphs">
gap> TargetGraphCategory(:GraphCategory:=OrientedGraphs);
<Operation "OrientedGraphs">
gap> TargetGraphCategory([g1,g2]);                       
<Operation "LooplessGraphs">
gap> TargetGraphCategory([g1,g2]:GraphCategory:=UndirectedGraphs);
<Operation "UndirectedGraphs">
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{Tetrahedron}
%enddisplay
\>`Tetrahedron' V

The 1-skeleton of Plato's tetrahedron.

\beginexample
gap> Tetrahedron;
Graph( Category := SimpleGraphs, Order := 4, Size := 6, Adjacencies :=
[ [ 2, 3, 4 ], [ 1, 3, 4 ], [ 1, 2, 4 ], [ 1, 2, 3 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{TimeInSeconds()}
%enddisplay
\>TimeInSeconds( ) O

Returns the time in seconds since 1970-01-01 00:00:00 UTC as an integer.
This is useful to measure execution time. It can also be used to impose 
time constraints on the execution of algorithms. Note however that the time 
reported is the 'wall time', not necessarily the time spent in the process
you intend to measure.

\beginexample
gap> TimeInSeconds();
1415551598
gap> K:=CliqueGraph;;
gap>  t1:=TimeInSeconds();NumberOfCliques(K(K(K(K(Icosahedron)))));TimeInSeconds()-t1;
1415551608
44644
103
\endexample
  
Currently, this operation is not working on MS Windows.


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{TimesProduct()}
%enddisplay
\>TimesProduct( <G>, <H> ) O

Returns the times product of two graphs <G> and <H>, <G> $\times$ <H>
(also known as the tensor product).

The times product is computed as follows:

For each pair of vertices $x \in G, y \in H$ we create a vertex
$(x,y)$. Given two such vertices $(x,y)$ and $(x',y')$ they are
adjacent <iff> $x \sim x'$ and $y \sim y'$.

\beginexample
gap> g:=PathGraph(3);h:=CycleGraph(4);                              
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
Graph( Category := SimpleGraphs, Order := 4, Size := 4, Adjacencies := 
[ [ 2, 4 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3 ] ] )
gap> gh:=TimesProduct(g,h);         
Graph( Category := SimpleGraphs, Order := 12, Size := 16, Adjacencies := 
[ [ 6, 8 ], [ 5, 7 ], [ 6, 8 ], [ 5, 7 ], [ 2, 4, 10, 12 ], [ 1, 3, 9, 11 ], 
  [ 2, 4, 10, 12 ], [ 1, 3, 9, 11 ], [ 6, 8 ], [ 5, 7 ], [ 6, 8 ], [ 5, 7 ] ] )
gap> VertexNames(gh);                 
[ [ 1, 1 ], [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 2, 1 ], [ 2, 2 ], [ 2, 3 ], 
  [ 2, 4 ], [ 3, 1 ], [ 3, 2 ], [ 3, 3 ], [ 3, 4 ] ]
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{TrivialGraph}
%enddisplay
\>`TrivialGraph' V

The one vertex graph.

\beginexample
gap> TrivialGraph;
Graph( Category := SimpleGraphs, Order := 1, Size := 0, Adjacencies :=
[ [  ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{UFFind()}
%enddisplay
\>UFFind( <UFS>, <x> ) F

For internal use. Implements the <find> operation on the <union-find structure>. 


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{UFUnite()}
%enddisplay
\>UFUnite( <UFS>, <x>, <y> ) F

For internal use. Implements the <unite> operation on the <union-find structure>. 


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{UndirectedGraphs()}
%enddisplay
\>UndirectedGraphs( ) C

`UndirectedGraphs' is a graph category in {\YAGS}. A graph in this category may 
contain edges and loops, but no arrows. The parent of this category is `Graphs'.

\beginexample
gap> GraphByWalks([1,1],[1,2],[2,1],[3,2]:GraphCategory:=Graphs);
Graph( Category := Graphs, Order := 3, Size := 4, Adjacencies := 
[ [ 1, 2 ], [ 1 ], [ 2 ] ] )
gap> GraphByWalks([1,1],[1,2],[2,1],[3,2]:GraphCategory:=UndirectedGraphs);
Graph( Category := UndirectedGraphs, Order := 3, Size := 3, Adjacencies := 
[ [ 1, 2 ], [ 1, 3 ], [ 2 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{UnitsRingGraph()}
%enddisplay
\>UnitsRingGraph( <Rng> ) O

Returns the graph G whose vertices are the elements of <Rng> 
such that x is adjacent to y iff x+z=y for some unit z of <Rng>.

\beginexample
gap> UnitsRingGraph(ZmodnZ(8));    
Graph( Category := SimpleGraphs, Order := 8, Size := 16, Adjacencies := 
[ [ 2, 4, 6, 8 ], [ 1, 3, 5, 7 ], [ 2, 4, 6, 8 ], [ 1, 3, 5, 7 ], 
  [ 2, 4, 6, 8 ], [ 1, 3, 5, 7 ], [ 2, 4, 6, 8 ], [ 1, 3, 5, 7 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{VertexDegree()}
%enddisplay
\>VertexDegree( <G>, <x> ) O

Returns the degree of vertex <x> in Graph <G>. 

\beginexample
gap> g:=PathGraph(3);
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
gap> VertexDegree(g,1);
1
gap> VertexDegree(g,2);
2
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{VertexDegrees()}
%enddisplay
\>VertexDegrees( <G> ) O

Returns the list of degrees of the vertices in graph <G>.

\beginexample
gap> g:=GemGraph;
Graph( Category := SimpleGraphs, Order := 5, Size := 7, Adjacencies := 
[ [ 2, 3, 4, 5 ], [ 1, 3 ], [ 1, 2, 4 ], [ 1, 3, 5 ], [ 1, 4 ] ] )
gap> VertexDegrees(g);
[ 4, 2, 3, 3, 2 ]
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{VertexNames()}
%enddisplay
\>VertexNames( <G> ) A

Return the list of names of the vertices of <G>. The vertices of a graph in {\YAGS} are always 
$\{1,2, \ldots, Order(G)\}$, but depending on how the graph was constructed, its vertices may 
have also some <names>, that help us identify the origin of the vertices. {\YAGS} will always try 
to store meaninful names for the vertices. For example, in the case of the LineGraph, the vertex 
names of the new graph are the edges of the old graph.

\beginexample
gap> g:=LineGraph(DiamondGraph);          
Graph( Category := SimpleGraphs, Order := 5, Size := 8, Adjacencies := 
[ [ 2, 3, 4 ], [ 1, 3, 4, 5 ], [ 1, 2, 5 ], [ 1, 2, 5 ], [ 2, 3, 4 ] ] )
gap> VertexNames(g);
[ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 2, 3 ], [ 3, 4 ] ]
gap> Edges(DiamondGraph);
[ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 2, 3 ], [ 3, 4 ] ]
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{Vertices()}
%enddisplay
\>Vertices( <G> ) O

Returns the list [1..Order( <G> )].

\beginexample
gap> Vertices(Icosahedron);
[ 1 .. 12 ]
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{WheelGraph()}
%enddisplay
\>WheelGraph( <n> ) O
\>WheelGraph( <n>, <r> ) O

In its first form `WheelGraph' returns the wheel graph on <n>+1 vertices. This is the 
cone of a cycle: a central vertex adjacent to all the vertices of an <n>-cycle.

\beginexample
WheelGraph(5);
gap> Graph( Category := SimpleGraphs, Order := 6, Size := 10, Adjacencies :=
[ [ 2, 3, 4, 5, 6 ], [ 1, 3, 6 ], [ 1, 2, 4 ], [ 1, 3, 5 ], [ 1, 4, 6 ],
 [ 1, 2, 5 ] ] )
\endexample

In its second form, `WheelGraph' returns returns the wheel graph, but adding 
<r>-1 layers, each layer is a new <n>-cycle joined to the previous layer 
by a zigzagging 2<n>-cycle. This graph is a triangulation of the disk.

\beginexample
gap> WheelGraph(5,2);
Graph( Category := SimpleGraphs, Order := 11, Size := 25, Adjacencies := 
[ [ 2, 3, 4, 5, 6 ], [ 1, 3, 6, 7, 8 ], [ 1, 2, 4, 8, 9 ], [ 1, 3, 5, 9, 10 ],
  [ 1, 4, 6, 10, 11 ], [ 1, 2, 5, 7, 11 ], [ 2, 6, 8, 11 ], [ 2, 3, 7, 9 ], 
  [ 3, 4, 8, 10 ], [ 4, 5, 9, 11 ], [ 5, 6, 7, 10 ] ] )
gap> WheelGraph(5,3);
Graph( Category := SimpleGraphs, Order := 16, Size := 40, Adjacencies := 
[ [ 2, 3, 4, 5, 6 ], [ 1, 3, 6, 7, 8 ], [ 1, 2, 4, 8, 9 ], [ 1, 3, 5, 9, 10 ],
  [ 1, 4, 6, 10, 11 ], [ 1, 2, 5, 7, 11 ], [ 2, 6, 8, 11, 12, 13 ], 
  [ 2, 3, 7, 9, 13, 14 ], [ 3, 4, 8, 10, 14, 15 ], [ 4, 5, 9, 11, 15, 16 ], 
  [ 5, 6, 7, 10, 12, 16 ], [ 7, 11, 13, 16 ], [ 7, 8, 12, 14 ], 
  [ 8, 9, 13, 15 ], [ 9, 10, 14, 16 ], [ 10, 11, 12, 15 ] ] )
\endexample


%display{tex}
\advance\xsecno by1
\edef\tempa{\thechapter.\the\xsecno}
\expandafter\writesecline\tempa\\{YagsExec()}
%enddisplay
\>YagsExec( <ProgName>, <InString> ) O

For internal use. Calls external program <ProgName> located in directory 
'<YagsDir>/bin/' feeding it with <InString> as input and returning 
the output of the external program as a string. 'fail' is returned if
the program could not be located.

\beginexample
gap> YagsExec("time","");
"1415551127\n"
gap> YagsExec("nauty","l=0$=1dacn=5 g1,2,3. xbzq");
"(4,5)\n(2,3)\n[2,3,4,5,1]\n[\"cb0c\",\"484f264\",\"b0e19f1\"]\n"
\endexample
  
Currently, this operation is not working on MS Windows.


