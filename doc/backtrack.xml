<Chapter Label="backtracking">
  <Heading>Backtracking</Heading>

<P/>Backtracking is an algorithmic technique for searching in
combinatorial spaces. In this chapter we describe the technique and
the facilities provided by &YAGS; to aid in the rapid prototyping of
backtracking algorithms. This chapter is written for the non-expert
programmer, which is who can benefit the most from these facilities.

<P/>While the expert programmer will not have any problem designing
her/his own backtracking algorithms, she/he can still benefit from
&YAGS;'s bactracking facilities since it may still faster to
implemet/test/prototype a backtracking algorithm using &YAGS;'s
facilities. A minimal example (for computing derangements) can be
found in <Ref Func="BackTrack"/>.

<P/>The kind of combinatorial problems that can be addressed by
backtracking are those that can be represented by a decision tree,
and these include problems where we want to find: morphisms,
isomorphisms, cages, colorings, cliques, hamiltonian cycles, walks,
paths, subgraphs, and much much more.  Combinatorial problems that can
be represented by a decision tree are truly everywhere.

<P/>As a concrete example, consider the graph coloring problem: You have
<M>k</M> colors <M>\{C_1, C_2, \ldots, C_k\}</M> and a graph <M>G</M> and
you want to color all the vertices of a graph in such a way that no two
adjacent vertices have the same color. How would you proceed? Well,
probably, you would pick some random color <M>C_1</M>
**** decision tree, code, efficency (the problem, the code), improvements, code.

**otro ejemplo?


<Section Label="asimpleexample">
<Heading>A Simple Example</Heading>


<Log>
gap> chk:=function(L,extra)
> local x,y,x1,y1;
> x:=Length(L);y:=L[x];
> for x1 in [1..x-1] do
>   y1:=L[x1];
>   if y=y1 then return false; fi;
>   if x-y = x1-y1 then return false; fi;
>   if x+y = x1+y1 then return false; fi;
> od;
> return true;
> end;
function( L, extra ) ... end
gap> BackTrackBag([1..8],chk,8,0);
[ [ 1, 5, 8, 6, 3, 7, 2, 4 ], [ 1, 6, 8, 3, 7, 4, 2, 5 ], 
  [ 1, 7, 4, 6, 8, 2, 5, 3 ], [ 1, 7, 5, 8, 2, 4, 6, 3 ], 
  [ 2, 4, 6, 8, 3, 1, 7, 5 ], [ 2, 5, 7, 1, 3, 8, 6, 4 ],
  --- many more line here ---
  [ 7, 4, 2, 8, 6, 1, 3, 5 ], [ 7, 5, 3, 1, 6, 8, 2, 4 ], 
  [ 8, 2, 4, 1, 7, 5, 3, 6 ], [ 8, 2, 5, 3, 1, 7, 4, 6 ], 
  [ 8, 3, 1, 6, 2, 5, 7, 4 ], [ 8, 4, 1, 3, 6, 2, 7, 5 ] ]
</Log>
    
  </Section>
  <Section Label="howdoesitwork">
    <Heading>How Does it Work?</Heading>

  </Section>
  <Section Label="backtrackingindepth">
    <Heading>Backtracking in Depth</Heading>

  </Section>
</Chapter>
