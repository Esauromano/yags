\Chapter{Basics}

\YAGS \ \ (Yet Another Graph System) is a system designed to aid in the
study of graphs. Therefore it provides functions designed to help
researchers in this field. The main goal was, as a start, to be
thorough and provide as much functionality as possible, and at a later
stage to increase the efficiency of the system. Furthermore, a module
on genetic algorithms is provided to allow experiments with graphs to
be carried out.

This chapter is intended as a gentle tutorial on working with \YAGS \
\ (some knowledge of \GAP \  and the basic use of a
computer are assumed). 

The tutorial is divided as follows:
\beginlist
\item{$\bullet$} Using \YAGS \

\item{$\bullet$} Definition of a graph

\item{$\bullet$} A taxonomy of graphs

\item{$\bullet$} Creating graphs

\item{$\bullet$} Transforming graphs

\item{$\bullet$} Experimenting on graphs
\endlist

\Section{Using YAGS}
\endexample

\YAGS \ \ is a \GAP \ package an as such the <RequirePackage> directive is
used to start \YAGS \ 
\beginexample 
gap> RequirePackage("YAGS");

Loading  YAGS 0.01  (Yet Another Graph System),
by  R. MacKinney and M.A. Pizana
rene@xamanek.uam.mx, map@xamanek.uam.mx

true
\endexample
a double semicolon can be used to avoid the banner.

Once the package has been loaded help can be obtained at anytime using
the \GAP \ help facility. For instance get help on the function
<RandomGraph>:

\beginexample
gap> ?RandomGraph
Help: Showing `yags: RandomGraph'

> RandomGraph( <n>, <p> )                                                F
> RandomGraph( <n> )                                                     F
 
Returns  a  Random Graph of order <n>. The first form additionally takes a
parameter  <p>,  the probability of an edge to exist. A probability 1 will
return a Complete Graph and a probability 0 a Discrete Graph.
 
gap> RandomGraph(5);
Graph( Category := SimpleGraphs, Order := 5, Size := 5, Adjacencies :=
[ [ 4, 5 ], [ 4, 5 ], [  ], [ 1, 2, 5 ], [ 1, 2, 4 ] ] )
\endexample

\Section{Definition of graphs}
\endexample

A graph is defined as follows. A graph <G> is a set of vertices <V>
and a set of edges (arrows) <E>, <G> = <\{V,E\}>. The set of edges is
a set of tuples of vertices $(v_i, v_j)$ that belong to $V, v_i, v_j
\in V$ representing that $v_i, v_j$ are adjacent.

For instance, $(\{1,2,3,4\},\{(1,3),(2,4),(3,2)\})$ is a graph with
four vertices such that vertices 1 and 2 are adjacent to vertex
3 and vertex 2 is adjacent to vertex 4. Visually this can be seen as
$$
\xymatrix{
   1{\bullet} & 2{\bullet} \ar[d] \\
   3{\bullet} \ar[u] \ar[ur]& 4{\bullet} 
}  
$$

The adjacencies can also be represented as a matrix. This would be a
boolean matrix $M$ where two vertices $i,j$ are adjacent if
$M[i,j]=\text{<true>}$ and not adjacent otherwise.

Given two vertices $i,j$ in graph $G$ we will say that graph $G$ has an
*edge* $\{i,j\}$ if there is an arrow $(i,j)$ and and arrow $(j,i).$ 

$$
\xymatrix{
   {\bullet} \ar@(ur,dr)[r] & {\bullet} \ar@(dl,ul)[l]
}
\enskip
\equiv 
\enskip
\xymatrix{
   {\bullet} \ar@{-}[r] &  {\bullet}
}
$$

If a graph $G$ has an arrow that starts and finishes on the same
vertex we say that graph $G$ has a loop.

$$
\xymatrix{
   {\bullet} \ar@(ur,dr)[]
} 
$$

\YAGS \ handles graphs that have arrows, edges and loops. Graphs that,
for instance, have multiple arrows between vertices are not handled by
\YAGS \ .

$$
\xymatrix{
   {\bullet} \ar@(ur,dr)[r] \ar[r] \ar@(dr,ur)[r] & {\bullet} 
}
$$

\Section{A taxonomy of graphs}

There are several ways of characterizing graphs. \YAGS \ uses a category
system where any graph belongs to a specific category. The following
is the list of graph categories in \YAGS

\beginlist
\item{$\bullet$} <Graphs>: graphs with no particular property.
$$
\xymatrix{
   {\bullet} \ar@(ul,dl)[] \ar[dr] & & {\bullet} \ar@(l,d)[dl]\\
   & {\bullet} \ar@(r,u)[ur] & 
} 
$$
\item{$\bullet$} <Loopless>: graphs with no loops.
$$
\xymatrix{
   {\bullet} \ar[dr] & & {\bullet} \ar@(l,d)[dl]\\
   & {\bullet} \ar@(r,u)[ur] & 
} 
$$
\item{$\bullet$} <Undirected>: graphs with no arrows but only edges.
$$
\xymatrix{
   {\bullet} \ar@(ul,dl)[] \ar@{-}[dr] & & {\bullet} \ar@{-}[dl]\\
   & {\bullet} & 
} 
$$
\item{$\bullet$} <Oriented>: graphs with no edges but only arrows.
$$
\xymatrix{
   {\bullet} \ar[dr] & & {\bullet} \\
   & {\bullet} \ar[ur] & 
} 
$$
\item{$\bullet$} <SimpleGraphs>: graphs with no loops and only edges.
\endlist
$$
\xymatrix{
   {\bullet} \ar@{-}[dr] & & {\bullet} \ar@{-}[dl]\\
   & {\bullet} & 
} 
$$

The following figure shows the relationships among categories.

$$
\pstree[nodesep=5pt]{\Tr{Graphs}}
{
  \pstree{\Tr{Loopless}}
  {
         \Tr{Oriented}
         \Tr[name=S]{Simple Graphs}
  }
  \Tr[name=U]{Undirected}
}
\ncline[nodesep=5pt]{S}{U}
$$
\medskip\nobreak
\centerline{{\bf Figure 1:} Graph Categories}
\medskip

\YAGS \ uses the category of a graph to normalize it. This is helpful,
for instance, when we define an undirected graph and inadvertently
forget an arrow in its definition. The category of a graph can be
given explicitly or implicitly. To do it explicitly the category must
be given when creating a graph, as can be seen in the section
"Creating Graphs". If no category is given the category is assumed to
be the <DefaultCategory>. The default category can be changed at any
time using the <SetDefaultCategory> function.

Further information regarding categories can be found on chapter "Categories".

\Section{Creating Graphs}

There exist several ways to create a graph in \YAGS. First, a \GAP\
record can be used. To do so the record has to have either of
\beginlist
\item{$\bullet$} Adjacency List
\item{$\bullet$} Adjacency Matrix
\endlist
in the graph presented in Section "Definition of graphs" the
adjacency list would be $$[[], [4], [1,2], []]$$ 
and the adjacency matrix
$$\left[
\matrix
false & false & false & false \cr
false & false & false & true \cr
true & true & false & false \cr
false & false & false & false
\endmatrix
\right]$$

To create a graph \YAGS \ we also need the category the graph belongs
to. We give this information to the <Graph> function. For instance to
create the graph using the adjacency list we would use the following
command:

\beginexample
gap> g:=Graph(rec(Category:=OrientedGraphs,Adjacencies:=[[],[4],[1,2],[]]));
Graph( Category := OrientedGraphs, Order := 4, Size := 3, Adjacencies :=
[ [  ], [ 4 ], [ 1, 2 ], [  ] ] )
\endexample

This will create a graph <g> that represents the graph in Section
"Definition of graphs".

$$
\xymatrix{
   1{\bullet} & 2{\bullet} \ar[d] \\
   3{\bullet} \ar[u] \ar[ur]& 4{\bullet} 
}  
$$

Since the <DefaultCategory> is <SimpleGraphs> when \YAGS \ starts up
and the graph we have been using as an example is oriented we must
explicitly give the category to \YAGS. This is achieved using
<Category:=OrientedGraphs> inside the record structure.

The same graph can be created using the function <GraphByAdjacencies> as
in

\beginexample
gap> g:=GraphByAdjacencies([[],[4],[1,2],[]]:Category:=OrientedGraphs);
Graph( Category := OrientedGraphs, Order := 4, Size := 3, Adjacencies :=
[ [  ], [ 4 ], [ 1, 2 ], [  ] ] )
\endexample

In this case to explicitly give the Category of the graph we use the
construction <:Category:=OrientedGraphs> inside the function. This
construction can be used in any function to explicitly give the
category of a graph.

We said previously we can also use the adjacency matrix to
create a  graph. For instance the command

\beginexample
gap> g:=Graph(rec(Category:=OrientedGraphs,AdjMatrix:=
         [[false,false,false,false],[false,false,false,true],
         [true,true,false,false],[false,false,false,false]]));
Graph( Category := OrientedGraphs, Order := 4, Size := 3, Adjacencies :=
[ [  ], [ 4 ], [ 1, 2 ], [  ] ] )
\endexample

Creates the same graph. Note that we explicitly give the graph
category as before. We also can use the command <AdjMatrix> as in

\beginexample
gap> g:=AdjMatrix(AdjMatrix:=[[false,false,false,false],
         [false,false,false,true],[true,true,false,false],
         [false,false,false,false]]):Category:=OrientedGraphs);
Graph( Category := OrientedGraphs, Order := 4, Size := 3, Adjacencies :=
[ [  ], [ 4 ], [ 1, 2 ], [  ] ] )
\endexample

If we create the graph using any of the methods so far
described omitting the graph category \YAGS \ will create a graph
normalized to the <DefaultCategory> which by default is <SimpleGraphs>

\beginexample
gap> g:=GraphByAdjacencies([[],[4],[1,2],[]];
Graph( Category := SimpleGraphs, Order := 4, Size := 3, Adjacencies :=
[ [ 3 ], [ 3, 4 ], [ 1, 2 ], [ 2 ] ] )
\endexample

Which creates a graph with only edges

$$
\xymatrix{
   1{\bullet} & 2{\bullet} \ar@{-}[d] \\
   3{\bullet} \ar@{-}[u] \ar@{-}[ur]& 4{\bullet} 
}  
$$

There are many functions to create graphs, some from existing graphs
and some create interesting well known graphs.

Among the former we have the function <AddEdges> which adds edges to an
existing graph

\beginexample
gap> g:=GraphByAdjacencies([[],[4],[1,2],[]]);
Graph( Category := SimpleGraphs, Order := 4, Size := 3, Adjacencies :=
[ [ 3 ], [ 3, 4 ], [ 1, 2 ], [ 2 ] ] )
gap> h:=AddEdges(g,[[1,2]]);
Graph( Category := SimpleGraphs, Order := 4, Size := 4, Adjacencies :=
[ [ 2, 3 ], [ 1, 3, 4 ], [ 1, 2 ], [ 2 ] ] )
\endexample

that yields the graph $h$

$$
\xymatrix{
   1{\bullet} \ar@{-}[r] & 2{\bullet} \ar@{-}[d] \\
   3{\bullet} \ar@{-}[u] \ar@{-}[ur]& 4{\bullet} 
}  
$$

Among the latter we have the function <SunGraph> which takes an
integer as argument and returns a fresh copy of a sun graph of the
order given as argument.

\beginexample
gap> h:=SunGraph(4);
Graph( Category := SimpleGraphs, Order := 8, Size := 14, Adjacencies :=
[ [ 2, 8 ], [ 1, 3, 4, 6, 8 ], [ 2, 4 ], [ 2, 3, 5, 6, 8 ], [ 4, 6 ],
  [ 2, 4, 5, 7, 8 ], [ 6, 8 ], [ 1, 2, 4, 6, 7 ] ] )
\endexample

that produces $h$ as

$$
\xygraph{
 \bullet-[dr]\bullet-[dl]\bullet-[ul]\bullet-[ur],
 [dr(.5)]\bullet-[d]\bullet-[l]\bullet-[u]\bullet-[r],
 [dr(.5)]-[dl][r]-[ul]
}
$$

Further information regarding constructing graphs can be found on
chapter "Constructing graphs".

\Section{Transforming graphs}

\Section{Experimenting on graphs}

Coming soon!


