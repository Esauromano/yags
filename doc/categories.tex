% This file was created automatically from categories.msk.
% DO NOT EDIT!
\Chapter{Categories}

\Section{Graph Categories}
Using {\GAP} category facilities \YAGS \ defines a hierarchy of
graphs. The categories defined are as follows.

\>Graphs( ) C

`Graphs' is the most general graph category in \YAGS. This category contains
all graphs that can be represented in \YAGS. A graph in this category may 
contain loops, arrows and edges (which in \YAGS\ are exactly the same as two opposite 
arrows between some pair of vertices). This graph category has no parent category.

\beginexample
gap> GraphByWalks([1,1],[1,2],[2,1],[3,2]:GraphCategory:=Graphs);
Graph( Category := Graphs, Order := 3, Size := 4, Adjacencies := 
[ [ 1, 2 ], [ 1 ], [ 2 ] ] )
gap> GraphByWalks([1,1],[1,2],[2,1],[3,2]:GraphCategory:=SimpleGraphs);  
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
\endexample



Among them we can find:

$$
\xymatrix{
   {\bullet} \ar@(dr,dl)[d] \ar[dr] \\
   {\bullet} \ar@(ul,ur)[u] \ar[r] & {\bullet}
} 
\hskip 1cm
\xymatrix{
   {\bullet} \ar@{-}[dr] & {\bullet} \ar[dl]\\
   {\bullet} & {\bullet} \ar@(ur,dr)[]\ar[l]
} 
$$
\bigskip
$$
\xymatrix{
   {\bullet} \ar@(ul,dl)[] \ar[dr] & & {\bullet} \ar@(l,d)[dl]\\
   & {\bullet} \ar@(r,u)[ur] & 
} 
\hskip 1cm
\xymatrix{
   & {\bullet} \ar@{-}[dl] \ar@{-}[dr] & & {\bullet} \ar@{-}[dl] \\
   {\bullet} & & {\bullet} \ar@{-}[dr] \\
   & {\bullet} \ar@{-}[ur] \ar@{-}[ul] & & {\bullet} \ar@{-}[uu] \\
}
$$

\>LooplessGraphs( ) C

`LooplessGraphs' is a graph category in \YAGS. A graph in this category may 
contain arrows and edges but no loops. The parent of this category is `Graphs'

\beginexample
gap> GraphByWalks([1,1],[1,2],[2,1],[3,2]:GraphCategory:=Graphs);
Graph( Category := Graphs, Order := 3, Size := 4, Adjacencies := 
[ [ 1, 2 ], [ 1 ], [ 2 ] ] )
gap> GraphByWalks([1,1],[1,2],[2,1],[3,2]:GraphCategory:=LooplessGraphs);  
Graph( Category := LooplessGraphs, Order := 3, Size := 3, Adjacencies := 
[ [ 2 ], [ 1 ], [ 2 ] ] )
\endexample



A loop is an arrow that starts and finishes on the same
vertex. 

$$
\xymatrix{
   {\bullet} \ar@(ur,dr)[]
} 
$$

Loopless graphs have no such arrows.

$$
\xymatrix{
   {\bullet} \ar[dr] & & {\bullet} \ar@(l,d)[dl]\\
   & {\bullet} \ar@(r,u)[ur] & 
} 
$$

\>UndirectedGraphs( ) C

`UndirectedGraphs' is a graph category in \YAGS. A graph in this category may 
contain edges and loops, but no arrows. The parent of this category is `Graphs'

\beginexample
gap> GraphByWalks([1,1],[1,2],[2,1],[3,2]:GraphCategory:=Graphs);
Graph( Category := Graphs, Order := 3, Size := 4, Adjacencies := 
[ [ 1, 2 ], [ 1 ], [ 2 ] ] )
gap> GraphByWalks([1,1],[1,2],[2,1],[3,2]:GraphCategory:=UndirectedGraphs);
Graph( Category := UndirectedGraphs, Order := 3, Size := 3, Adjacencies := 
[ [ 1, 2 ], [ 1, 3 ], [ 2 ] ] )
\endexample



Given two vertex $i,j$ in graph $G$ we will say that graph $G$ has an
*edge* $\{i,j\}$ if there is an arrow $(i,j)$ and and arrow $(j,i).$ 

$$
\xymatrix{
   {\bullet} \ar@(ur,dr)[r] & {\bullet} \ar@(dl,ul)[l]
}
\enskip
\equiv 
\enskip
\xymatrix{
   {\bullet} \ar@{-}[r] &  {\bullet}
}
$$

Undirected graphs have no arrows but only edges.

$$
\vcenter{\xymatrix{
   {\bullet} \ar@(ul,dl)[] \ar@(r,d)[dr] & & {\bullet} \ar@(l,d)[dl]\\
   & {\bullet} \ar@(r,u)[ur] \ar@(l,u)[ul] & 
}}
\enskip
\equiv
\hskip .5cm
\vcenter{\xymatrix{
   {\bullet} \ar@(ul,dl){-} \ar@{-}[dr] & & {\bullet} \ar@{-}[dl]\\
   & {\bullet} & 
}}
$$

\>OrientedGraphs( ) C

`OrientedGraphs' is a graph category in \YAGS. A graph in this category may 
contain arrows, but no loops or edges. The parent of this category is `LooplessGraphs'.

\beginexample
gap> GraphByWalks([1,1],[1,2],[2,1],[3,2]:GraphCategory:=Graphs);
Graph( Category := Graphs, Order := 3, Size := 4, Adjacencies := 
[ [ 1, 2 ], [ 1 ], [ 2 ] ] )
gap> GraphByWalks([1,1],[1,2],[2,1],[3,2]:GraphCategory:=OrientedGraphs);
Graph( Category := OrientedGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [  ], [ 2 ] ] )
\endexample



Oriented graphs have no edges but only arrows. 

$$
\xymatrix{
   {\bullet} \ar[dr] & & {\bullet} \ar[ll]\\
   & {\bullet} \ar[ur] & 
} 
$$

\>SimpleGraphs( ) C

`SimpleGraphs' is a graph category in \YAGS. A graph in this category may 
contain edges, but no loops or arrows. The category has two parents: `LooplessGraphs' 
and `UndirectedGraphs'.

\beginexample
gap> GraphByWalks([1,1],[1,2],[2,1],[3,2]:GraphCategory:=Graphs);
Graph( Category := Graphs, Order := 3, Size := 4, Adjacencies := 
[ [ 1, 2 ], [ 1 ], [ 2 ] ] )
gap> GraphByWalks([1,1],[1,2],[2,1],[3,2]:GraphCategory:=SimpleGraphs);  
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
\endexample


$$
\xymatrix{
   & {\bullet} \ar@{-}[dl] \ar@{-}[dr] & & {\bullet} \ar@{-}[dl] \\
   {\bullet} & & {\bullet} \ar@{-}[dr] \\
   & {\bullet} \ar@{-}[ur] \ar@{-}[ul] & & {\bullet} \ar@{-}[uu] \\
}
$$

The following figure shows the relationships among categories.

$$
\pstree[nodesep=5pt]{\Tr{Graphs}}
{
  \pstree{\Tr{Loopless}}
  {
         \Tr{Oriented}
         \Tr[name=S]{Simple Graphs}
  }
  \Tr[name=U]{Undirected}
}
\ncline[nodesep=5pt]{S}{U}
$$
\medskip\nobreak
\centerline{{\bf Figure 2:} Graph Categories}
\medskip

This relationship is important because when a graph is created it is
normalized to the category it belongs. For instance, if we create a
graph such as 
$$
\xymatrix{
   {\bullet} \ar[dr] & & {\bullet} \ar[ll]\\
   & {\bullet} \ar[ur] & 
}
$$
as a simple graph \YAGS\  will normalize the graph as
$$
\xymatrix{
   {\bullet} \ar@{-}[dr] & & {\bullet} \ar@{-}[ll]\\
   & {\bullet} \ar@{-}[ur] & 
}
$$
For further examples see the following section.


\Section{Default Category}

There are several ways to specify the category in which a new graph
will be created. There exists a <DefaultCategory> which tells \YAGS\  to
which category belongs any new graph by default. The <DefaultCategory> can be
changed using the following function.

\>SetDefaultGraphCategory( <C> ) F

Sets the default graphs category to <C>. The default graph
category is used when constructing new graphs when no other graph category 
is indicated. New graphs are always forced to comply with the `TargetGraphCategory', 
so loops may be removed, and arrows may replaced by edges or viceversa, depending on 
the category that the new graph belongs to.

The available graph categories are:  `SimpleGraphs', `OrientedGraphs', 
`UndirectedGraphs', `LooplessGraphs', and `Graphs'.

\beginexample
gap> SetDefaultGraphCategory(Graphs);
gap> GraphByWalks([1,1],[1,2],[2,1],[3,2]);
Graph( Category := Graphs, Order := 3, Size := 4, Adjacencies := 
[ [ 1, 2 ], [ 1 ], [ 2 ] ] )
gap> SetDefaultGraphCategory(LooplessGraphs);
gap> GraphByWalks([1,1],[1,2],[2,1],[3,2]);  
Graph( Category := LooplessGraphs, Order := 3, Size := 3, Adjacencies := 
[ [ 2 ], [ 1 ], [ 2 ] ] )
gap> SetDefaultGraphCategory(UndirectedGraphs);
gap> GraphByWalks([1,1],[1,2],[2,1],[3,2]);    
Graph( Category := UndirectedGraphs, Order := 3, Size := 3, Adjacencies := 
[ [ 1, 2 ], [ 1, 3 ], [ 2 ] ] )
gap> SetDefaultGraphCategory(SimpleGraphs);    
gap> GraphByWalks([1,1],[1,2],[2,1],[3,2]);
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
gap> SetDefaultGraphCategory(OrientedGraphs);
gap> GraphByWalks([1,1],[1,2],[2,1],[3,2]);  
Graph( Category := OrientedGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [  ], [ 2 ] ] )
\endexample



In order to handle graphs with different categories there two
functions available.

\>GraphCategory( [<G>, ... ] ) F

For internal use. Returns the minimal common category to a list of graphs.
If the list of graphs is empty, the default category is returned.

The partial order (by inclusion) among graph categories is as follows: 
%%FIXME: Wrong spacing in the pdf manual.
$$
`SimpleGraphs' \<  `UndirectedGraphs' \< `Graphs',
$$
$$
`OrientedGraphs' \< `LooplessGraphs' \< `Graphs',
$$
$$
`SimpleGraphs' \< `LooplessGraphs' \< `Graphs'
$$
 
\beginexample
gap> g1:=CompleteGraph(2:GraphCategory:=SimpleGraphs);  
Graph( Category := SimpleGraphs, Order := 2, Size := 1, Adjacencies := 
[ [ 2 ], [ 1 ] ] )
gap> g2:=CompleteGraph(2:GraphCategory:=OrientedGraphs);
Graph( Category := OrientedGraphs, Order := 2, Size := 1, Adjacencies := 
[ [ 2 ], [  ] ] )
gap> g3:=CompleteGraph(2:GraphCategory:=UndirectedGraphs);
Graph( Category := UndirectedGraphs, Order := 2, Size := 3, Adjacencies := 
[ [ 1, 2 ], [ 1, 2 ] ] )
gap> GraphCategory([g1,g2,g3]);
<Operation "Graphs">
gap> GraphCategory([g1,g2]);   
<Operation "LooplessGraphs">
gap> GraphCategory([g1,g3]);
<Operation "UndirectedGraphs">
\endexample



\>TargetGraphCategory( [<G>, ... ] ) F

For internal use. Returns the graph category indicated in the <options stack> if any, 
otherwise if the list of graphs provided is not empty, returns the minimal common graph 
category for the graphs in the list, else returns the default graph category.

The partial order (by inclusion) among graph categories is as follows: 
$$`SimpleGraphs' \<  `UndirectedGraphs' \< `Graphs',$$
$$`OrientedGraphs' \< `LooplessGraphs' \< `Graphs'$$  
$$`SimpleGraphs' \< `LooplessGraphs' \< `Graphs'$$
 
This function is internally called by all graph constructing operations in \YAGS\ to decide the 
graph category that the newly constructed graph is going to belong. New graphs are always 
forced to comply with the `TargetGraphCategory', so loops may be removed, and arrows may 
replaced by edges or viceversa, depending on the category that the new graph belongs to.

The <options stack> is a mechanism provided by \GAP\ to pass implicit parameters 
and is used by `TargetGraphCategory' so that the user may indicate the graph 
category she/he wants for the new graph.

\beginexample
gap> SetDefaultGraphCategory(SimpleGraphs);             
gap> g1:=CompleteGraph(2);                              
Graph( Category := SimpleGraphs, Order := 2, Size := 1, Adjacencies := 
[ [ 2 ], [ 1 ] ] )
gap> g2:=CompleteGraph(2:GraphCategory:=OrientedGraphs);
Graph( Category := OrientedGraphs, Order := 2, Size := 1, Adjacencies := 
[ [ 2 ], [  ] ] )
gap> DisjointUnion(g1,g2);
Graph( Category := LooplessGraphs, Order := 4, Size := 3, Adjacencies := 
[ [ 2 ], [ 1 ], [ 4 ], [  ] ] )
gap> DisjointUnion(g1,g2:GraphCategory:=UndirectedGraphs);
Graph( Category := UndirectedGraphs, Order := 4, Size := 2, Adjacencies := 
[ [ 2 ], [ 1 ], [ 4 ], [ 3 ] ] )
\endexample

In the previous examples, `TargetGraphCategory' was called internally exactly once for 
each new graph constructed with the following parameters:

\beginexample
gap> TargetGraphCategory();
<Operation "SimpleGraphs">
gap> TargetGraphCategory(:GraphCategory:=OrientedGraphs);
<Operation "OrientedGraphs">
gap> TargetGraphCategory([g1,g2]);                       
<Operation "LooplessGraphs">
gap> TargetGraphCategory([g1,g2]:GraphCategory:=UndirectedGraphs);
<Operation "UndirectedGraphs">
\endexample



Finally we can test if a single graph belongs to a given category.

\>in( <G>, <C> ) O

Returns `true' if graph <G> belongs to category <C> and `false' otherwise.






