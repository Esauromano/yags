% This file was created automatically from inspecting.msk.
% DO NOT EDIT!
\Chapter{Inspecting Graphs}

\Section{Atributes and properties of graphs}

The following are functions to obtain atributes and properties of
graphs.

\>AdjMatrix( <G> ) A

Returns the adjacency matrix of graph <G>.

\beginexample
gap> AdjMatrix(CycleGraph(4));
[ [ false, true, false, true ], [ true, false, true, false ], 
  [ false, true, false, true ], [ true, false, true, false ] ]
\endexample

--map

\>Order( <G> ) A

Returns the number of vertices, of graph <G>.

\beginexample
gap> Order(Icosahedron);
12
\endexample

--map

\>Size( <G> ) A

Returns the number of edges of graph <G>.

\beginexample
gap> Size(Icosahedron);
30
\endexample

--map

\>VertexNames( <G> ) A

Return the list of names of the vertices of a graph <G>. The vertices of a graph in \YAGS are always 
$\{1,2, \ldots, Order(G)\}$, but depending on how the graph was constructed, its vertices may 
have also some <names>, that help us identify the origin of the vertices. \YAGS will always try 
to store meaninful names for the vertices. For example, in the case of the LineGraph, the vertex 
names of the new graph are the edges of the old graph.

\beginexample
gap> g:=LineGraph(DiamondGraph);          
Graph( Category := SimpleGraphs, Order := 5, Size := 8, Adjacencies := 
[ [ 2, 3, 4 ], [ 1, 3, 4, 5 ], [ 1, 2, 5 ], [ 1, 2, 5 ], [ 2, 3, 4 ] ] )
gap> VertexNames(g);
[ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 2, 3 ], [ 3, 4 ] ]
gap> Edges(DiamondGraph);
[ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 2, 3 ], [ 3, 4 ] ]
\endexample

--map

\>IsCompleteGraph( <G> ) A
\>QtfyIsCompleteGraph( <G> ) P

The attribute form is `true' if graph <G> is complete.
The property form measures how far graph <G> is from being complete.


\>IsLoopless( <G> ) A
\>QtfyIsLoopless( <G> ) P

The attribute form is `true' if graph <G> has no loops.
The property form measures how far graph <G> is from being
loopless, <i.e.> the number of loops in <G>.


\>IsUndirected( <G> ) A
\>QtfyIsUndirected( <G> ) P

The attribute form is `true' if graph <G> has only edges and no arrows.
The property form measures how far graph <G> is from being
undirected, <i.e.> the number of arrows in <G>.


\>IsOriented( <G> ) A
\>QtfyIsOriented( <G> ) P

The attribute form is `true' if graph <G> has only arrows.
The property form measures how far graph <G> is from being
oriented, <i.e.> the number of edges in <G>.


\>CliqueNumber( <G> ) A

Returns the order, $\omega(G)$, of a maximum clique of <G>. 

\beginexample
gap> g:=SunGraph(4);
Graph( Category := SimpleGraphs, Order := 8, Size := 14, Adjacencies := 
[ [ 2, 8 ], [ 1, 3, 4, 6, 8 ], [ 2, 4 ], [ 2, 3, 5, 6, 8 ], [ 4, 6 ], 
  [ 2, 4, 5, 7, 8 ], [ 6, 8 ], [ 1, 2, 4, 6, 7 ] ] )
gap> CliqueNumber(g);
4
\endexample

--map

\>Cliques( <G> ) A
\>Cliques( <G>, <m> ) O

Returns the set of all (maximal) cliques of a graph <G>. A clique is a maximal complete subgraph.
Here, we use the Bron-Kerbosch algorithm \cite{BK73}.
 
In the second form, It stops computing cliques after <m> of them have been found.

\beginexample
gap> Cliques(Octahedron);  
[ [ 1, 3, 5 ], [ 1, 3, 6 ], [ 1, 4, 5 ], [ 1, 4, 6 ], [ 2, 3, 5 ], 
  [ 2, 3, 6 ], [ 2, 4, 5 ], [ 2, 4, 6 ] ]
gap> Cliques(Octahedron,4);
[ [ 1, 3, 5 ], [ 1, 3, 6 ], [ 1, 4, 5 ], [ 1, 4, 6 ] ]
\endexample

--map

\>IsCliqueHelly( <G> ) A

Returns `true' if the set of (maximal) cliques <G> satisfy
the <Helly> property.

The Helly property is defined as follows:

A non-empty family $\Cal{F}$ of non-empty sets satisfies the Helly property if
every pairwise intersecting subfamily of $\Cal{F}$ has a non-empty total intersection.

Here we use the Dragan-Szwarcfiter characterization \cite{Dra89,Szw97} to compute the Helly property.

\beginexample
gap> g:=SunGraph(3);
Graph( Category := SimpleGraphs, Order := 6, Size := 9, Adjacencies :=
[ [ 2, 6 ], [ 1, 3, 4, 6 ], [ 2, 4 ], [ 2, 3, 5, 6 ], [ 4, 6 ],
  [ 1, 2, 4, 5 ] ] )
gap> IsCliqueHelly(g);
false
\endexample

--map


\Section{Information about graphs}

The following functions give information regarding graphs.

\>IsSimple( <G> ) O

Returns `true' if the graph <G> is simple regardless of its category.


\>QtfyIsSimple( <G> ) O

Returns how far is graph <G> from being simple.


\>Adjacency( <G>, <v> ) O

Returns the adjacency list of vertex <v> in <G>.

\beginexample
gap> g:=PathGraph(3);
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
gap> Adjacency(g,1);           
[ 2 ]
gap> Adjacency(g,2);
[ 1, 3 ]
\endexample

--map

\>Adjacencies( <G> ) O

Returns the adjacency lists of graph <G>.

\beginexample
gap> g:=PathGraph(3);
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
gap> Adjacencies(g);  
[ [ 2 ], [ 1, 3 ], [ 2 ] ]
\endexample

--map

\>VertexDegree( <G>, <v> ) O

Returns the degree of vertex <v> in Graph <G>. 

\beginexample
gap> g:=PathGraph(3);
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
gap> VertexDegree(g,1);
1
gap> VertexDegree(g,2);
2
\endexample

--map

\>VertexDegrees( <G> ) O

Returns the list of degrees of the vertices in graph <G>.

\beginexample
gap> g:=GemGraph;
Graph( Category := SimpleGraphs, Order := 5, Size := 7, Adjacencies := 
[ [ 2, 3, 4, 5 ], [ 1, 3 ], [ 1, 2, 4 ], [ 1, 3, 5 ], [ 1, 4 ] ] )
gap> VertexDegrees(g);
[ 4, 2, 3, 3, 2 ]
\endexample

--map

\>Edges( <G> ) O

Returns the list of edges of graph <G>.  

\beginexample
gap> Edges(CompleteGraph(4));
[ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 2, 3 ], [ 2, 4 ], [ 3, 4 ] ]
\endexample

--map

\>CompletesOfGivenOrder( <G>, <o> ) O

This operation finds all complete subgraphs of order <o> in graph <G>.

\beginexample
gap> G:=SunGraph(4);
Graph( Category := SimpleGraphs, Order := 8, Size := 14, Adjacencies :=
[ [ 2, 8 ], [ 1, 3, 4, 6, 8 ], [ 2, 4 ], [ 2, 3, 5, 6, 8 ], [ 4, 6 ],
  [ 2, 4, 5, 7, 8 ], [ 6, 8 ], [ 1, 2, 4, 6, 7 ] ] )
gap> CompletesOfGivenOrder(G,3);
[ [ 1, 2, 8 ], [ 2, 3, 4 ], [ 2, 4, 6 ], [ 2, 4, 8 ], [ 2, 6, 8 ],
  [ 4, 5, 6 ], [ 4, 6, 8 ], [ 6, 7, 8 ] ]
gap> CompletesOfGivenOrder(G,4);
[ [ 2, 4, 6, 8 ] ]
\endexample

--map


\Section{Distances}

These are functions that measure distances between graphs.

\>Distance( <G>, <x>, <y> ) O

Returns the minimal number of edges that connect vertices <x> and
<y>. $$ d_G(x,y) $$

\beginexample
gap> G:=CycleGraph(5);
Graph( Category := SimpleGraphs, Order := 5, Size := 5, Adjacencies :=
[ [ 2, 5 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 1, 4 ] ] )
gap> Distance(G,1,3);
2
\endexample



\>DistanceMatrix( <G> ) A

Returns the matrix of distances for all vertices in <G>. The
matrix is asymetric if the graphic is directed. An entry in the
matrix of $\infty$ means there is no path between the vertices. 
Floyd's algorithm is used to compute the matrix.

\beginexample
gap> G:=CycleGraph(5);
Graph( Category := SimpleGraphs, Order := 5, Size := 5, Adjacencies :=
[ [ 2, 5 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 1, 4 ] ] )
gap> DistanceMatrix(G);
[ [ 0, 1, 2, 2, 1 ], [ 1, 0, 1, 2, 2 ], [ 2, 1, 0, 1, 2 ], [ 2, 2, 1, 0, 1 ],
  [ 1, 2, 2, 1, 0 ] ]
\endexample



\>Diameter( <G> ) A

The diameter of a graph <G> is the maximum distance for any two
vertices in <G>. $$ \max \{ d_G(x,y) | x,y \in V(G) \} $$

\beginexample
gap> G:=CycleGraph(5);
Graph( Category := SimpleGraphs, Order := 5, Size := 5, Adjacencies :=
[ [ 2, 5 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 1, 4 ] ] )
gap> Diameter(G);
2
\endexample



\>Excentricity( <G>, <x> ) F

Returns the distance from a vertex <x> in graph <G> to the
furthest away vertex in <G>. $$ \max \{ d_G(x,y) | y \in V(G) \} $$

\beginexample
gap> G:=CycleGraph(5);
Graph( Category := SimpleGraphs, Order := 5, Size := 5, Adjacencies :=
[ [ 2, 5 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 1, 4 ] ] )
gap> Excentricity(G,3);
2
\endexample



\>Radius( <G> ) A

Returns the minimal excentricity among the vertices of graph
<G>. $$ \min \{ {Excentricity}(G,x) | x \in V(G) \} $$ 

\beginexample
gap> G:=CycleGraph(5);
Graph( Category := SimpleGraphs, Order := 5, Size := 5, Adjacencies :=
[ [ 2, 5 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 1, 4 ] ] )
gap> Radius(G);
2
\endexample



\>Distances( <G>, <A>, <B> ) O

Given two subsets of vertices <A>, <B> of graph <G> returns the
list of distances for every pair in the cartesian product of <A>
and <B>. $$ [ d_G(x,y) | (x,y) \in A \times B ] $$ 

\beginexample
gap> G:=CycleGraph(5);
Graph( Category := SimpleGraphs, Order := 5, Size := 5, Adjacencies :=
[ [ 2, 5 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 1, 4 ] ] )
gap> Distances(G, [1,3], [2,4]);
[ 1, 2, 1, 1 ]
\endexample



\>DistanceSet( <G>, <A>, <B> ) O

Given two subsets of vertices <A>, <B> of graph <G> returns the
set of distances for every pair in the cartesian product of <A>
and <B>. $$ \{ d_G(x,y) | (x,y) \in A \times B \} $$ 

\beginexample
gap> G:=CycleGraph(5);
Graph( Category := SimpleGraphs, Order := 5, Size := 5, Adjacencies :=
[ [ 2, 5 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 1, 4 ] ] )
gap> DistanceSet(G, [1,3], [2,4]);
[ 1, 2 ]
\endexample



\>DistanceGraph( <G>, <D> ) O

Given a graph <G> and list of Distances <D> returns the graph
constructed using the vertices of <G> where two vertices are
adjacent iff the distance between them is in the list <D>.

\beginexample
gap> G:=CycleGraph(5);
Graph( Category := SimpleGraphs, Order := 5, Size := 5, Adjacencies :=
[ [ 2, 5 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 1, 4 ] ] )
gap> DistanceGraph(G, [2]);
Graph( Category := SimpleGraphs, Order := 5, Size := 5, Adjacencies :=
[ [ 3, 4 ], [ 4, 5 ], [ 1, 5 ], [ 1, 2 ], [ 2, 3 ] ] )
\endexample



\>PowerGraph( <G>, <e> ) O

Returns the Distance graph of <G> using as a list of distances
[0,1,...,<e>]. Note that the distance 0 is used only if <G> has
loops. $$ G^n = {DistanceGraph}(G,[0,1,\dots,e]) $$ 

\beginexample
gap> G:=SunGraph(4);
Graph( Category := SimpleGraphs, Order := 8, Size := 14, Adjacencies :=
[ [ 2, 8 ], [ 1, 3, 4, 6, 8 ], [ 2, 4 ], [ 2, 3, 5, 6, 8 ], [ 4, 6 ],
  [ 2, 4, 5, 7, 8 ], [ 6, 8 ], [ 1, 2, 4, 6, 7 ] ] )
gap> PowerGraph(G,3);
Graph( Category := SimpleGraphs, Order := 8, Size := 28, Adjacencies :=
[ [ 2, 3, 4, 5, 6, 7, 8 ], [ 1, 3, 4, 5, 6, 7, 8 ], [ 1, 2, 4, 5, 6, 7, 8 ],
  [ 1, 2, 3, 5, 6, 7, 8 ], [ 1, 2, 3, 4, 6, 7, 8 ], [ 1, 2, 3, 4, 5, 7, 8 ],
  [ 1, 2, 3, 4, 5, 6, 8 ], [ 1, 2, 3, 4, 5, 6, 7 ] ] )
\endexample



