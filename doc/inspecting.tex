% This file was created automatically from inspecting.msk.
% DO NOT EDIT!
\Chapter{Inspecting Graphs}

\Section{Atributes and properties of graphs}

The following are functions to obtain atributes and properties of
graphs.

\>AdjMatrix( <G> ) A

Returns the adjacency matrix of graph <G>.

\beginexample
gap> AdjMatrix(CycleGraph(4));
[ [ false, true, false, true ], [ true, false, true, false ], 
  [ false, true, false, true ], [ true, false, true, false ] ]
\endexample

--map

\>Order( <G> ) A

Returns the number of vertices, of graph <G>.

\beginexample
gap> Order(Icosahedron);
12
\endexample

--map

\>Size( <G> ) A

Returns the number of edges of graph <G>.

\beginexample
gap> Size(Icosahedron);
30
\endexample

--map

\>VertexNames( <G> ) A

Return the list of names of the vertices of <G>. The vertices of a graph in \YAGS\ are always 
$\{1,2, \ldots, Order(G)\}$, but depending on how the graph was constructed, its vertices may 
have also some <names>, that help us identify the origin of the vertices. \YAGS\ will always try 
to store meaninful names for the vertices. For example, in the case of the LineGraph, the vertex 
names of the new graph are the edges of the old graph.

\beginexample
gap> g:=LineGraph(DiamondGraph);          
Graph( Category := SimpleGraphs, Order := 5, Size := 8, Adjacencies := 
[ [ 2, 3, 4 ], [ 1, 3, 4, 5 ], [ 1, 2, 5 ], [ 1, 2, 5 ], [ 2, 3, 4 ] ] )
gap> VertexNames(g);
[ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 2, 3 ], [ 3, 4 ] ]
gap> Edges(DiamondGraph);
[ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 2, 3 ], [ 3, 4 ] ]
\endexample

--map

\>IsCompleteGraph( <G> ) P

Returns `true' if graph <G> is a complete graph, `false' otherwise.
In a complete graph every pair of vertices is an edge.

--map

\>IsLoopless( <G> ) P

Returns `true' if graph <G> have no loops, `false' otherwise. Loops are edges 
from a vertex to itself.

--map

\>IsUndirected( <G> ) P

Returns `true' if graph <G> is an undirected graph, `false' otherwise.
Regardless of the categories that <G> belongs to, <G> is undirected if 
whenever `[x,y]' is an edge of <G>, `[y,x]' is also an egde of <G>.

--map

\>IsOriented( <G> ) P
\>QtfyIsOriented( <G> ) A

Returns `true' if graph <G> is an oriented graph, `false' otherwise.
Regardless of the categories that <G> belongs to, <G> is oriented if 
whenever `[x,y]' is an edge of <G>, `[y,x]' is not.

--map

\>CliqueNumber( <G> ) A

Returns the order, $\omega(G)$, of a maximum clique of <G>. 

\beginexample
gap> g:=SunGraph(4);
Graph( Category := SimpleGraphs, Order := 8, Size := 14, Adjacencies := 
[ [ 2, 8 ], [ 1, 3, 4, 6, 8 ], [ 2, 4 ], [ 2, 3, 5, 6, 8 ], [ 4, 6 ], 
  [ 2, 4, 5, 7, 8 ], [ 6, 8 ], [ 1, 2, 4, 6, 7 ] ] )
gap> CliqueNumber(g);
4
\endexample

--map

\>Cliques( <G> ) A
\>Cliques( <G>, <m> ) O

Returns the set of all (maximal) cliques of a graph <G>. A clique is a maximal complete subgraph.
Here, we use the Bron-Kerbosch algorithm \cite{BK73}.
 
In the second form, It stops computing cliques after <m> of them have been found.

\beginexample
gap> Cliques(Octahedron);  
[ [ 1, 3, 5 ], [ 1, 3, 6 ], [ 1, 4, 5 ], [ 1, 4, 6 ], [ 2, 3, 5 ], 
  [ 2, 3, 6 ], [ 2, 4, 5 ], [ 2, 4, 6 ] ]
gap> Cliques(Octahedron,4);
[ [ 1, 3, 5 ], [ 1, 3, 6 ], [ 1, 4, 5 ], [ 1, 4, 6 ] ]
\endexample

--map

\>IsCliqueHelly( <G> ) A

Returns `true' if the set of (maximal) cliques <G> satisfy
the <Helly> property.

The Helly property is defined as follows:

A non-empty family $\Cal{F}$ of non-empty sets satisfies the Helly property if
every pairwise intersecting subfamily of $\Cal{F}$ has a non-empty total intersection.

Here we use the Dragan-Szwarcfiter characterization \cite{Dra89,Szw97} to compute the Helly property.

\beginexample
gap> g:=SunGraph(3);
Graph( Category := SimpleGraphs, Order := 6, Size := 9, Adjacencies :=
[ [ 2, 6 ], [ 1, 3, 4, 6 ], [ 2, 4 ], [ 2, 3, 5, 6 ], [ 4, 6 ],
  [ 1, 2, 4, 5 ] ] )
gap> IsCliqueHelly(g);
false
\endexample

--map


\Section{Information about graphs}

The following functions give information regarding graphs.

\>IsSimple( <G> ) O

Returns `true' if graph <G> is a simple graph, `false' otherwise.
Regardless of the categories that <G> belongs to, <G> is simple if and only if 
<G> is undirected and loopless.

Returns `true' if the graph <G> is simple regardless of its category.

--map

\>QtfyIsSimple( <G> ) O

Returns how far is graph <G> from being simple.


\>Adjacency( <G>, <v> ) O

Returns the adjacency list of vertex <v> in <G>.

\beginexample
gap> g:=PathGraph(3);
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
gap> Adjacency(g,1);           
[ 2 ]
gap> Adjacency(g,2);
[ 1, 3 ]
\endexample

--map

\>Adjacencies( <G> ) O

Returns the adjacency lists of graph <G>.

\beginexample
gap> g:=PathGraph(3);
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
gap> Adjacencies(g);  
[ [ 2 ], [ 1, 3 ], [ 2 ] ]
\endexample

--map

\>VertexDegree( <G>, <v> ) O

Returns the degree of vertex <v> in Graph <G>. 

\beginexample
gap> g:=PathGraph(3);
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
gap> VertexDegree(g,1);
1
gap> VertexDegree(g,2);
2
\endexample

--map

\>VertexDegrees( <G> ) O

Returns the list of degrees of the vertices in graph <G>.

\beginexample
gap> g:=GemGraph;
Graph( Category := SimpleGraphs, Order := 5, Size := 7, Adjacencies := 
[ [ 2, 3, 4, 5 ], [ 1, 3 ], [ 1, 2, 4 ], [ 1, 3, 5 ], [ 1, 4 ] ] )
gap> VertexDegrees(g);
[ 4, 2, 3, 3, 2 ]
\endexample

--map

\>Edges( <G> ) O

Returns the list of edges of graph <G>.  

\beginexample
gap> Edges(CompleteGraph(4));
[ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 2, 3 ], [ 2, 4 ], [ 3, 4 ] ]
\endexample

--map

\>CompletesOfGivenOrder( <G>, <o> ) O

This operation finds all complete subgraphs of order <o> in graph <G>.

\beginexample
gap> g:=SunGraph(4);
Graph( Category := SimpleGraphs, Order := 8, Size := 14, Adjacencies :=
[ [ 2, 8 ], [ 1, 3, 4, 6, 8 ], [ 2, 4 ], [ 2, 3, 5, 6, 8 ], [ 4, 6 ],
  [ 2, 4, 5, 7, 8 ], [ 6, 8 ], [ 1, 2, 4, 6, 7 ] ] )
gap> CompletesOfGivenOrder(g,3);
[ [ 1, 2, 8 ], [ 2, 3, 4 ], [ 2, 4, 6 ], [ 2, 4, 8 ], [ 2, 6, 8 ],
  [ 4, 5, 6 ], [ 4, 6, 8 ], [ 6, 7, 8 ] ]
gap> CompletesOfGivenOrder(g,4);
[ [ 2, 4, 6, 8 ] ]
\endexample

--map


\Section{Distances}

These are functions that measure distances between graphs.

\>Distance( <G>, <x>, <y> ) O

Returns the length of a minimal path connecting <x> to <y> in <G>.

\beginexample
gap> Distance(CycleGraph(5),1,3);
2
gap> Distance(CycleGraph(5),1,5);
1
\endexample

--map


\>DistanceMatrix( <G> ) A

Returns the distance matrix <D> of a graph <G>: D[x][y] is the distance in <G> 
from vertex <x> to vertex <y>. The matrix may be asymmetric if the graph is not simple. 
An infinite entry in the matrix means that there is no path between the vertices. 
Floyd's algorithm is used to compute the matrix.

\beginexample
gap> g:=PathGraph(4);
Graph( Category := SimpleGraphs, Order := 4, Size := 3, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2, 4 ], [ 3 ] ] )
gap> Display(DistanceMatrix(g));
[ [  0,  1,  2,  3 ],
  [  1,  0,  1,  2 ],
  [  2,  1,  0,  1 ],
  [  3,  2,  1,  0 ] ]
gap> g:=PathGraph(4:GraphCategory:=OrientedGraphs);
Graph( Category := OrientedGraphs, Order := 4, Size := 3, Adjacencies := 
[ [ 2 ], [ 3 ], [ 4 ], [  ] ] )
gap> Display(DistanceMatrix(g));                   
[ [         0,         1,         2,         3 ],
  [  infinity,         0,         1,         2 ],
  [  infinity,  infinity,         0,         1 ],
  [  infinity,  infinity,  infinity,         0 ] ]
\endexample

--map


\>Diameter( <G> ) A

Returns the maximum among the distances between pairs of
vertices of <G>.

\beginexample
gap> g:=CycleGraph(5);
Graph( Category := SimpleGraphs, Order := 5, Size := 5, Adjacencies :=
[ [ 2, 5 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 1, 4 ] ] )
gap> Diameter(g);
2
\endexample

--map


\>Excentricity( <G>, <x> ) F

Returns the distance from a vertex <x> in graph <G> to its
most distant vertex in <G>.

\beginexample
gap> g:=PathGraph(5);
Graph( Category := SimpleGraphs, Order := 5, Size := 4, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 4 ] ] )
gap> Excentricity(g,1);           
4
gap> Excentricity(g,3);
2
\endexample

--map


\>Radius( <G> ) A

Returns the minimal excentricity among the vertices of graph <G>.

\beginexample
gap> Radius(PathGraph(5)); 
2
\endexample

--map


\>Distances( <G>, <A>, <B> ) O

Given two lists of vertices <A>, <B> of a graph <G>, `Distances' returns the
list of distances for every pair in the cartesian product of <A>
and <B>. The order of the vertices in lists <A> and <B> affects the order
of the list of distances returned.

\beginexample
gap> g:=CycleGraph(5);;
gap> Distances(g, [1,3], [2,4]);
[ 1, 2, 1, 1 ]
gap> Distances(g, [3,1], [2,4]);
[ 1, 1, 1, 2 ]
\endexample

--map


\>DistanceSet( <G>, <A>, <B> ) O

Given two subsets of vertices <A>, <B> of a graph <G>, `DistanceSet' returns the
set of distances for every pair in the cartesian product of <A> and <B>.  

\beginexample
gap> g:=CycleGraph(5);;         
gap> DistanceSet(g, [1,3], [2,4]);
[ 1, 2 ]
\endexample

--map


\>DistanceGraph( <G>, <D> ) O

Given a graph <G> and list of distances <D>, `DistanceGraph' returns the new graph
constructed on the vertices of <G> where two vertices are
adjacent iff the distance (in <G>) between them belongs to the list <D>.

\beginexample
gap> g:=CycleGraph(5);            
Graph( Category := SimpleGraphs, Order := 5, Size := 5, Adjacencies := 
[ [ 2, 5 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 1, 4 ] ] )
gap> DistanceGraph(g,[2]);
Graph( Category := SimpleGraphs, Order := 5, Size := 5, Adjacencies := 
[ [ 3, 4 ], [ 4, 5 ], [ 1, 5 ], [ 1, 2 ], [ 2, 3 ] ] )
gap> DistanceGraph(g,[1,2]);
Graph( Category := SimpleGraphs, Order := 5, Size := 10, Adjacencies := 
[ [ 2, 3, 4, 5 ], [ 1, 3, 4, 5 ], [ 1, 2, 4, 5 ], [ 1, 2, 3, 5 ], 
  [ 1, 2, 3, 4 ] ] )
\endexample

--map


\>PowerGraph( <G>, <e> ) O

Returns the `DistanceGraph' of <G> using `[0, 1, ..., <e>]' as the list of distances. 
Note that the distance `0' in the list produces loops in the new graph only when the `TargetGraphCategory'
admits loops.

\beginexample
gap> g:=PathGraph(5);
Graph( Category := SimpleGraphs, Order := 5, Size := 4, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 4 ] ] )
gap> PowerGraph(g,1);                      
Graph( Category := SimpleGraphs, Order := 5, Size := 4, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 4 ] ] )
gap> PowerGraph(g,1:GraphCategory:=Graphs);
Graph( Category := Graphs, Order := 5, Size := 13, Adjacencies := 
[ [ 1, 2 ], [ 1, 2, 3 ], [ 2, 3, 4 ], [ 3, 4, 5 ], [ 4, 5 ] ] )
\endexample

--map


