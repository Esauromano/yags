% This file was created automatically from inspecting.msk.
% DO NOT EDIT!
\Chapter{Inspecting Graphs}

\Section{Atributes and properties of graphs}

The following are functions to obtain atributes and properties of
graphs.

\>AdjMatrix( <G> ) A

Returns the adjacency matrix of graph <G>.

\beginexample
gap> AdjMatrix(CycleGraph(4));
[ [ false, true, false, true ], [ true, false, true, false ], 
  [ false, true, false, true ], [ true, false, true, false ] ]
\endexample

--map

\>Order( <G> ) A

Returns the number of vertices, of graph <G>.

\beginexample
gap> Order(Icosahedron);
12
\endexample

--map

\>Size( <G> ) A

Returns the number of edges of graph <G>.

\beginexample
gap> Size(Icosahedron);
30
\endexample

--map

\>VertexNames( <G> ) A

Return the list of names of the vertices of a graph <G>. The vertices of a graph in \YAGS are always 
$\{1,2, \ldots, Order(G)\}$, but depending on how the graph was constructed, its vertices may 
have also some <names>, that help us identify the origin of the vertices. \YAGS will always try 
to store meaninful names for the vertices. For example, in the case of the LineGraph, the vertex 
names of the new graph are the edges of the old graph.

\beginexample
gap> g:=LineGraph(DiamondGraph);          
Graph( Category := SimpleGraphs, Order := 5, Size := 8, Adjacencies := 
[ [ 2, 3, 4 ], [ 1, 3, 4, 5 ], [ 1, 2, 5 ], [ 1, 2, 5 ], [ 2, 3, 4 ] ] )
gap> VertexNames(g);
[ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 2, 3 ], [ 3, 4 ] ]
gap> Edges(DiamondGraph);
[ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 2, 3 ], [ 3, 4 ] ]
\endexample

--map

\>IsCompleteGraph( <G> ) A
\>QtfyIsCompleteGraph( <G> ) P

The attribute form is `true' if graph <G> is complete.
The property form measures how far graph <G> is from being complete.


\>IsLoopless( <G> ) A
\>QtfyIsLoopless( <G> ) P

The attribute form is `true' if graph <G> has no loops.
The property form measures how far graph <G> is from being
loopless, <i.e.> the number of loops in <G>.


\>IsUndirected( <G> ) A
\>QtfyIsUndirected( <G> ) P

The attribute form is `true' if graph <G> has only edges and no arrows.
The property form measures how far graph <G> is from being
undirected, <i.e.> the number of arrows in <G>.


\>IsOriented( <G> ) A
\>QtfyIsOriented( <G> ) P

The attribute form is `true' if graph <G> has only arrows.
The property form measures how far graph <G> is from being
oriented, <i.e.> the number of edges in <G>.


\>CliqueNumber( <G> ) A

The order of the largest clique in <G>, $\omega(G)$. 

\beginexample
gap> G:=SunGraph(4);
Graph( Category := SimpleGraphs, Order := 8, Size := 14, Adjacencies :=
[ [ 2, 8 ], [ 1, 3, 4, 6, 8 ], [ 2, 4 ], [ 2, 3, 5, 6, 8 ], [ 4, 6 ],
  [ 2, 4, 5, 7, 8 ], [ 6, 8 ], [ 1, 2, 4, 6, 7 ] ] )
gap> CliqueNumber(G);
4
\endexample


\>Cliques( <G> ) A
\>Cliques( <G>, <m> ) O

The set of all cliques in graph <G> using the Bron-Kerbosch algorithm.
The additional parameter <m> stops the operation when a maximum of
<m> cliques have been found.  

Each clique is represented by the set of vertices in <G> that
belong to the clique. A set is represented as a list.

\beginexample
gap> G:=SunGraph(4);
Graph( Category := SimpleGraphs, Order := 8, Size := 14, Adjacencies :=
[ [ 2, 8 ], [ 1, 3, 4, 6, 8 ], [ 2, 4 ], [ 2, 3, 5, 6, 8 ], [ 4, 6 ],
  [ 2, 4, 5, 7, 8 ], [ 6, 8 ], [ 1, 2, 4, 6, 7 ] ] )
gap> Cliques(G);
[ [ 2, 4, 6, 8 ], [ 2, 4, 3 ], [ 2, 1, 8 ], [ 5, 4, 6 ], [ 7, 6, 8 ] ]
\endexample


\>IsCliqueHelly( <G> ) A
\>QtfyIsCliqueHelly( <G> ) P

The attribute form is `true' if all cliques of graph <G> satisfy
the <Helly> property.
The property form measures how far graph <G> is from being
cliquehelly, <i.e.> the number of non-Helly cliques in <G>.

The Helly property is defined as follows:

A family $\Cal{F}$ of sets satisfies the Helly property if
$$\eqalign{\forall \Cal{X} \subseteq& \Cal{F} \cr
\forall x_1,x_2 \in& \Cal{X} \cr
x_1 \cap x_2 \neq \phi \Rightarrow& \bigcap \Cal{X} \neq \phi}$$

The algorithm used to compute the Helly property is by Jayme

\beginexample
gap> G:=SunGraph(3);
Graph( Category := SimpleGraphs, Order := 6, Size := 9, Adjacencies :=
[ [ 2, 6 ], [ 1, 3, 4, 6 ], [ 2, 4 ], [ 2, 3, 5, 6 ], [ 4, 6 ],
  [ 1, 2, 4, 5 ] ] )
gap> IsCliqueHelly(G);
false
gap> QtfyIsCliqueHelly(G);
1
\endexample



\Section{Information about graphs}

The following functions give information regarding graphs.

\>IsSimple( <G> ) O

Returns `true' if the graph <G> is simple regardless of its category.


\>QtfyIsSimple( <G> ) O

Returns how far is graph <G> from being simple.


\>Adjacency( <G>, <v> ) O

Returns the adjacency list of vertex <v> in <G>.

\beginexample
gap> g:=PathGraph(3);
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
gap> Adjacency(g,1);           
[ 2 ]
gap> Adjacency(g,2);
[ 1, 3 ]
\endexample

--map

\>Adjacencies( <G> ) O

Returns the adjacency lists of graph <G>.

\beginexample
gap> g:=PathGraph(3);
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
gap> Adjacencies(g);  
[ [ 2 ], [ 1, 3 ], [ 2 ] ]
\endexample

--map

\>VertexDegree( <G>, <v> ) O

Returns the degree of vertex <v> in Graph <G>. 

\beginexample
gap> g:=PathGraph(3);
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
gap> VertexDegree(g,1);
1
gap> VertexDegree(g,2);
2
\endexample

--map

\>VertexDegrees( <G> ) O

Returns the list of degrees of the vertices in graph <G>.

\beginexample
gap> g:=GemGraph;
Graph( Category := SimpleGraphs, Order := 5, Size := 7, Adjacencies := 
[ [ 2, 3, 4, 5 ], [ 1, 3 ], [ 1, 2, 4 ], [ 1, 3, 5 ], [ 1, 4 ] ] )
gap> VertexDegrees(g);
[ 4, 2, 3, 3, 2 ]
\endexample

--map

\>Edges( <G> ) O

Returns the list of edges of graph <G>.  

\beginexample
gap> Edges(CompleteGraph(4));
[ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 2, 3 ], [ 2, 4 ], [ 3, 4 ] ]
\endexample

--map

\>CompletesOfGivenOrder( <G>, <o> ) O

This operation finds all complete graphs of order <o> in graph <G>.

\beginexample
gap> G:=SunGraph(4);
Graph( Category := SimpleGraphs, Order := 8, Size := 14, Adjacencies :=
[ [ 2, 8 ], [ 1, 3, 4, 6, 8 ], [ 2, 4 ], [ 2, 3, 5, 6, 8 ], [ 4, 6 ],
  [ 2, 4, 5, 7, 8 ], [ 6, 8 ], [ 1, 2, 4, 6, 7 ] ] )
gap> CompletesOfGivenOrder(G,3);
[ [ 1, 2, 8 ], [ 2, 3, 4 ], [ 2, 4, 6 ], [ 2, 4, 8 ], [ 2, 6, 8 ],
  [ 4, 5, 6 ], [ 4, 6, 8 ], [ 6, 7, 8 ] ]
gap> CompletesOfGivenOrder(G,4);
[ [ 2, 4, 6, 8 ] ]
\endexample



\Section{Distances}

These are functions that measure distances between graphs.

\>Distance( <G>, <x>, <y> ) O

Returns the minimal number of edges that connect vertices <x> and
<y>. $$ d_G(x,y) $$

\beginexample
gap> G:=CycleGraph(5);
Graph( Category := SimpleGraphs, Order := 5, Size := 5, Adjacencies :=
[ [ 2, 5 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 1, 4 ] ] )
gap> Distance(G,1,3);
2
\endexample



\>DistanceMatrix( <G> ) A

Returns the matrix of distances for all vertices in <G>. The
matrix is asymetric if the graphic is directed. An entry in the
matrix of $\infty$ means there is no path between the vertices. 
Floyd's algorithm is used to compute the matrix.

\beginexample
gap> G:=CycleGraph(5);
Graph( Category := SimpleGraphs, Order := 5, Size := 5, Adjacencies :=
[ [ 2, 5 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 1, 4 ] ] )
gap> DistanceMatrix(G);
[ [ 0, 1, 2, 2, 1 ], [ 1, 0, 1, 2, 2 ], [ 2, 1, 0, 1, 2 ], [ 2, 2, 1, 0, 1 ],
  [ 1, 2, 2, 1, 0 ] ]
\endexample



\>Diameter( <G> ) A

The diameter of a graph <G> is the maximum distance for any two
vertices in <G>. $$ \max \{ d_G(x,y) | x,y \in V(G) \} $$

\beginexample
gap> G:=CycleGraph(5);
Graph( Category := SimpleGraphs, Order := 5, Size := 5, Adjacencies :=
[ [ 2, 5 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 1, 4 ] ] )
gap> Diameter(G);
2
\endexample



\>Excentricity( <G>, <x> ) F

Returns the distance from a vertex <x> in graph <G> to the
furthest away vertex in <G>. $$ \max \{ d_G(x,y) | y \in V(G) \} $$

\beginexample
gap> G:=CycleGraph(5);
Graph( Category := SimpleGraphs, Order := 5, Size := 5, Adjacencies :=
[ [ 2, 5 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 1, 4 ] ] )
gap> Excentricity(G,3);
2
\endexample



\>Radius( <G> ) A

Returns the minimal excentricity among the vertices of graph
<G>. $$ \min \{ {Excentricity}(G,x) | x \in V(G) \} $$ 

\beginexample
gap> G:=CycleGraph(5);
Graph( Category := SimpleGraphs, Order := 5, Size := 5, Adjacencies :=
[ [ 2, 5 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 1, 4 ] ] )
gap> Radius(G);
2
\endexample



\>Distances( <G>, <A>, <B> ) O

Given two subsets of vertices <A>, <B> of graph <G> returns the
list of distances for every pair in the cartesian product of <A>
and <B>. $$ [ d_G(x,y) | (x,y) \in A \times B ] $$ 

\beginexample
gap> G:=CycleGraph(5);
Graph( Category := SimpleGraphs, Order := 5, Size := 5, Adjacencies :=
[ [ 2, 5 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 1, 4 ] ] )
gap> Distances(G, [1,3], [2,4]);
[ 1, 2, 1, 1 ]
\endexample



\>DistanceSet( <G>, <A>, <B> ) O

Given two subsets of vertices <A>, <B> of graph <G> returns the
set of distances for every pair in the cartesian product of <A>
and <B>. $$ \{ d_G(x,y) | (x,y) \in A \times B \} $$ 

\beginexample
gap> G:=CycleGraph(5);
Graph( Category := SimpleGraphs, Order := 5, Size := 5, Adjacencies :=
[ [ 2, 5 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 1, 4 ] ] )
gap> DistanceSet(G, [1,3], [2,4]);
[ 1, 2 ]
\endexample



\>DistanceGraph( <G>, <D> ) O

Given a graph <G> and list of Distances <D> returns the graph
constructed using the vertices of <G> where two vertices are
adjacent iff the distance between them is in the list <D>.

\beginexample
gap> G:=CycleGraph(5);
Graph( Category := SimpleGraphs, Order := 5, Size := 5, Adjacencies :=
[ [ 2, 5 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 1, 4 ] ] )
gap> DistanceGraph(G, [2]);
Graph( Category := SimpleGraphs, Order := 5, Size := 5, Adjacencies :=
[ [ 3, 4 ], [ 4, 5 ], [ 1, 5 ], [ 1, 2 ], [ 2, 3 ] ] )
\endexample



\>PowerGraph( <G>, <e> ) O

Returns the Distance graph of <G> using as a list of distances
[0,1,...,<e>]. Note that the distance 0 is used only if <G> has
loops. $$ G^n = {DistanceGraph}(G,[0,1,\dots,e]) $$ 

\beginexample
gap> G:=SunGraph(4);
Graph( Category := SimpleGraphs, Order := 8, Size := 14, Adjacencies :=
[ [ 2, 8 ], [ 1, 3, 4, 6, 8 ], [ 2, 4 ], [ 2, 3, 5, 6, 8 ], [ 4, 6 ],
  [ 2, 4, 5, 7, 8 ], [ 6, 8 ], [ 1, 2, 4, 6, 7 ] ] )
gap> PowerGraph(G,3);
Graph( Category := SimpleGraphs, Order := 8, Size := 28, Adjacencies :=
[ [ 2, 3, 4, 5, 6, 7, 8 ], [ 1, 3, 4, 5, 6, 7, 8 ], [ 1, 2, 4, 5, 6, 7, 8 ],
  [ 1, 2, 3, 5, 6, 7, 8 ], [ 1, 2, 3, 4, 6, 7, 8 ], [ 1, 2, 3, 4, 5, 7, 8 ],
  [ 1, 2, 3, 4, 5, 6, 8 ], [ 1, 2, 3, 4, 5, 6, 7 ] ] )
\endexample



