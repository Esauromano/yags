% This file was created automatically from morphisms.msk.
% DO NOT EDIT!
\Chapter{Morphisms of Graphs}

There exists several classes of morphisms that can be found on
graphs. Moreover, sometimes we want to find a combination of them. For
this reason \YAGS \ uses a unique mechanism for dealing with
morphisms. This mechanisms allows to find any combination of morphisms
using three underlying operations.

\Section{Core Operations}

The following operations do all the work of finding morphisms that
comply with all the properties given in a list. The list of checks
that each function receives can have any of the following elements. 
\beginlist
\item{-}
    CHK_METRIC <Metric>
\item{-}
    CHK_MONO <Mono>
\item{-}
    CHK_FULL <Full>
\item{-}
    CHK_EPI <Epi>
\item{-}
    CHK_CMPLT <Complete>
\item{-}
    CHK_ISO <Iso>
\endlist

Additionally it must have at least one of the following.
\beginlist
\item{-}
    CHK_WEAK <Weak>
\item{-}
    CHK_MORPH <Morph>
\endlist

These properties are detailed in the next section.

\>PropertyMorphism( <G1>, <G2>, <c> ) O

Returns the first morphisms (in lexicographic order) from <G1> to <G2> 
satisfying the list of properties <c>

A number of preprogrammed properties are provided by \YAGS, and the user may create 
additional ones. The properties provided are: `CHK_WEAK', `CHK_MORPH', `CHK_METRIC', 
`CHK_CMPLT', `CHK_MONO' and `CHK_EPI'.

If <G1> has <n> vertices and $f:G1\rightarrow G2$ is a morphism, it is 
represented as `[f(1), f(2), ..., f(n)]'. 

\beginexample
gap> g1:=CycleGraph(4);;g2:=CompleteBipartiteGraph(2,2);;
gap> c:=[CHK_MORPH];;                            
gap> PropertyMorphism(g1,g2,c);                          
[ 1, 3, 1, 3 ]
\endexample



\>PropertyMorphisms( <G1>, <G2>, <c> ) O

Returns all morphisms from <G1> to <G2> 
satisfying the list of properties <c>

A number of preprogrammed properties are provided by \YAGS, and the user may create 
additional ones. The properties provided are: `CHK_WEAK', `CHK_MORPH', `CHK_METRIC', 
`CHK_CMPLT', `CHK_MONO' and `CHK_EPI'.

If <G1> has <n> vertices and $f:G1\rightarrow G2$ is a morphism, it is 
represented as `[f(1), f(2), ..., f(n)]'. 

\beginexample
gap> g1:=CycleGraph(4);;g2:=CompleteBipartiteGraph(2,2);;
gap> c:=[CHK_WEAK,CHK_MONO];;                    
gap> PropertyMorphisms(g1,g2,c);
[ [ 1, 3, 2, 4 ], [ 1, 4, 2, 3 ], [ 2, 3, 1, 4 ], [ 2, 4, 1, 3 ], 
  [ 3, 1, 4, 2 ], [ 3, 2, 4, 1 ], [ 4, 1, 3, 2 ], [ 4, 2, 3, 1 ] ]
\endexample



\>NextPropertyMorphism( <G1>, <G2>, <m>, <c> ) O

Returns the next morphisms (in lexicographic order) from <G1> to <G2> 
satisfying the list of properties <c> starting with (possibly incomplete) 
morphism <m>. The morphism found will me returned *and* stored in <m>
in order to use it as the next starting point, in case `NextPropertyMorphism'
is called again. The operation returns `fail' if there are no more morphisms of 
the specified type.

A number of preprogrammed properties are provided by \YAGS, and the user may create 
additional ones. The properties provided are: `CHK_WEAK', `CHK_MORPH', `CHK_METRIC', 
`CHK_CMPLT', `CHK_MONO' and `CHK_EPI'.

If <G1> has <n> vertices and $f:G1\rightarrow G2$ is a morphism, it is 
represented as `[f(1), f(2), ..., f(n)]'. 

\beginexample
gap> g1:=CycleGraph(4);;g2:=CompleteBipartiteGraph(2,2);;
gap> m:=[];; c:=[CHK_MORPH,CHK_MONO];;                   
gap> NextPropertyMorphism(g1,g2,m,c);                    
[ 1, 3, 2, 4 ]
gap> NextPropertyMorphism(g1,g2,m,c);
[ 1, 4, 2, 3 ]
gap> NextPropertyMorphism(g1,g2,m,c);
[ 2, 3, 1, 4 ]
gap> NextPropertyMorphism(g1,g2,m,c);
[ 2, 4, 1, 3 ]
gap> NextPropertyMorphism(g1,g2,m,c);
[ 3, 1, 4, 2 ]
gap> NextPropertyMorphism(g1,g2,m,c);
[ 3, 2, 4, 1 ]
gap> NextPropertyMorphism(g1,g2,m,c);
[ 4, 1, 3, 2 ]
gap> NextPropertyMorphism(g1,g2,m,c);
[ 4, 2, 3, 1 ]
gap> NextPropertyMorphism(g1,g2,m,c);
fail
\endexample



\Section{Morphisms}

For all the definitions we assume we have a morphism $\varphi:G
\rightarrow H.$ The properties for creating morphisms are the following:

\beginlist
\item{*Metric*}
A morphism is metric if the distance (see section "distance") of any
two vertices remains constant $$d_G(x,y) = d_H(\varphi(x),\varphi(y)).$$

\item{*Mono*}
A morphism is mono if two different vertices in <G> map to two
different vertices in <H> $$x \neq y \implies \varphi(x) \neq
\varphi(y).$$

\item{*Full*}
A morphism is full if every edge in <G> is mapped to an edge in
<H>. $$|H| = |G|.$$ Not yet implemented.

\item{*Epi*}
A morphism is Epi if for each vertex in <H> exist a vertex in <G> that
is mapped from. $$\forall x \in H \exists x_0 \in G \bullet
\varphi(x_0) = x$$

\item{*Complete*}
A morphism is complete iff the inverse image of any complete of $H$ is
a complete of $G.$

\item{*Iso*}
An isomorphism is a bimorphism which is also complete.

\endlist

Aditionally they must be one of the following

\beginlist
\item{*Weak*}
A morphism is weak if <x> adjacent to <y> in <G> means their mappings
are adjacent in <H> $$x, y \in G \wedge x \simeq y \Rightarrow
\varphi(x) \simeq \varphi(y).$$

\item{*Morph*}
This is equivalent to <strong>. A morphism is strong if two different
vertices in <G> map to different vertices in <H>. $$x, y \in G \wedge
x \sim y \Rightarrow \varphi(x) \sim \varphi(y).$$ Note that $x \neq y
\Rightarrow \varphi(x) \neq \varphi(y)$ unless there is a loop in $G.$

\endlist

 


