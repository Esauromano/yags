% This file was created automatically from other.msk.
% DO NOT EDIT!
\Chapter{All YAGS 's Functions}

A complete list of all \YAGS 's functions in alphabetical order follows.

\>AddEdges( <G>, <E> ) O

Returns a new graph created from graph <G> by adding the edges in list <E>.

\beginexample
gap> g:=CycleGraph(4);   
Graph( Category := SimpleGraphs, Order := 4, Size := 4, Adjacencies := 
[ [ 2, 4 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3 ] ] )
gap> AddEdges(g,[[1,3]]);
Graph( Category := SimpleGraphs, Order := 4, Size := 5, Adjacencies := 
[ [ 2, 3, 4 ], [ 1, 3 ], [ 1, 2, 4 ], [ 1, 3 ] ] )
gap> AddEdges(g,[[1,3],[2,4]]);
Graph( Category := SimpleGraphs, Order := 4, Size := 6, Adjacencies := 
[ [ 2, 3, 4 ], [ 1, 3, 4 ], [ 1, 2, 4 ], [ 1, 2, 3 ] ] )
\endexample


\>AddVerticesByAdjacencies( <G>, <NewAdjList> ) O

Returns a new graph created from graph <G> by adding as many new vertices 
as `Length(<NewAdjList>)'. Each entry in <NewAdjList> is also a list: the list  
of neighbors of the corresponding new vertex.

\beginexample
gap> g:=PathGraph(5);
Graph( Category := SimpleGraphs, Order := 5, Size := 4, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 4 ] ] )
gap> AddVerticesByAdjacencies(g,[[1,2],[4,5]]); 
Graph( Category := SimpleGraphs, Order := 7, Size := 8, Adjacencies := 
[ [ 2, 6 ], [ 1, 3, 6 ], [ 2, 4 ], [ 3, 5, 7 ], [ 4, 7 ], [ 1, 2 ], [ 4, 5 ] ] )
gap> AddVerticesByAdjacencies(g,[[1,2,7],[4,5]]);
Graph( Category := SimpleGraphs, Order := 7, Size := 9, Adjacencies := 
[ [ 2, 6 ], [ 1, 3, 6 ], [ 2, 4 ], [ 3, 5, 7 ], [ 4, 7 ], [ 1, 2, 7 ], [ 4, 5, 6 ] ] )
\endexample


\>Adjacencies( <G> ) O

Returns the adjacency lists of graph <G>.

\beginexample
gap> g:=PathGraph(3);
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
gap> Adjacencies(g);  
[ [ 2 ], [ 1, 3 ], [ 2 ] ]
\endexample


\>Adjacency( <G>, <v> ) O

Returns the adjacency list of vertex <v> in <G>.

\beginexample
gap> g:=PathGraph(3);
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
gap> Adjacency(g,1);           
[ 2 ]
gap> Adjacency(g,2);
[ 1, 3 ]
\endexample


\>AdjMatrix( <G> ) A

Returns the adjacency matrix of graph <G>.

\beginexample
gap> AdjMatrix(CycleGraph(4));
[ [ false, true, false, true ], [ true, false, true, false ], 
  [ false, true, false, true ], [ true, false, true, false ] ]
\endexample


\>`AGraph' V

A 4-cycle with two pendant vertices on consecutive vertices of the cycle.

\beginexample
gap> AGraph;
Graph( Category := SimpleGraphs, Order := 6, Size := 6, Adjacencies := 
[ [ 2 ], [ 1, 3, 5 ], [ 2, 4 ], [ 3, 5 ], [ 2, 4, 6 ], [ 5 ] ] )
\endexample


\>`AntennaGraph' V

A `HouseGraph' with a pendant vertex (antenna) on the roof.

\beginexample
gap> AntennaGraph;
Graph( Category := SimpleGraphs, Order := 6, Size := 7, Adjacencies := 
[ [ 2, 4, 5 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3, 5 ], [ 1, 4, 6 ], [ 5 ] ] )
\endexample



%FIXME AutomorphismGroup

\>BackTrack( <L>, <opts>, <chk>, <done>, <extra> ) O

Generic, user-customizable backtracking algorithm.

A backtraking algorithm explores a decision tree in search for solutions to a 
combinatorial problem. The combinatorial problem and the search strategy are specified 
by the parameters:

<L> is just a list that `BackTrack' uses to keep track of solutions and partial solutions. 
It is usually set to the empty list as a starting point. 
After a solution is found, it is returned *and* stored in <L>. This value of <L> is then used 
as a starting point to search for the next solution in case `BackTrack' is called again. 
Partial solutions are also stored in <L> during the execution of `BackTrack'.

<extra> may be any object, list, record, etc. `BackTrack' only uses it to pass this data to 
the user-defined functions <opts>, <chk> and <done>, therefore offering you a way to share data 
between your functions.

<opts>`:=function(L,extra)' must return the list of continuation options (childs) one has after some 
partial solution (node) <L> has been reached within the decision tree (<opts> may use the extra data 
<extra> as needed). Each of the values in the list returned by <opts>`(L,extra)' will be tried as 
possible continuations of the partial solution <L>. If <opts>`(L,extra)' always returns the same list, 
you can put that list in place of the parameter <opts>.

<chk>`:=function(L,extra)' must evaluate the partial solution <L> possibly using the extra data 
<extra> and must return `false' when it knows that <L> can not be extended to a solution 
of the problem. Otherwise it returns `true'. <chk> may assume that <L>`{[1..Length(L)-1]}' already 
passed the test.

<done>`:=function(L,extra)' returns `true' if <L> is already a complete solution and `false' otherwise. 
In many combinatorial problems, any partial solution of certain length <N> is also a solution 
(and viceversa), so if this is your case, you can put that length in place of the parameter <done>.

The following example uses `BackTrack' in its simplest form to compute derrangements 
(permutations of a set, where none of the elements appears in its original position).

\beginexample
gap> N:=4;;L:=[];;extra:=[];;opts:=[1..N];;done:=N;;
gap> chk:=function(L,extra) local i; i:=Length(L); 
>           return not L[i] in L{[1..i-1]} and L[i]<> i; end;;
gap> BackTrack(L,opts,chk,done,extra);
[ 2, 1, 4, 3 ]
gap> BackTrack(L,opts,chk,done,extra);
[ 2, 3, 4, 1 ]
gap> BackTrack(L,opts,chk,done,extra);
[ 2, 4, 1, 3 ]
gap> BackTrack(L,opts,chk,done,extra);
[ 3, 1, 4, 2 ]
gap> BackTrack(L,opts,chk,done,extra);
[ 3, 4, 1, 2 ]
gap> BackTrack(L,opts,chk,done,extra);
[ 3, 4, 2, 1 ]
gap> BackTrack(L,opts,chk,done,extra);
[ 4, 1, 2, 3 ]
gap> BackTrack(L,opts,chk,done,extra);
[ 4, 3, 1, 2 ]
gap> BackTrack(L,opts,chk,done,extra);
[ 4, 3, 2, 1 ]
gap> BackTrack(L,opts,chk,done,extra);
fail
\endexample


\>BackTrackBag( <opts>, <chk>, <done>, <extra> ) O

Returns the list of all solutions that would be returned one at a time by 
`Backtrack'.

The following example computes all derrangements of order 4.

\beginexample
gap> N:=4;;
gap> chk:=function(L,extra) local i; i:=Length(L); 
>           return not L[i] in L{[1..i-1]} and L[i]<> i; end;;
gap> BackTrackBag([1..N],chk,N,[]);
[ [ 2, 1, 4, 3 ], [ 2, 3, 4, 1 ], [ 2, 4, 1, 3 ], [ 3, 1, 4, 2 ], 
  [ 3, 4, 1, 2 ], [ 3, 4, 2, 1 ], [ 4, 1, 2, 3 ], [ 4, 3, 1, 2 ], 
  [ 4, 3, 2, 1 ] ]
\endexample


\>Basement( <G>, <KnG>, <x> ) O
\>Basement( <G>, <KnG>, <V> ) O

Given a graph <G>, some iterated clique graph <KnG> of <G> and a vertex <x> of <KnG>,
the operation computes the <basement> of <x> with respect to <G> \cite{Piz04}. 
Loosely speaking, the basement of <x> is the set of vertices of <G> that constitutes 
the iterated clique <x>.

\beginexample
gap> g:=Icosahedron;;Cliques(g);
[ [ 1, 2, 3 ], [ 1, 2, 6 ], [ 1, 3, 4 ], [ 1, 4, 5 ], [ 1, 5, 6 ], 
  [ 4, 5, 7 ], [ 4, 7, 11 ], [ 5, 7, 8 ], [ 7, 8, 12 ], [ 7, 11, 12 ], 
  [ 5, 6, 8 ], [ 6, 8, 9 ], [ 8, 9, 12 ], [ 2, 6, 9 ], [ 2, 9, 10 ], 
  [ 9, 10, 12 ], [ 2, 3, 10 ], [ 3, 10, 11 ], [ 10, 11, 12 ], [ 3, 4, 11 ] ]
gap> kg:=CliqueGraph(g);; k2g:=CliqueGraph(kg);;
gap> Basement(g,k2g,1);Basement(g,k2g,2);
[ 1, 2, 3, 4, 5, 6 ]
[ 1, 2, 3, 4, 6, 10 ]
\endexample

In its second form, <V> is a set of vertices of <KnG>, in that case, the basement is 
simply the union of the basements of the vertices in <V>.

\beginexample
gap> Basement(g,k2g,[1,2]);              
[ 1, 2, 3, 4, 5, 6, 10 ]
\endexample


\>BoxProduct( <G>, <H> ) O

Returns the box product, <G> $\square$ <H>, of two graphs <G> and <H> 
(also known as the cartesian product).

The box product is calculated as follows:

For each pair of vertices $g \in G, h \in H$ we create a vertex
$(g,h)$. Given two such vertices $(g,h)$ and $(g',h')$ they are
adjacent <iff> $g = g'$ and $h \sim h'$ or $g \sim g'$ and $h = h'$.

\beginexample
gap> g1:=PathGraph(3);g2:=CycleGraph(4);
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
Graph( Category := SimpleGraphs, Order := 4, Size := 4, Adjacencies := 
[ [ 2, 4 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3 ] ] )
gap> g1g2:=BoxProduct(g1,g2);           
Graph( Category := SimpleGraphs, Order := 12, Size := 20, Adjacencies := 
[ [ 2, 4, 5 ], [ 1, 3, 6 ], [ 2, 4, 7 ], [ 1, 3, 8 ], [ 1, 6, 8, 9 ], 
  [ 2, 5, 7, 10 ], [ 3, 6, 8, 11 ], [ 4, 5, 7, 12 ], [ 5, 10, 12 ], 
  [ 6, 9, 11 ], [ 7, 10, 12 ], [ 8, 9, 11 ] ] )
gap> VertexNames(g1g2);
[ [ 1, 1 ], [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 2, 1 ], [ 2, 2 ], [ 2, 3 ], 
  [ 2, 4 ], [ 3, 1 ], [ 3, 2 ], [ 3, 3 ], [ 3, 4 ] ]
\endexample


\>BoxTimesProduct( <G>, <H> ) O

Returns the boxtimes product of two graphs <G> and <H>, <G>
$\boxtimes$ <H> (also known as the strong product). 

The box times product is calculated as follows:

For each pair of vertices $g \in G, h \in H$ we create a vertex
$(g,h)$. Given two such vertices $(g,h)$ and $(g',h')$ such that
$(g,h) \neq (g',h')$ they are adjacent <iff> $g \simeq g'$ and $h
\simeq h'$. 

\beginexample
gap> g1:=PathGraph(3);g2:=CycleGraph(4);
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
Graph( Category := SimpleGraphs, Order := 4, Size := 4, Adjacencies := 
[ [ 2, 4 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3 ] ] )
gap> g1g2:=BoxTimesProduct(g1,g2);      
Graph( Category := SimpleGraphs, Order := 12, Size := 36, Adjacencies := 
[ [ 2, 4, 5, 6, 8 ], [ 1, 3, 5, 6, 7 ], [ 2, 4, 6, 7, 8 ], [ 1, 3, 5, 7, 8 ], 
  [ 1, 2, 4, 6, 8, 9, 10, 12 ], [ 1, 2, 3, 5, 7, 9, 10, 11 ], 
  [ 2, 3, 4, 6, 8, 10, 11, 12 ], [ 1, 3, 4, 5, 7, 9, 11, 12 ], 
  [ 5, 6, 8, 10, 12 ], [ 5, 6, 7, 9, 11 ], [ 6, 7, 8, 10, 12 ], 
  [ 5, 7, 8, 9, 11 ] ] )
gap> VertexNames(g1g2);                 
[ [ 1, 1 ], [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 2, 1 ], [ 2, 2 ], [ 2, 3 ], 
  [ 2, 4 ], [ 3, 1 ], [ 3, 2 ], [ 3, 3 ], [ 3, 4 ] ]
\endexample


\>`BullGraph' V

A triangle with two pendant vertices (horns).

\beginexample
gap> BullGraph;    
Graph( Category := SimpleGraphs, Order := 5, Size := 5, Adjacencies := 
[ [ 2 ], [ 1, 3, 4 ], [ 2, 4 ], [ 2, 3, 5 ], [ 4 ] ] )
\endexample


\>CayleyGraph( <Grp>, <elms> ) O
\>CayleyGraph( <Grp> ) O

Returns the graph $G$ whose vertices are the elements of the group <Grp> 
such that $x$ is adjacent to $y$ iff $x*g=y$ for some $g$ in the list <elms>.
if <elms> is not provided, then the generators of <G> are used instead.

\beginexample
gap> grp:=Group((1,2,3),(1,2));    
Group([ (1,2,3), (1,2) ])
gap> CayleyGraph(grp);             
Graph( Category := SimpleGraphs, Order := 6, Size := 9, Adjacencies := 
[ [ 3, 4, 5 ], [ 3, 5, 6 ], [ 1, 2, 6 ], [ 1, 5, 6 ], [ 1, 2, 4 ], 
  [ 2, 3, 4 ] ] )
gap> CayleyGraph(grp,[(1,2),(2,3)]);
Graph( Category := SimpleGraphs, Order := 6, Size := 6, Adjacencies := 
[ [ 2, 3 ], [ 1, 5 ], [ 1, 4 ], [ 3, 6 ], [ 2, 6 ], [ 4, 5 ] ] )
\endexample


\>`ChairGraph' V

A tree with degree sequence 3,2,1,1,1.

\beginexample
gap> ChairGraph;
Graph( Category := SimpleGraphs, Order := 5, Size := 4, Adjacencies := 
[ [ 2 ], [ 1, 3, 4 ], [ 2 ], [ 2, 5 ], [ 4 ] ] )
\endexample


\>Circulant( <n>, <jumps> ) O

Returns the graph G whose vertices are [1..n] such that x is adjacent 
to y iff x+z=y mod n for some z the list of <jumps>

\beginexample
gap> Circulant(6,[1,2]);   
Graph( Category := SimpleGraphs, Order := 6, Size := 12, Adjacencies := 
[ [ 2, 3, 5, 6 ], [ 1, 3, 4, 6 ], [ 1, 2, 4, 5 ], [ 2, 3, 5, 6 ], 
  [ 1, 3, 4, 6 ], [ 1, 2, 4, 5 ] ] )
\endexample


\>`ClawGraph' V

The graph on 4 vertices, 3 edges, and maximum degree 3. 

\beginexample
gap> ClawGraph;
Graph( Category := SimpleGraphs, Order := 4, Size := 3, Adjacencies :=
[ [ 2, 3, 4 ], [ 1 ], [ 1 ], [ 1 ] ] )
\endexample


\>CliqueGraph( <G> ) A
\>CliqueGraph( <G>, <m> ) O

Returns the intersection graph of all the (maximal) cliques of <G>.

The additional parameter <m> aborts the computation when <m> cliques are found, 
even if they are all the cliques of <G>. If the bound <m> is reached, <fail> is returned.

\beginexample
gap> CliqueGraph(Octahedron);   
Graph( Category := SimpleGraphs, Order := 8, Size := 24, Adjacencies := 
[ [ 2, 3, 4, 5, 6, 7 ], [ 1, 3, 4, 5, 6, 8 ], [ 1, 2, 4, 5, 7, 8 ], 
  [ 1, 2, 3, 6, 7, 8 ], [ 1, 2, 3, 6, 7, 8 ], [ 1, 2, 4, 5, 7, 8 ], 
  [ 1, 3, 4, 5, 6, 8 ], [ 2, 3, 4, 5, 6, 7 ] ] )
gap> CliqueGraph(Octahedron,9); 
Graph( Category := SimpleGraphs, Order := 8, Size := 24, Adjacencies := 
[ [ 2, 3, 4, 5, 6, 7 ], [ 1, 3, 4, 5, 6, 8 ], [ 1, 2, 4, 5, 7, 8 ], 
  [ 1, 2, 3, 6, 7, 8 ], [ 1, 2, 3, 6, 7, 8 ], [ 1, 2, 4, 5, 7, 8 ], 
  [ 1, 3, 4, 5, 6, 8 ], [ 2, 3, 4, 5, 6, 7 ] ] )
gap> CliqueGraph(Octahedron,8);
fail
\endexample


\>CliqueNumber( <G> ) A

Returns the order, $\omega(G)$, of a maximum clique of <G>. 

\beginexample
gap> g:=SunGraph(4);
Graph( Category := SimpleGraphs, Order := 8, Size := 14, Adjacencies := 
[ [ 2, 8 ], [ 1, 3, 4, 6, 8 ], [ 2, 4 ], [ 2, 3, 5, 6, 8 ], [ 4, 6 ], 
  [ 2, 4, 5, 7, 8 ], [ 6, 8 ], [ 1, 2, 4, 6, 7 ] ] )
gap> CliqueNumber(g);
4
\endexample


\>Cliques( <G> ) A
\>Cliques( <G>, <m> ) O

Returns the set of all (maximal) cliques of a graph <G>. A clique is a maximal complete subgraph.
Here, we use the Bron-Kerbosch algorithm \cite{BK73}.
 
In the second form, It stops computing cliques after <m> of them have been found.

\beginexample
gap> Cliques(Octahedron);  
[ [ 1, 3, 5 ], [ 1, 3, 6 ], [ 1, 4, 5 ], [ 1, 4, 6 ], [ 2, 3, 5 ], 
  [ 2, 3, 6 ], [ 2, 4, 5 ], [ 2, 4, 6 ] ]
gap> Cliques(Octahedron,4);
[ [ 1, 3, 5 ], [ 1, 3, 6 ], [ 1, 4, 5 ], [ 1, 4, 6 ] ]
\endexample


\>ComplementGraph( <G> ) A

Computes the complement of graph <G>. The complement of a graph is
created as follows:
Create a graph <G'> with same vertices of <G>. For each <x>, <y>
$\in$ <G> if <x> $\nsim$ <y> in <G> then <x> $\sim$ <y> in <G'>

\beginexample 
gap> g:=ClawGraph;
Graph( Category := SimpleGraphs, Order := 4, Size := 3, Adjacencies :=
[ [ 2, 3, 4 ], [ 1 ], [ 1 ], [ 1 ] ] )
gap> ComplementGraph(g);
Graph( Category := SimpleGraphs, Order := 4, Size := 3, Adjacencies :=
[ [  ], [ 3, 4 ], [ 2, 4 ], [ 2, 3 ] ] )
\endexample


\>CompleteBipartiteGraph( <n>, <m> ) F

Returns the complete bipartite whose parts have order <n> and <m> respectively. 
This is the joint (Zykov sum) of two discrete graphs of order <n> and <m>. 

\beginexample
gap> CompleteBipartiteGraph(2,3);
Graph( Category := SimpleGraphs, Order := 5, Size := 6, Adjacencies :=
[ [ 3, 4, 5 ], [ 3, 4, 5 ], [ 1, 2 ], [ 1, 2 ], [ 1, 2 ] ] )
\endexample


\>CompleteGraph( <n> ) F

Returns the complete graph of order <n>. A complete graph is a graph
where all vertices are connected to each other.

\beginexample
gap> CompleteGraph(4);
Graph( Category := SimpleGraphs, Order := 4, Size := 6, Adjacencies :=
[ [ 2, 3, 4 ], [ 1, 3, 4 ], [ 1, 2, 4 ], [ 1, 2, 3 ] ] )
\endexample


\>CompletelyParedGraph( <G> ) O

Returns the completely pared graph of <G>, which is obtained by repeatedly applying 
`ParedGraph' until no more dominated vertices remain. 

\beginexample
gap> g:=PathGraph(6);
Graph( Category := SimpleGraphs, Order := 6, Size := 5, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 4, 6 ], [ 5 ] ] )
gap> CompletelyParedGraph(g);
Graph( Category := SimpleGraphs, Order := 1, Size := 0, Adjacencies := 
[ [  ] ] )
\endexample


\>CompleteMultipartiteGraph( <n1>, <n2> [, <n3> ...] ) F

Returns the complete multipartite graph where the orders of the parts are 
<n1>, <n2>, ... It is also the Zykov sum of discrete graphs of order <n1>, <n2>, ...

\beginexample
gap> CompleteMultipartiteGraph(2,2,2);
Graph( Category := SimpleGraphs, Order := 6, Size := 12, Adjacencies :=
[ [ 3, 4, 5, 6 ], [ 3, 4, 5, 6 ], [ 1, 2, 5, 6 ], [ 1, 2, 5, 6 ],
 [ 1, 2, 3, 4 ], [ 1, 2, 3, 4 ] ] )
\endexample


\>CompletesOfGivenOrder( <G>, <o> ) O

This operation finds all complete subgraphs of order <o> in graph <G>.

\beginexample
gap> g:=SunGraph(4);
Graph( Category := SimpleGraphs, Order := 8, Size := 14, Adjacencies :=
[ [ 2, 8 ], [ 1, 3, 4, 6, 8 ], [ 2, 4 ], [ 2, 3, 5, 6, 8 ], [ 4, 6 ],
  [ 2, 4, 5, 7, 8 ], [ 6, 8 ], [ 1, 2, 4, 6, 7 ] ] )
gap> CompletesOfGivenOrder(g,3);
[ [ 1, 2, 8 ], [ 2, 3, 4 ], [ 2, 4, 6 ], [ 2, 4, 8 ], [ 2, 6, 8 ],
  [ 4, 5, 6 ], [ 4, 6, 8 ], [ 6, 7, 8 ] ]
gap> CompletesOfGivenOrder(g,4);
[ [ 2, 4, 6, 8 ] ]
\endexample


\>Composition( <G>, <H> ) O

Returns the composition $G[H]$ of two graphs <G> and <H>.

A composition of graphs is obtained by calculating the GraphSum
of <G> with <Order(G)> copies of <H>, $G[H] = GraphSum(G, [H, \ldots, H])$.

\beginexample
gap> g1:=CycleGraph(4);;g2:=DiscreteGraph(2);;                  
gap> Composition(g1,g2);                      
Graph( Category := SimpleGraphs, Order := 8, Size := 16, Adjacencies := 
[ [ 3, 4, 7, 8 ], [ 3, 4, 7, 8 ], [ 1, 2, 5, 6 ], [ 1, 2, 5, 6 ], 
  [ 3, 4, 7, 8 ], [ 3, 4, 7, 8 ], [ 1, 2, 5, 6 ], [ 1, 2, 5, 6 ] ] )
\endexample


\>Cone( <G> ) O

Returns the cone of graph <G>. The cone of <G> is the graph 
obtained from <G> by adding a new vertex which is adjacent to every 
vertex of <G>. The new vertex is the first one in the new graph.

\beginexample 
gap> Cone(CycleGraph(4));
Graph( Category := SimpleGraphs, Order := 5, Size := 8, Adjacencies := 
[ [ 2, 3, 4, 5 ], [ 1, 3, 5 ], [ 1, 2, 4 ], [ 1, 3, 5 ], [ 1, 2, 4 ] ] )
\endexample


\>ConnectedComponents( <G> ) A

Returns the connected components of <G>.


\>Coordinates( <G> ) O

Gets the coordinates of the vertices of <G>, which are used to draw <G> 
by `Draw( <G> )'. If the coordinates have not been previously set, `Coordinates' 
returns <fail>.


\beginexample
gap> g:=CycleGraph(4);;
gap> Coordinates(g);
fail
gap> SetCoordinates(g,[[-10,-10 ],[-10,20],[20,-10 ], [20,20]]);
gap> Coordinates(g);
[ [ -10, -10 ], [ -10, 20 ], [ 20, -10 ], [ 20, 20 ] ]
\endexample


\>CopyGraph( <G> ) O

Returns a fresh copy of graph <G>. Only the order and adjacency information is copied, 
all other known attributes of <G> are not. Mainly used to transform a graph from one category 
to another. The new graph will be forced to comply with the `TargetGraphCategory'.

\beginexample
gap> g:=CompleteGraph(4);                         
Graph( Category := SimpleGraphs, Order := 4, Size := 6, Adjacencies := 
[ [ 2, 3, 4 ], [ 1, 3, 4 ], [ 1, 2, 4 ], [ 1, 2, 3 ] ] )
gap> g1:=CopyGraph(g:GraphCategory:=OrientedGraphs);
Graph( Category := OrientedGraphs, Order := 4, Size := 6, Adjacencies := 
[ [ 2, 3, 4 ], [ 3, 4 ], [ 4 ], [  ] ] )
gap> CopyGraph(g1:GraphCategory:=SimpleGraphs);     
Graph( Category := SimpleGraphs, Order := 4, Size := 6, Adjacencies := 
[ [ 2, 3, 4 ], [ 1, 3, 4 ], [ 1, 2, 4 ], [ 1, 2, 3 ] ] )
\endexample


\>CuadraticRingGraph( <Rng> ) O

Returns the graph G whose vertices are the elements of <Rng> 
such that x is adjacent to y iff x+z^2=y for some z in <Rng>

\beginexample
gap> CuadraticRingGraph(ZmodnZ(8));
Graph( Category := SimpleGraphs, Order := 8, Size := 12, Adjacencies := 
[ [ 2, 5, 8 ], [ 1, 3, 6 ], [ 2, 4, 7 ], [ 3, 5, 8 ], [ 1, 4, 6 ], 
  [ 2, 5, 7 ], [ 3, 6, 8 ], [ 1, 4, 7 ] ] )
\endexample


\>`Cube' V

The 1-skeleton of Plato's cube.

\beginexample
gap> Cube;
Graph( Category := SimpleGraphs, Order := 8, Size := 12, Adjacencies :=
[ [ 2, 3, 5 ], [ 1, 4, 6 ], [ 1, 4, 7 ], [ 2, 3, 8 ], [ 1, 6, 7 ],
 [ 2, 5, 8 ], [ 3, 5, 8 ], [ 4, 6, 7 ] ] )
\endexample


\>CubeGraph( <n> ) F

Returns the hypercube of dimension <n>. This is the box product (cartesian product) 
of $n$ copies of $K_2$ (an edge).

\beginexample
gap> CubeGraph(3);
Graph( Category := SimpleGraphs, Order := 8, Size := 12, Adjacencies :=
[ [ 2, 3, 5 ], [ 1, 4, 6 ], [ 1, 4, 7 ], [ 2, 3, 8 ], [ 1, 6, 7 ],
[ 2, 5, 8 ], [ 3, 5, 8 ], [ 4, 6, 7 ] ] )
\endexample

-map

\>CycleGraph( <n> ) F

Returns the cyclic graph on <n> vertices. 

\beginexample
gap> CycleGraph(5);
Graph( Category := SimpleGraphs, Order := 5, Size := 5, Adjacencies :=
[ [ 2, 5 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 1, 4 ] ] )
\endexample


\>CylinderGraph( <Base>, <Height> ) F

Returns a cylinder of base <Base> and height <Height>. 
The order of this graph is <Base*(Height+1)> and it is constructed by taking 
<Height+1> copies of the cyclic graph on <Base> vertices, ordering these cycles linearly and then 
joining consecutive cycles by a zigzagging <2*Base>-cycle. This graph is a triangulation of the cylinder where 
all internal vertices are of degree 6 and the border vertices are of degree 4.

\beginexample
gap> g:=CylinderGraph(4,1);
Graph( Category := SimpleGraphs, Order := 8, Size := 16, Adjacencies := 
[ [ 2, 4, 5, 6 ], [ 1, 3, 6, 7 ], [ 2, 4, 7, 8 ], [ 1, 3, 5, 8 ], 
  [ 1, 4, 6, 8 ], [ 1, 2, 5, 7 ], [ 2, 3, 6, 8 ], [ 3, 4, 5, 7 ] ] )
gap> g:=CylinderGraph(4,2);
Graph( Category := SimpleGraphs, Order := 12, Size := 28, Adjacencies := 
[ [ 2, 4, 5, 6 ], [ 1, 3, 6, 7 ], [ 2, 4, 7, 8 ], [ 1, 3, 5, 8 ], 
  [ 1, 4, 6, 8, 9, 10 ], [ 1, 2, 5, 7, 10, 11 ], [ 2, 3, 6, 8, 11, 12 ], 
  [ 3, 4, 5, 7, 9, 12 ], [ 5, 8, 10, 12 ], [ 5, 6, 9, 11 ], [ 6, 7, 10, 12 ], 
  [ 7, 8, 9, 11 ] ] )
\endexample


\>`DartGraph' V

A diamond with a pending vertex and maximum degree 4.

\beginexample
gap> DartGraph; 
Graph( Category := SimpleGraphs, Order := 5, Size := 6, Adjacencies := 
[ [ 2 ], [ 1, 3, 4, 5 ], [ 2, 4, 5 ], [ 2, 3 ], [ 2, 3 ] ] )
\endexample


\>DeclareQtfyProperty( <Name>, <Filter> ) F

For internal use. 

Declares a \YAGS\ quantifiable property named <Name> for filter <Filter>. 
This in turns, declares a boolean \GAP\ property <Name> and an integer \GAP\ attribute <QtfyName>.  

The user must provide the method <Name>(<O>, <qtfy>). If <qtfy> is false,
the method must return a boolean indicating whether the property holds, otherwise,
the method must return a non-negative integer quantifying how far is the object from satisfying the property. 
In the latter case, returning 0 actually means that the object does satisfy the property.

\beginexample
gap> DeclareQtfyProperty("Is2Regular",Graphs);
gap> InstallMethod(Is2Regular,"for graphs",true,[Graphs,IsBool],0,
> function(G,qtfy)
>   local x,count;
>   count:=0;
>   for x in Vertices(G) do
>     if VertexDegree(G,x)<> 2 then 
>       if not qtfy then
>         return false;
>       fi;
>         count:=count+1;
>     fi;
>   od;
>   if not qtfy then return true; fi;
>   return count;
> end);
gap> Is2Regular(CycleGraph(4));
true
gap> QtfyIs2Regular(CycleGraph(4));
0
gap> Is2Regular(DiamondGraph);     
false
gap> QtfyIs2Regular(DiamondGraph);
2
\endexample


\>Diameter( <G> ) A

Returns the maximum among the distances between pairs of
vertices of <G>.

\beginexample
gap> g:=CycleGraph(5);
Graph( Category := SimpleGraphs, Order := 5, Size := 5, Adjacencies :=
[ [ 2, 5 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 1, 4 ] ] )
gap> Diameter(g);
2
\endexample


\>`DiamondGraph' V

The graph on 4 vertices and 5 edges.

\beginexample
gap> DiamondGraph;
Graph( Category := SimpleGraphs, Order := 4, Size := 5, Adjacencies :=
[ [ 2, 3, 4 ], [ 1, 3 ], [ 1, 2, 4 ], [ 1, 3 ] ] )
\endexample


\>DiscreteGraph( <n> ) F

Returns the discrete graph of order <n>. A discrete graph is a graph
without edges.

\beginexample
gap> DiscreteGraph(4);
Graph( Category := SimpleGraphs, Order := 4, Size := 0, Adjacencies :=
[ [  ], [  ], [  ], [  ] ] )
\endexample


\>DisjointUnion( <G>, <H> ) O

Returns the disjoint union of two graphs <G> and <H>, <G> $\dot{\cup}$ <H>.

\beginexample
gap> g1:=PathGraph(3);g2:=PathGraph(2); 
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
Graph( Category := SimpleGraphs, Order := 2, Size := 1, Adjacencies := 
[ [ 2 ], [ 1 ] ] )
gap> DisjointUnion(g1,g2);
Graph( Category := SimpleGraphs, Order := 5, Size := 3, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ], [ 5 ], [ 4 ] ] )
\endexample


\>Distance( <G>, <x>, <y> ) O

Returns the length of a minimal path connecting <x> to <y> in <G>.

\beginexample
gap> Distance(CycleGraph(5),1,3);
2
gap> Distance(CycleGraph(5),1,5);
1
\endexample


\>DistanceGraph( <G>, <D> ) O

Given a graph <G> and list of distances <D>, `DistanceGraph' returns the new graph
constructed on the vertices of <G> where two vertices are
adjacent iff the distance (in <G>) between them belongs to the list <D>.

\beginexample
gap> g:=CycleGraph(5);            
Graph( Category := SimpleGraphs, Order := 5, Size := 5, Adjacencies := 
[ [ 2, 5 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 1, 4 ] ] )
gap> DistanceGraph(g,[2]);
Graph( Category := SimpleGraphs, Order := 5, Size := 5, Adjacencies := 
[ [ 3, 4 ], [ 4, 5 ], [ 1, 5 ], [ 1, 2 ], [ 2, 3 ] ] )
gap> DistanceGraph(g,[1,2]);
Graph( Category := SimpleGraphs, Order := 5, Size := 10, Adjacencies := 
[ [ 2, 3, 4, 5 ], [ 1, 3, 4, 5 ], [ 1, 2, 4, 5 ], [ 1, 2, 3, 5 ], 
  [ 1, 2, 3, 4 ] ] )
\endexample


\>DistanceMatrix( <G> ) A

Returns the distance matrix <D> of a graph <G>: D[x][y] is the distance in <G> 
from vertex <x> to vertex <y>. The matrix may be asymmetric if the graph is not simple. 
An infinite entry in the matrix means that there is no path between the vertices. 
Floyd's algorithm is used to compute the matrix.

\beginexample
gap> g:=PathGraph(4);
Graph( Category := SimpleGraphs, Order := 4, Size := 3, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2, 4 ], [ 3 ] ] )
gap> Display(DistanceMatrix(g));
[ [  0,  1,  2,  3 ],
  [  1,  0,  1,  2 ],
  [  2,  1,  0,  1 ],
  [  3,  2,  1,  0 ] ]
gap> g:=PathGraph(4:GraphCategory:=OrientedGraphs);
Graph( Category := OrientedGraphs, Order := 4, Size := 3, Adjacencies := 
[ [ 2 ], [ 3 ], [ 4 ], [  ] ] )
gap> Display(DistanceMatrix(g));                   
[ [         0,         1,         2,         3 ],
  [  infinity,         0,         1,         2 ],
  [  infinity,  infinity,         0,         1 ],
  [  infinity,  infinity,  infinity,         0 ] ]
\endexample


\>Distances( <G>, <A>, <B> ) O

Given two lists of vertices <A>, <B> of a graph <G>, `Distances' returns the
list of distances for every pair in the cartesian product of <A>
and <B>. The order of the vertices in lists <A> and <B> affects the order
of the list of distances returned.

\beginexample
gap> g:=CycleGraph(5);;
gap> Distances(g, [1,3], [2,4]);
[ 1, 2, 1, 1 ]
gap> Distances(g, [3,1], [2,4]);
[ 1, 1, 1, 2 ]
\endexample


\>DistanceSet( <G>, <A>, <B> ) O

Given two subsets of vertices <A>, <B> of a graph <G>, `DistanceSet' returns the
set of distances for every pair in the cartesian product of <A> and <B>.  

\beginexample
gap> g:=CycleGraph(5);;         
gap> DistanceSet(g, [1,3], [2,4]);
[ 1, 2 ]
\endexample


\>`Dodecahedron' V

The 1-skeleton of Plato's Dodecahedron.

\beginexample
gap> Dodecahedron;
Graph( Category := SimpleGraphs, Order := 20, Size := 30, Adjacencies := 
[ [ 2, 5, 6 ], [ 1, 3, 7 ], [ 2, 4, 8 ], [ 3, 5, 9 ], [ 1, 4, 10 ], 
  [ 1, 11, 15 ], [ 2, 11, 12 ], [ 3, 12, 13 ], [ 4, 13, 14 ], [ 5, 14, 15 ], 
  [ 6, 7, 16 ], [ 7, 8, 17 ], [ 8, 9, 18 ], [ 9, 10, 19 ], [ 6, 10, 20 ], 
  [ 11, 17, 20 ], [ 12, 16, 18 ], [ 13, 17, 19 ], [ 14, 18, 20 ], 
  [ 15, 16, 19 ] ] )
\endexample


\>DominatedVertices( <G> ) A

Returns the set of dominated vertices of <G>. 

A vertex <x> is dominated by another vertex <y> when the closed neighborhood
of <x> is contained in that of <y>. However, when there are twin vertices 
(mutually dominated vertices), exactly one of them (in each equivalent class 
of mutually dominated vertices) does not appear in the returned set.

\beginexample
gap> g1:=PathGraph(3);     
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
gap> DominatedVertices(g1);
[ 1, 3 ]
gap> g2:=PathGraph(2);
Graph( Category := SimpleGraphs, Order := 2, Size := 1, Adjacencies := 
[ [ 2 ], [ 1 ] ] )
gap> DominatedVertices(g2);
[ 2 ]
\endexample


\>`DominoGraph' V

Two squares glued by an edge.

\beginexample
gap> DominoGraph;
Graph( Category := SimpleGraphs, Order := 6, Size := 7, Adjacencies := 
[ [ 2, 4, 6 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3, 5 ], [ 4, 6 ], [ 1, 5 ] ] )
\endexample


\>Draw( <G> ) O

Takes a graph <G> and makes a drawing of it in a separate window. 
The user can then view and modify the drawing and finaly save the vertex 
coordinates of the drawing into the graph <G>.

Within the separate window, type h to toggle on/off the help menu. Besides the 
keyword commands indicated in the help menu, the user may also move vertices 
(by dragging them), move the whole drawing (by dragging the background) and 
scale the drawing (by using the mouse wheel).

\beginexample
gap> Coordinates(Icosahedron);
fail
gap> Draw(Icosahedron);
gap> Coordinates(Icosahedron);
[ [ 29, -107 ], [ 65, -239 ], [ 240, -62 ], [ 78, 79 ], [ -107, 28 ], 
  [ -174, -176 ], [ -65, 239 ], [ -239, 62 ], [ -78, -79 ], [ 107, -28 ], 
  [ 174, 176 ], [ -29, 107 ] ]
\endexample

This preliminary version, should work fine on GNU/Linux. For other plataforms,
you should probably (at least) set up correctly the variable `drawproc'
which should point to the correct external program binary. Java binaries are provided for 
GNU/Linux, Mac OS X and Windows. 

\beginexample
gap> drawproc;
"/usr/share/gap/pkg/yags/bin/draw/application.linux64/draw"
\endexample


\>DumpObject( <O> ) O

Dumps all information available for object <O>. This information
includes to which categories it belongs as well as its type and 
hashing information used by {\GAP}.

\beginexample
gap> DumpObject( true );
Object( TypeObj := NewType( NewFamily( "BooleanFamily", [ 11 ], [ 11 ] ),
[ 11, 34 ] ), Categories := [ "IS_BOOL" ] )
\endexample


\>EasyExec( <dir>, <progname>, <instring> ) O
\>EasyExec( <progname>, <instring> ) O

Calls external program <prog> located in directory <dir>, feeding it with
<instring> as input and returning the output of the external program as a 
string. <dir> must be a directory object or a list of diretory objects. 
If <dir> is not provided, <prog> must be in the system's binary PATH.
'fail' is returned if the program could not be located.

\beginexample
gap> s:=EasyExec("date","");;
gap> s;
"Sun Nov  9 10:36:16 CST 2014\n"
gap> s:=EasyExec("sort","4\n2\n3\n1");;
gap> s;
"1\n2\n3\n4\n"
\endexample


\>Eccentricity( <G>, <x> ) F

Returns the distance from a vertex <x> in graph <G> to its
most distant vertex in <G>.

\beginexample
gap> g:=PathGraph(5);
Graph( Category := SimpleGraphs, Order := 5, Size := 4, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 4 ] ] )
gap> Eccentricity(g,1);           
4
gap> Eccentricity(g,3);
2
\endexample


\>Edges( <G> ) O

Returns the list of edges of graph <G> in the case of `SimpleGraphs'.

\beginexample
gap> g1:=CompleteGraph(3);     
Graph( Category := SimpleGraphs, Order := 3, Size := 3, Adjacencies := 
[ [ 2, 3 ], [ 1, 3 ], [ 1, 2 ] ] )
gap> Edges(g1);
[ [ 1, 2 ], [ 1, 3 ], [ 2, 3 ] ]
\endexample

In the case of `UndirectedGraphs', it also returns the loops. While in the 
other categories, `Edges' actually does not return the edges, but the loops 
and arrows of <G>.

\beginexample
gap> g2:=CompleteGraph(3:GraphCategory:=UndirectedGraphs);
Graph( Category := UndirectedGraphs, Order := 3, Size := 6, Adjacencies := 
[ [ 1, 2, 3 ], [ 1, 2, 3 ], [ 1, 2, 3 ] ] )
gap> Edges(g2);
[ [ 1, 1 ], [ 1, 2 ], [ 1, 3 ], [ 2, 2 ], [ 2, 3 ], [ 3, 3 ] ]
gap> g3:=CompleteGraph(3:GraphCategory:=Graphs);          
Graph( Category := Graphs, Order := 3, Size := 9, Adjacencies := 
[ [ 1, 2, 3 ], [ 1, 2, 3 ], [ 1, 2, 3 ] ] )
gap> Edges(g3);                                 
[ [ 1, 1 ], [ 1, 2 ], [ 1, 3 ], [ 2, 1 ], [ 2, 2 ], [ 2, 3 ], [ 3, 1 ], 
  [ 3, 2 ], [ 3, 3 ] ]
\endexample


\>FanGraph( <N> ) F

Returns the <N>-Fan: The join of a vertex and a <(N+1)>-path.

\beginexample
gap> FanGraph(4);
Graph( Category := SimpleGraphs, Order := 6, Size := 9, Adjacencies :=
[ [ 2, 3, 4, 5, 6 ], [ 1, 3 ], [ 1, 2, 4 ], [ 1, 3, 5 ], [ 1, 4, 6 ],
[ 1, 5 ] ] )
\endexample


\>`FishGraph' V

A square and a triangle glued by a vertex.

\beginexample
gap> FishGraph;
Graph( Category := SimpleGraphs, Order := 6, Size := 7, Adjacencies := 
[ [ 2, 3, 4, 6 ], [ 1, 3 ], [ 1, 2 ], [ 1, 5 ], [ 4, 6 ], [ 1, 5 ] ] )
\endexample


\>`GemGraph' V

The 3-Fan graph.

\beginexample
gap> GemGraph;
Graph( Category := SimpleGraphs, Order := 5, Size := 7, Adjacencies := 
[ [ 2, 3, 4, 5 ], [ 1, 3 ], [ 1, 2, 4 ], [ 1, 3, 5 ], [ 1, 4 ] ] )
\endexample


\>Graph( <R> ) O

Returns a new graph created from the record <R>. The record must provide the field <Category> 
and either the field <Adjacencies> or the field <AdjMatrix>

\beginexample
gap> Graph(rec(Category:=SimpleGraphs,Adjacencies:=[[2],[1]]));
Graph( Category := SimpleGraphs, Order := 2, Size := 1, Adjacencies := [ [ 2 ], [ 1 ] ] )
gap> Graph(rec(Category:=SimpleGraphs,AdjMatrix:=[[false, true],[true, false]]));
Graph( Category := SimpleGraphs, Order := 2, Size := 1, Adjacencies := [ [ 2 ], [ 1 ] ] )
\endexample

Its main purpose is to import graphs from files, which could have been 
previously exported using `PrintTo'.

\beginexample
gap> g:=CycleGraph(4);
Graph( Category := SimpleGraphs, Order := 4, Size := 4, Adjacencies := 
[ [ 2, 4 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3 ] ] )
gap> PrintTo("aux.g","h1:=",g,";");
gap> Read("aux.g");
gap> h1;
Graph( Category := SimpleGraphs, Order := 4, Size := 4, Adjacencies := 
[ [ 2, 4 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3 ] ] )
\endexample


\>GraphByAdjacencies( <A> ) F

Returns a new graph having <A> as its list of adjacencies. The order of the created graph is 
`Length(A)', and the set of neighbors of vertex $x$ is $A[x]$. 

\beginexample
gap> GraphByAdjacencies([[2],[1,3],[2]]);      
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
\endexample

Note, however, that the graph is forced to comply with the `TargetGraphCategory'.

\beginexample
gap> GraphByAdjacencies([[1,2,3],[],[]]);
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2, 3 ], [ 1 ], [ 1 ] ] )
\endexample


\>GraphByAdjMatrix( <M> ) F

Returns a new graph created from an adjacency matrix <M>. The matrix <M> must
be a square boolean matrix.

\beginexample
gap> m:=[ [ false, true, false ], [ true, false, true ], [ false, true, false ] ];;
gap> g:=GraphByAdjMatrix(m);
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
gap> AdjMatrix(g);
[ [ false, true, false ], [ true, false, true ], [ false, true, false ] ]
\endexample

Note, however, that the graph is forced to comply with the `TargetGraphCategory'.

\beginexample
gap> m:=[ [ true, true], [ false, false ] ];;
gap> g:=GraphByAdjMatrix(m);                
Graph( Category := SimpleGraphs, Order := 2, Size := 1, Adjacencies := [ [ 2 ], [ 1 ] ] )
gap> AdjMatrix(g);                          
[ [ false, true ], [ true, false ] ]
\endexample


\>GraphByCompleteCover( <C> ) F

Returns the minimal graph where the elements of <C> are 
(the vertex sets of) complete subgraphs.

\beginexample
gap> GraphByCompleteCover([[1,2,3,4],[4,6,7]]); 
Graph( Category := SimpleGraphs, Order := 7, Size := 9, Adjacencies := 
[ [ 2, 3, 4 ], [ 1, 3, 4 ], [ 1, 2, 4 ], [ 1, 2, 3, 6, 7 ], [  ], [ 4, 7 ], 
  [ 4, 6 ] ] )
\endexample


\>GraphByEdges( <L> ) F

Returns the minimal graph such that the pairs in <L> are edges.

\beginexample
gap> GraphByEdges([[1,2],[1,3],[1,4],[4,5]]);
Graph( Category := SimpleGraphs, Order := 5, Size := 4, Adjacencies := 
[ [ 2, 3, 4 ], [ 1 ], [ 1 ], [ 1, 5 ], [ 4 ] ] )
\endexample

The vertices of the constructed graph range from 1 to the maximum of the
numbers appearing in <L>.

\beginexample
gap> GraphByEdges([[4,3],[4,5]]);
Graph( Category := SimpleGraphs, Order := 5, Size := 2, Adjacencies := 
[ [  ], [  ], [ 4 ], [ 3, 5 ], [ 4 ] ] )
\endexample

Note that `GraphByWalks' has an even greater functionality.


\>GraphByRelation( <V>, <R> ) F
\>GraphByRelation( <N>, <R> ) F

Returns a new graph created from a set of vertices $V$ and a binary relation $R$, 
where $x\sim y$ iff $R(x,y)=true$. In the second form, $N$ is an integer
and $V$ is assumed to be $\{1, 2, \ldots, N\}$.

\beginexample
gap> R:=function(x,y) return Intersection(x,y)<>[]; end;;          
gap> GraphByRelation([[1,2,3],[3,4,5],[5,6,7]],R);               
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
gap> GraphByRelation(8,function(x,y) return AbsInt(x-y)<=2; end); 
Graph( Category := SimpleGraphs, Order := 8, Size := 13, Adjacencies := 
[ [ 2, 3 ], [ 1, 3, 4 ], [ 1, 2, 4, 5 ], [ 2, 3, 5, 6 ], [ 3, 4, 6, 7 ], 
  [ 4, 5, 7, 8 ], [ 5, 6, 8 ], [ 6, 7 ] ] )
\endexample


\>GraphByWalks( <walk1>, <walk2>, ... ) F

Returns the minimal graph such that <walk1>, <walk2>, etc are walks.

\beginexample
gap> GraphByWalks([1,2,3,4,1],[1,5,6]);
Graph( Category := SimpleGraphs, Order := 6, Size := 6, Adjacencies := 
[ [ 2, 4, 5 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3 ], [ 1, 6 ], [ 5 ] ] )
\endexample

Walks can be <nested>, which greatly improves the versatility of this function.
 
\beginexample
gap> GraphByWalks([1,[2,3,4],5],[5,6]);
Graph( Category := SimpleGraphs, Order := 6, Size := 9, Adjacencies := 
[ [ 2, 3, 4 ], [ 1, 3, 5 ], [ 1, 2, 4, 5 ], [ 1, 3, 5 ], [ 2, 3, 4, 6 ], [ 5 ] ] )
\endexample

The vertices in the constructed graph range from 1 to the maximum of the numbers
appearing in <walk1>, <walk2>, ... etc.

\beginexample
gap> GraphByWalks([4,2],[3,6]);
Graph( Category := SimpleGraphs, Order := 6, Size := 2, Adjacencies := 
[ [  ], [ 4 ], [ 6 ], [ 2 ], [  ], [ 3 ] ] )
\endexample


\>GraphCategory( [<G>, ... ] ) F

For internal use. Returns the minimal common category to a list of graphs.
If the list of graphs is empty, the default category is returned.

The partial order (by inclusion) among graph categories is as follows: 
%%FIXME: Wrong spacing in the pdf manual.
$$
`SimpleGraphs' \<  `UndirectedGraphs' \< `Graphs',
$$
$$
`OrientedGraphs' \< `LooplessGraphs' \< `Graphs',
$$
$$
`SimpleGraphs' \< `LooplessGraphs' \< `Graphs'
$$
 
\beginexample
gap> g1:=CompleteGraph(2:GraphCategory:=SimpleGraphs);  
Graph( Category := SimpleGraphs, Order := 2, Size := 1, Adjacencies := 
[ [ 2 ], [ 1 ] ] )
gap> g2:=CompleteGraph(2:GraphCategory:=OrientedGraphs);
Graph( Category := OrientedGraphs, Order := 2, Size := 1, Adjacencies := 
[ [ 2 ], [  ] ] )
gap> g3:=CompleteGraph(2:GraphCategory:=UndirectedGraphs);
Graph( Category := UndirectedGraphs, Order := 2, Size := 3, Adjacencies := 
[ [ 1, 2 ], [ 1, 2 ] ] )
gap> GraphCategory([g1,g2,g3]);
<Operation "Graphs">
gap> GraphCategory([g1,g2]);   
<Operation "LooplessGraphs">
gap> GraphCategory([g1,g3]);
<Operation "UndirectedGraphs">
\endexample


\>Graphs( ) C

`Graphs' is the most general graph category in \YAGS. This category contains
all graphs that can be represented in \YAGS. A graph in this category may 
contain loops, arrows and edges (which in \YAGS\ are exactly the same as two opposite 
arrows between some pair of vertices). This graph category has no parent category.

\beginexample
gap> GraphByWalks([1,1],[1,2],[2,1],[3,2]:GraphCategory:=Graphs);
Graph( Category := Graphs, Order := 3, Size := 4, Adjacencies := 
[ [ 1, 2 ], [ 1 ], [ 2 ] ] )
gap> GraphByWalks([1,1],[1,2],[2,1],[3,2]:GraphCategory:=SimpleGraphs);  
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
\endexample


\>GraphSum( <G>, <L> ) O

Returns the lexicographic sum of a list of graphs <L> over a graph <G>.

The lexicographic sum is computed as follows:

Given <G>, with $Order(G)=n$ and a list of <n> graphs $L = [G_1, \ldots, G_n]$,
We take the disjoint union of $G_1,G_2, \ldots,G_n$ and then we add all the 
edges between $G_i$ and $G_j$ whenever $[i,j]$ is and edge of $G$.

If <L> contains holes, the trivial graph is used in place.

\beginexample
gap> t:=TrivialGraph;; g:=CycleGraph(4);;
gap> GraphSum(PathGraph(3),[t,g,t]);
Graph( Category := SimpleGraphs, Order := 6, Size := 12, Adjacencies := 
[ [ 2, 3, 4, 5 ], [ 1, 3, 5, 6 ], [ 1, 2, 4, 6 ], [ 1, 3, 5, 6 ], 
  [ 1, 2, 4, 6 ], [ 2, 3, 4, 5 ] ] )
gap> GraphSum(PathGraph(3),[,g,]);  
Graph( Category := SimpleGraphs, Order := 6, Size := 12, Adjacencies := 
[ [ 2, 3, 4, 5 ], [ 1, 3, 5, 6 ], [ 1, 2, 4, 6 ], [ 1, 3, 5, 6 ], 
  [ 1, 2, 4, 6 ], [ 2, 3, 4, 5 ] ] )
\endexample


\>GraphToRaw( <filename>, <G> ) O

Converts a \YAGS\ graph <G> into a raw format (number of vertices, coordinates and 
adjacency matrix) and writes the converted data to the file <filename>. 
For use by the external program `draw' (see `Draw(<G>)' ).

\beginexample
gap> g:=CycleGraph(4);;
gap> GraphToRaw("mygraph.raw",g);
\endexample


\>GraphUpdateFromRaw( <filename>, <G> ) O

Updates the coordinates of <G> from a file <filename> in raw format. 
Intended for internal use only.


\>GroupGraph( <G>, <Grp>, <act> ) O
\>GroupGraph( <G>, <Grp> ) O

Given a graph <G>, a group <Grp> and an action <act> of <Grp> in some 
set S which contains Vertices( <G> ), GroupGraph returns a new graph 
with vertex set $\{act(v,g) : g \in Grp, v \in Vertices( G )\}$ 
and edge set $\{\{act(v,g),act(u,g)\}: g\ in Grp \{u,v\}\in Edges( G )\}$.

If <act> is omited, the standard \GAP\ action `OnPoints' is used.

\beginexample
gap> GroupGraph(GraphByWalks([1,2]),Group([(1,2,3,4,5),(2,5)(3,4)]));
Graph( Category := SimpleGraphs, Order := 5, Size := 5, Adjacencies := 
[ [ 2, 5 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 1, 4 ] ] )
\endexample


\>`HouseGraph' V

A 4-Cycle and a triangle glued by an edge.

\beginexample
gap> HouseGraph;
Graph( Category := SimpleGraphs, Order := 5, Size := 6, Adjacencies := 
[ [ 2, 4, 5 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3, 5 ], [ 1, 4 ] ] )
\endexample


\>`Icosahedron' V

The 1-skeleton of Plato's icosahedron.

\beginexample
gap> Icosahedron;
Graph( Category := SimpleGraphs, Order := 12, Size := 30, Adjacencies :=
[ [ 2, 3, 4, 5, 6 ], [ 1, 3, 6, 9, 10 ], [ 1, 2, 4, 10, 11 ],
  [ 1, 3, 5, 7, 11 ], [ 1, 4, 6, 7, 8 ], [ 1, 2, 5, 8, 9 ],
  [ 4, 5, 8, 11, 12 ], [ 5, 6, 7, 9, 12 ], [ 2, 6, 8, 10, 12 ],
  [ 2, 3, 9, 11, 12 ], [ 3, 4, 7, 10, 12 ], [ 7, 8, 9, 10, 11 ] ] )
\endexample


\>in( <G>, <C> ) O

Returns `true' if graph <G> belongs to category <C> and `false' otherwise.


\>InducedSubgraph( <G>, <V> ) O

Returns the subgraph of graph <G> induced by the vertex set <V>.

\beginexample
gap> g:=CycleGraph(6);          
Graph( Category := SimpleGraphs, Order := 6, Size := 6, Adjacencies := 
[ [ 2, 6 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 4, 6 ], [ 1, 5 ] ] )
gap> InducedSubgraph(g,[3,4,6]);  
Graph( Category := SimpleGraphs, Order := 3, Size := 1, Adjacencies := 
[ [ 2 ], [ 1 ], [  ] ] )
\endexample

The order of the elements in <V> does matter.

\beginexample
gap> InducedSubgraph(g,[6,3,4]);  
Graph( Category := SimpleGraphs, Order := 3, Size := 1, Adjacencies := 
[ [  ], [ 3 ], [ 2 ] ] )
\endexample


\>InNeigh( <G>, <x> ) O

Returns the list of in-neighbors of <x> in <G>.

\beginexample
gap> tt:=CompleteGraph(5:GraphCategory:=OrientedGraphs);
Graph( Category := OrientedGraphs, Order := 5, Size := 10, Adjacencies := 
[ [ 2, 3, 4, 5 ], [ 3, 4, 5 ], [ 4, 5 ], [ 5 ], [  ] ] )
gap> InNeigh(tt,3);                                     
[ 1, 2 ]
gap> OutNeigh(tt,3);                                    
[ 4, 5 ]
\endexample


\>IntersectionGraph( <L> ) F

Returns the intersection graph of the family of sets <L>. This graph has a 
vertex for every set in <L>, and two such vertices are adjacent iff the 
corresponding sets have non-empty intersection.

\beginexample
gap> IntersectionGraph([[1,2,3],[3,4,5],[5,6,7]]);
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
\endexample


\>IsBoolean( <O> ) F

Returns `true' if object <O> is `true' or `false' and `false' otherwise.

\beginexample
gap> IsBoolean( true ); IsBoolean( fail ); IsBoolean ( false );
true
false
true
\endexample


\>IsCliqueGated( <G> ) P

Returns `true' if <G> is a clique gated graph \cite{HK96}.


\>IsCliqueHelly( <G> ) P

Returns `true' if the set of (maximal) cliques <G> satisfy
the <Helly> property.

The Helly property is defined as follows:

A non-empty family $\Cal{F}$ of non-empty sets satisfies the Helly property if
every pairwise intersecting subfamily of $\Cal{F}$ has a non-empty total intersection.

Here we use the Dragan-Szwarcfiter characterization \cite{Dra89,Szw97} to compute the Helly property.

\beginexample
gap> g:=SunGraph(3);
Graph( Category := SimpleGraphs, Order := 6, Size := 9, Adjacencies :=
[ [ 2, 6 ], [ 1, 3, 4, 6 ], [ 2, 4 ], [ 2, 3, 5, 6 ], [ 4, 6 ],
  [ 1, 2, 4, 5 ] ] )
gap> IsCliqueHelly(g);
false
\endexample


\>IsComplete( <G>, <L> ) O

Returns true if <L> induces a complete subgraph of <G>.

\beginexample
gap> IsComplete(DiamondGraph,[1,2,3]);
true
gap> IsComplete(DiamondGraph,[1,2,4]);
false
\endexample


\>IsCompleteGraph( <G> ) P

Returns `true' if graph <G> is a complete graph, `false' otherwise.
In a complete graph every pair of vertices is an edge.


\>IsDiamondFree( <G> ) P

Returns `true' if <G> is free from induced diamonds, `false' otherwise.

\beginexample
gap> IsDiamondFree(Cube);
true
gap> IsDiamondFree(Octahedron);
false
\endexample
                                    

\>IsEdge( <G> , [x, y] ) O

Returns true if [x,y] is an edge of <G>.

\beginexample
gap> IsEdge(PathGraph(3),[1,2]);
true
gap> IsEdge(PathGraph(3),[1,3]);
false
\endexample


\>IsIsomorphicGraph( <G>, <H> ) O

Returns `true' when <G> is isomorphic to <H> and `false' otherwise.

\beginexample
gap> g:=PowerGraph(CycleGraph(6),2);;h:=Octahedron;;
gap> IsIsomorphicGraph(g,h);
true
\endexample


\>IsLoopless( <G> ) P

Returns `true' if graph <G> have no loops, `false' otherwise. Loops are edges 
from a vertex to itself.


\>IsoMorphism( <G>, <H> ) O
\>NextIsoMorphism( <G>, <H>, <f> ) O

`IsoMorphism' returns one isomorphism from <G> to <H>. 
`NextIsoMorphism' returns the next isomorphism from <G> to <H> in the lexicographic 
order, it returns `fail' if there are no more isomorphisms. If <G> has <n> vertices, 
an isomorphisms $f : G\rightarrow H$ is represented as the list `[f(1), f(2), ..., f(n)]'.

\beginexample
gap> g:=CycleGraph(4);;h:=CompleteBipartiteGraph(2,2);;
gap> f:=IsoMorphism(g,h);
[ 1, 3, 2, 4 ]
gap> NextIsoMorphism(g,h,f);
[ 1, 4, 2, 3 ]
gap> NextIsoMorphism(g,h,f);
[ 2, 3, 1, 4 ]
gap> NextIsoMorphism(g,h,f);
[ 2, 4, 1, 3 ]
\endexample


\>IsoMorphisms( <G>, <H> ) O

Returns the list of all isomorphism from <G> to <H>. If <G> has <n> vertices, 
an isomorphisms $f : G\rightarrow H$ is represented as the list `[f(1), f(2), ..., f(n)]'.

\beginexample
gap> g:=CycleGraph(4);;h:=CompleteBipartiteGraph(2,2);;
gap> IsoMorphisms(g,h);
[ [ 1, 3, 2, 4 ], [ 1, 4, 2, 3 ], [ 2, 3, 1, 4 ], [ 2, 4, 1, 3 ], 
  [ 3, 1, 4, 2 ], [ 3, 2, 4, 1 ], [ 4, 1, 3, 2 ], [ 4, 2, 3, 1 ] ]
\endexample


\>IsOriented( <G> ) P
\>QtfyIsOriented( <G> ) A

Returns `true' if graph <G> is an oriented graph, `false' otherwise.
Regardless of the categories that <G> belongs to, <G> is oriented if 
whenever `[x,y]' is an edge of <G>, `[y,x]' is not.


\>IsSimple( <G> ) P

Returns `true' if graph <G> is a simple graph, `false' otherwise.
Regardless of the categories that <G> belongs to, <G> is simple if and only if 
<G> is undirected and loopless.

Returns `true' if the graph <G> is simple regardless of its category.


\>IsTournament( <G> ) P

Returns `true' if <G> is a tournament.

\beginexample
gap> tt:=CompleteGraph(5:GraphCategory:=OrientedGraphs);
Graph( Category := OrientedGraphs, Order := 5, Size := 10, Adjacencies := 
[ [ 2, 3, 4, 5 ], [ 3, 4, 5 ], [ 4, 5 ], [ 5 ], [  ] ] )
gap> IsTournament(tt);                                  
true
\endexample


\>IsTransitiveTournament( <G> ) P

Returns `true' if <G> is a transitive tournament.

\beginexample
gap> tt:=CompleteGraph(5:GraphCategory:=OrientedGraphs);
Graph( Category := OrientedGraphs, Order := 5, Size := 10, Adjacencies := 
[ [ 2, 3, 4, 5 ], [ 3, 4, 5 ], [ 4, 5 ], [ 5 ], [  ] ] )
gap> IsTransitiveTournament(tt);
true
\endexample


\>IsUndirected( <G> ) P

Returns `true' if graph <G> is an undirected graph, `false' otherwise.
Regardless of the categories that <G> belongs to, <G> is undirected if 
whenever `[x,y]' is an edge of <G>, `[y,x]' is also an egde of <G>.


\>JohnsonGraph( <n>, <r> ) F

Returns the Johnson graph $J(n,r).$ A Johnson Graph is a 
graph constructed as follows. Each vertex represents a subset of
the set $\{1,\dots,n\}$ with cardinality $r.$ $$V(J(n,r)) = \{ X \subset
\{1,\dots,n\} | |X| = r \}$$ and there is an edge between two
vertices if and only if the cardinality of the intersection of the
sets they represent is $r-1$ $$X \sim X' \hbox{ iff } |X \cup X'| = r-1.$$

\beginexample
gap> JohnsonGraph(4,2);
Graph( Category := SimpleGraphs, Order := 6, Size := 12, Adjacencies :=
[ [ 2, 3, 4, 5 ], [ 1, 3, 4, 6 ], [ 1, 2, 5, 6 ], [ 1, 2, 5, 6 ],
 [ 1, 3, 4, 6 ], [ 2, 3, 4, 5 ] ] )
\endexample


\>Join( <G>, <H> ) O

Returns the result of joining graph <G> and <H>, <G> + <H> 
(also known as the Zykov sum).

Joining graphs is computed as follows:

First, we obtain the disjoint union of graphs <G> and <H>. Second,
for each vertex $g \in G$ we add an edge to each vertex $h \in H$.

\beginexample
gap> g1:=DiscreteGraph(2);g2:=CycleGraph(4);
Graph( Category := SimpleGraphs, Order := 2, Size := 0, Adjacencies := 
[ [  ], [  ] ] )
Graph( Category := SimpleGraphs, Order := 4, Size := 4, Adjacencies := 
[ [ 2, 4 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3 ] ] )
gap> Join(g1,g2);                           
Graph( Category := SimpleGraphs, Order := 6, Size := 12, Adjacencies := 
[ [ 3, 4, 5, 6 ], [ 3, 4, 5, 6 ], [ 1, 2, 4, 6 ], [ 1, 2, 3, 5 ], 
  [ 1, 2, 4, 6 ], [ 1, 2, 3, 5 ] ] )
\endexample


\>`KiteGraph' V

A diamond with a pending vertex and maximum degree 3.

\beginexample
gap> KiteGraph;
Graph( Category := SimpleGraphs, Order := 5, Size := 6, Adjacencies := 
[ [ 2 ], [ 1, 3, 4 ], [ 2, 4, 5 ], [ 2, 3, 5 ], [ 3, 4 ] ] )
\endexample


\>LineGraph( <G> ) O

Returns the line graph <L(G)> of graph <G>. The line graph is the
intersection graph of the edges of <G>, <i.e.> the vertices of
$L(G)$ are the edges of <G> two of them being adjacent iff they
are incident. 

\beginexample 
gap> g:=Tetrahedron;
Graph( Category := SimpleGraphs, Order := 4, Size := 6, Adjacencies :=
[ [ 2, 3, 4 ], [ 1, 3, 4 ], [ 1, 2, 4 ], [ 1, 2, 3 ] ] )
gap> LineGraph(g);
Graph( Category := SimpleGraphs, Order := 6, Size := 12, Adjacencies :=
[ [ 2, 3, 4, 5 ], [ 1, 3, 4, 6 ], [ 1, 2, 5, 6 ], [ 1, 2, 5, 6 ],
  [ 1, 3, 4, 6 ], [ 2, 3, 4, 5 ] ] )
\endexample


\>Link( <G>, <x> ) O

Returns the subgraph of <G> induced by the neighbors of <x>.

\beginexample
gap> Link(SnubDisphenoid,1);
Graph( Category := SimpleGraphs, Order := 5, Size := 5, Adjacencies := 
[ [ 2, 5 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 1, 4 ] ] )
gap> Link(SnubDisphenoid,3);
Graph( Category := SimpleGraphs, Order := 4, Size := 4, Adjacencies := 
[ [ 2, 3 ], [ 1, 4 ], [ 1, 4 ], [ 2, 3 ] ] )
\endexample


\>Links( <G> ) A

Returns the list of subgraphs of <G> induced by the neighbors of each vertex of <G>.

\beginexample
gap> Links(SnubDisphenoid); 
[ Graph( Category := SimpleGraphs, Order := 5, Size := 5, Adjacencies := 
    [ [ 2, 5 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 1, 4 ] ] ), 
  Graph( Category := SimpleGraphs, Order := 5, Size := 5, Adjacencies := 
    [ [ 2, 5 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 1, 4 ] ] ), 
  Graph( Category := SimpleGraphs, Order := 4, Size := 4, Adjacencies := 
    [ [ 2, 3 ], [ 1, 4 ], [ 1, 4 ], [ 2, 3 ] ] ), 
  Graph( Category := SimpleGraphs, Order := 4, Size := 4, Adjacencies := 
    [ [ 2, 3 ], [ 1, 4 ], [ 1, 4 ], [ 2, 3 ] ] ), 
  Graph( Category := SimpleGraphs, Order := 5, Size := 5, Adjacencies := 
    [ [ 2, 5 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 1, 4 ] ] ), 
  Graph( Category := SimpleGraphs, Order := 5, Size := 5, Adjacencies := 
    [ [ 2, 5 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 1, 4 ] ] ), 
  Graph( Category := SimpleGraphs, Order := 4, Size := 4, Adjacencies := 
    [ [ 3, 4 ], [ 3, 4 ], [ 1, 2 ], [ 1, 2 ] ] ), 
  Graph( Category := SimpleGraphs, Order := 4, Size := 4, Adjacencies := 
    [ [ 2, 3 ], [ 1, 4 ], [ 1, 4 ], [ 2, 3 ] ] ) ]
\endexample


\>LooplessGraphs( ) C

`LooplessGraphs' is a graph category in \YAGS. A graph in this category may 
contain arrows and edges but no loops. The parent of this category is `Graphs'

\beginexample
gap> GraphByWalks([1,1],[1,2],[2,1],[3,2]:GraphCategory:=Graphs);
Graph( Category := Graphs, Order := 3, Size := 4, Adjacencies := 
[ [ 1, 2 ], [ 1 ], [ 2 ] ] )
gap> GraphByWalks([1,1],[1,2],[2,1],[3,2]:GraphCategory:=LooplessGraphs);  
Graph( Category := LooplessGraphs, Order := 3, Size := 3, Adjacencies := 
[ [ 2 ], [ 1 ], [ 2 ] ] )
\endexample


\>MaxDegree( <G> ) O

Returns the maximum degree in graph <G>.

\beginexample
gap> g:=GemGraph;
Graph( Category := SimpleGraphs, Order := 5, Size := 7, Adjacencies := 
[ [ 2, 3, 4, 5 ], [ 1, 3 ], [ 1, 2, 4 ], [ 1, 3, 5 ], [ 1, 4 ] ] )
gap> MaxDegree(g);
4
\endexample


\>MinDegree( <G> ) O

Returns the minimum degree in graph <G>.

\beginexample
gap> g:=GemGraph;
Graph( Category := SimpleGraphs, Order := 5, Size := 7, Adjacencies := 
[ [ 2, 3, 4, 5 ], [ 1, 3 ], [ 1, 2, 4 ], [ 1, 3, 5 ], [ 1, 4 ] ] )
gap> MinDegree(g);
2
\endexample


\>NextPropertyMorphism( <G1>, <G2>, <m>, <c> ) O

Returns the next morphisms (in lexicographic order) from <G1> to <G2> 
satisfying the list of properties <c> starting with (possibly incomplete) 
morphism <m>. The morphism found will me returned *and* stored in <m>
in order to use it as the next starting point, in case `NextPropertyMorphism'
is called again. The operation returns `fail' if there are no more morphisms of 
the specified type.

A number of preprogrammed properties are provided by \YAGS, and the user may create 
additional ones. The properties provided are: `CHK_WEAK', `CHK_MORPH', `CHK_METRIC', 
`CHK_CMPLT', `CHK_MONO' and `CHK_EPI'.

If <G1> has <n> vertices and $f:G1\rightarrow G2$ is a morphism, it is 
represented as `[f(1), f(2), ..., f(n)]'. 

\beginexample
gap> g1:=CycleGraph(4);;g2:=CompleteBipartiteGraph(2,2);;
gap> m:=[];; c:=[CHK_MORPH,CHK_MONO];;                   
gap> NextPropertyMorphism(g1,g2,m,c);                    
[ 1, 3, 2, 4 ]
gap> NextPropertyMorphism(g1,g2,m,c);
[ 1, 4, 2, 3 ]
gap> NextPropertyMorphism(g1,g2,m,c);
[ 2, 3, 1, 4 ]
gap> NextPropertyMorphism(g1,g2,m,c);
[ 2, 4, 1, 3 ]
gap> NextPropertyMorphism(g1,g2,m,c);
[ 3, 1, 4, 2 ]
gap> NextPropertyMorphism(g1,g2,m,c);
[ 3, 2, 4, 1 ]
gap> NextPropertyMorphism(g1,g2,m,c);
[ 4, 1, 3, 2 ]
gap> NextPropertyMorphism(g1,g2,m,c);
[ 4, 2, 3, 1 ]
gap> NextPropertyMorphism(g1,g2,m,c);
fail
\endexample


\>NumberOfCliques( <G> ) A
\>NumberOfCliques( <G>, <m> ) O

Returns the number of (maximal) cliques of <G>.  
In the second form, It stops computing cliques after <m> of them have been counted and 
returns <m> in case <G> has <m> or more cliques.

\beginexample
gap> NumberOfCliques(Icosahedron);
20
gap> NumberOfCliques(Icosahedron,15);
15
gap> NumberOfCliques(Icosahedron,50);
20
\endexample

This implementation discards the cliques once counted hence, given enough time, 
it can compute the number of cliques of <G> even if the set of cliques does not fit in memory.

\beginexample
gap> NumberOfCliques(OctahedralGraph(30));
1073741824
\endexample


\>NumberOfConnectedComponents( <G> ) A

Returns the number of connected components of <G>.


\>OctahedralGraph( <n> ) F

Return the <n>-dimensional octahedron. This is the complement of <n> copies
of $K_2$ (an edge). It is also the <(2n-2)>-regular graph on $2n$ vertices.

\beginexample
gap> OctahedralGraph(3);
Graph( Category := SimpleGraphs, Order := 6, Size := 12, Adjacencies :=
[ [ 3, 4, 5, 6 ], [ 3, 4, 5, 6 ], [ 1, 2, 5, 6 ], [ 1, 2, 5, 6 ],
[ 1, 2, 3, 4 ], [ 1, 2, 3, 4 ] ] )
\endexample


\>`Octahedron' V

The 1-skeleton of Plato's octahedron.

\beginexample
gap> Octahedron;
Graph( Category := SimpleGraphs, Order := 6, Size := 12, Adjacencies :=
[ [ 3, 4, 5, 6 ], [ 3, 4, 5, 6 ], [ 1, 2, 5, 6 ], [ 1, 2, 5, 6 ],
  [ 1, 2, 3, 4 ], [ 1, 2, 3, 4 ] ] )
\endexample


\>Order( <G> ) A

Returns the number of vertices, of graph <G>.

\beginexample
gap> Order(Icosahedron);
12
\endexample


\>OrientedGraphs( ) C

`OrientedGraphs' is a graph category in \YAGS. A graph in this category may 
contain arrows, but no loops or edges. The parent of this category is `LooplessGraphs'.

\beginexample
gap> GraphByWalks([1,1],[1,2],[2,1],[3,2]:GraphCategory:=Graphs);
Graph( Category := Graphs, Order := 3, Size := 4, Adjacencies := 
[ [ 1, 2 ], [ 1 ], [ 2 ] ] )
gap> GraphByWalks([1,1],[1,2],[2,1],[3,2]:GraphCategory:=OrientedGraphs);
Graph( Category := OrientedGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [  ], [ 2 ] ] )
\endexample


\>OutNeigh( <G>, <x> ) O

Returns the list of out-neighbors of <x> in <G>.

\beginexample
gap> tt:=CompleteGraph(5:GraphCategory:=OrientedGraphs);
Graph( Category := OrientedGraphs, Order := 5, Size := 10, Adjacencies := 
[ [ 2, 3, 4, 5 ], [ 3, 4, 5 ], [ 4, 5 ], [ 5 ], [  ] ] )
gap> InNeigh(tt,3);                                     
[ 1, 2 ]
gap> OutNeigh(tt,3);                                    
[ 4, 5 ]
\endexample


\>`ParachuteGraph' V

The complement of a `ParapluieGraph'; The suspension of a 4-path with a 
pendant vertex attached to the south pole.

\beginexample
gap> ParachuteGraph;
Graph( Category := SimpleGraphs, Order := 7, Size := 12, Adjacencies := 
[ [ 2 ], [ 1, 3, 4, 5, 6 ], [ 2, 4, 7 ], [ 2, 3, 5, 7 ], [ 2, 4, 6, 7 ], 
  [ 2, 5, 7 ], [ 3, 4, 5, 6 ] ] )
\endexample


\>`ParapluieGraph' V

A 3-Fan graph with a 3-path attached to the universal vertex.

\beginexample
gap> ParapluieGraph;
Graph( Category := SimpleGraphs, Order := 7, Size := 9, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2, 4, 5, 6, 7 ], [ 3, 5 ], [ 3, 4, 6 ], [ 3, 5, 7 ], 
  [ 3, 6 ] ] )
\endexample


\>ParedGraph( <G> ) O

Returns the pared graph of <G>. This is the induced subgraph obtained from 
<G> by removing its dominated vertices. When there are twin vertices 
(mutually dominated vertices), exactly one of them survives the paring in 
each equivalent class of mutually dominated vertices.

\beginexample
gap> g1:=PathGraph(4);
Graph( Category := SimpleGraphs, Order := 4, Size := 3, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2, 4 ], [ 3 ] ] )
gap> ParedGraph(g1);  
Graph( Category := SimpleGraphs, Order := 2, Size := 1, Adjacencies := 
[ [ 2 ], [ 1 ] ] )
gap> g2:=PathGraph(2);
Graph( Category := SimpleGraphs, Order := 2, Size := 1, Adjacencies := 
[ [ 2 ], [ 1 ] ] )
gap> ParedGraph(g2);  
Graph( Category := SimpleGraphs, Order := 1, Size := 0, Adjacencies := 
[ [  ] ] )
\endexample


\>PathGraph( <n> ) F

Returns the path graph on <n> vertices.

\beginexample
gap> PathGraph(4);
Graph( Category := SimpleGraphs, Order := 4, Size := 3, Adjacencies :=
[ [ 2 ], [ 1, 3 ], [ 2, 4 ], [ 3 ] ] )
\endexample


\>`PawGraph' V

The graph on 4 vertices, 4 edges and maximum degree 3: A triangle with a pendant vertex.

\beginexample
gap> PawGraph;
Graph( Category := SimpleGraphs, Order := 4, Size := 4, Adjacencies :=
[ [ 2 ], [ 1, 3, 4 ], [ 2, 4 ], [ 2, 3 ] ] )
\endexample


\>`PetersenGraph' V

The 3-regular graph on 10 vertices having girth 5. 

\beginexample
gap> PetersenGraph;  
Graph( Category := SimpleGraphs, Order := 10, Size := 15, Adjacencies := 
[ [ 2, 5, 6 ], [ 1, 3, 7 ], [ 2, 4, 8 ], [ 3, 5, 9 ], [ 1, 4, 10 ], 
  [ 1, 8, 9 ], [ 2, 9, 10 ], [ 3, 6, 10 ], [ 4, 6, 7 ], [ 5, 7, 8 ] ] )  
\endexample


\>PowerGraph( <G>, <e> ) O

Returns the `DistanceGraph' of <G> using `[0, 1, ..., <e>]' as the list of distances. 
Note that the distance `0' in the list produces loops in the new graph only when the `TargetGraphCategory'
admits loops.

\beginexample
gap> g:=PathGraph(5);
Graph( Category := SimpleGraphs, Order := 5, Size := 4, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 4 ] ] )
gap> PowerGraph(g,1);                      
Graph( Category := SimpleGraphs, Order := 5, Size := 4, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 4 ] ] )
gap> PowerGraph(g,1:GraphCategory:=Graphs);
Graph( Category := Graphs, Order := 5, Size := 13, Adjacencies := 
[ [ 1, 2 ], [ 1, 2, 3 ], [ 2, 3, 4 ], [ 3, 4, 5 ], [ 4, 5 ] ] )
\endexample


\>PropertyMorphism( <G1>, <G2>, <c> ) O

Returns the first morphisms (in lexicographic order) from <G1> to <G2> 
satisfying the list of properties <c>

A number of preprogrammed properties are provided by \YAGS, and the user may create 
additional ones. The properties provided are: `CHK_WEAK', `CHK_MORPH', `CHK_METRIC', 
`CHK_CMPLT', `CHK_MONO' and `CHK_EPI'.

If <G1> has <n> vertices and $f:G1\rightarrow G2$ is a morphism, it is 
represented as `[f(1), f(2), ..., f(n)]'. 

\beginexample
gap> g1:=CycleGraph(4);;g2:=CompleteBipartiteGraph(2,2);;
gap> c:=[CHK_MORPH];;                            
gap> PropertyMorphism(g1,g2,c);                          
[ 1, 3, 1, 3 ]
\endexample


\>PropertyMorphisms( <G1>, <G2>, <c> ) O

Returns all morphisms from <G1> to <G2> 
satisfying the list of properties <c>

A number of preprogrammed properties are provided by \YAGS, and the user may create 
additional ones. The properties provided are: `CHK_WEAK', `CHK_MORPH', `CHK_METRIC', 
`CHK_CMPLT', `CHK_MONO' and `CHK_EPI'.

If <G1> has <n> vertices and $f:G1\rightarrow G2$ is a morphism, it is 
represented as `[f(1), f(2), ..., f(n)]'. 

\beginexample
gap> g1:=CycleGraph(4);;g2:=CompleteBipartiteGraph(2,2);;
gap> c:=[CHK_WEAK,CHK_MONO];;                    
gap> PropertyMorphisms(g1,g2,c);
[ [ 1, 3, 2, 4 ], [ 1, 4, 2, 3 ], [ 2, 3, 1, 4 ], [ 2, 4, 1, 3 ], 
  [ 3, 1, 4, 2 ], [ 3, 2, 4, 1 ], [ 4, 1, 3, 2 ], [ 4, 2, 3, 1 ] ]
\endexample


\>QtfyIsSimple( <G> ) A

For internal use. Returns how far is graph <G> from being simple.


\>QuotientGraph( <G>, <P> ) O
\>QuotientGraph( <G>, <L1>, <L2> ) O

Returns the quotient graph of graph <G> given a vertex partition
<P>, by identifying any two vertices in the same part. 
The vertices of the quotient
graph are the parts in the partition <P> two of them
being adjacent iff any vertex in one part is adjacent to any vertex in the other part.
Singletons may be omited in P.

\beginexample 
gap> g:=PathGraph(8);; 
gap> QuotientGraph(g,[[1,5,8],[2],[3],[4],[6],[7]]);
Graph( Category := SimpleGraphs, Order := 6, Size := 7, Adjacencies := 
[ [ 2, 4, 5, 6 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3 ], [ 1, 6 ], [ 1, 5 ] ] )
gap> QuotientGraph(g,[[1,5,8]]);  
Graph( Category := SimpleGraphs, Order := 6, Size := 7, Adjacencies := 
[ [ 2, 4, 5, 6 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3 ], [ 1, 6 ], [ 1, 5 ] ] )
\endexample

In its second form, `QuotientGraph' identifies each vertex in list <L1>, 
with the corresponding vertex in list <L2>. <L1> and <L2> must have the same length,
but any or both of them may have repetitions.

\beginexample 
gap> g:=PathGraph(8);; 
gap> QuotientGraph(g,[[1,7],[4,8]]);
Graph( Category := SimpleGraphs, Order := 6, Size := 7, Adjacencies := 
[ [ 2, 4, 6 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3, 5 ], [ 4, 6 ], [ 1, 5 ] ] )
gap> QuotientGraph(g,[1,4],[7,8]);  
Graph( Category := SimpleGraphs, Order := 6, Size := 7, Adjacencies := 
[ [ 2, 4, 6 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3, 5 ], [ 4, 6 ], [ 1, 5 ] ] )
\endexample


\>Radius( <G> ) A

Returns the minimal eccentricity among the vertices of graph <G>.

\beginexample
gap> Radius(PathGraph(5)); 
2
\endexample


\>RandomGraph( <n>, <p> ) F
\>RandomGraph( <n> ) F

Returns a random graph of order <n> taking the rational $p\in [0,1]$ as the edge probability. 

\beginexample
gap> RandomGraph(5,1/3);
Graph( Category := SimpleGraphs, Order := 5, Size := 2, Adjacencies := 
[ [ 5 ], [ 5 ], [  ], [  ], [ 1, 2 ] ] )
gap> RandomGraph(5,2/3);
Graph( Category := SimpleGraphs, Order := 5, Size := 6, Adjacencies := 
[ [ 4, 5 ], [ 3, 4, 5 ], [ 2, 4 ], [ 1, 2, 3 ], [ 1, 2 ] ] )
gap> RandomGraph(5,1/2);
Graph( Category := SimpleGraphs, Order := 5, Size := 4, Adjacencies := 
[ [ 2, 5 ], [ 1, 3, 5 ], [ 2 ], [  ], [ 1, 2 ] ] )
\endexample

If <p> is ommited, the edge probability is taken to be 1/2.

\beginexample
gap> RandomGraph(5);    
Graph( Category := SimpleGraphs, Order := 5, Size := 5, Adjacencies := 
[ [ 2, 3 ], [ 1 ], [ 1, 4, 5 ], [ 3, 5 ], [ 3, 4 ] ] )
gap> RandomGraph(5);
Graph( Category := SimpleGraphs, Order := 5, Size := 3, Adjacencies := 
[ [ 2, 5 ], [ 1, 4 ], [  ], [ 2 ], [ 1 ] ] )
\endexample


\>RandomlyPermuted( <Obj> ) O

Returns a copy of <Obj> with the order of its elements permuted randomly.
Currently, the operation is implemented for lists and graphs.

\beginexample
gap> RandomlyPermuted([1..9]);
[ 9, 7, 5, 3, 1, 4, 8, 6, 2 ]
gap> g:=PathGraph(4);
Graph( Category := SimpleGraphs, Order := 4, Size := 3, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2, 4 ], [ 3 ] ] )
gap> RandomlyPermuted(g);           
Graph( Category := SimpleGraphs, Order := 4, Size := 3, Adjacencies := 
[ [ 4 ], [ 3, 4 ], [ 2 ], [ 1, 2 ] ] )
\endexample


\>RandomPermutation( <N> ) O

Returns a random permutation of the list <[1..N]>

\beginexample
gap> RandomPermutation(12);
(1,8,10)(2,7,9,12)(3,5,11)(4,6)
\endexample


\>RemoveEdges( <G>, <E> ) O

Returns a new graph created from graph <G> by removing the edges in list <E>.

\beginexample
gap> g:=CompleteGraph(4);
Graph( Category := SimpleGraphs, Order := 4, Size := 6, Adjacencies := 
[ [ 2, 3, 4 ], [ 1, 3, 4 ], [ 1, 2, 4 ], [ 1, 2, 3 ] ] )
gap> RemoveEdges(g,[[1,2]]);
Graph( Category := SimpleGraphs, Order := 4, Size := 5, Adjacencies := 
[ [ 3, 4 ], [ 3, 4 ], [ 1, 2, 4 ], [ 1, 2, 3 ] ] )
gap> RemoveEdges(g,[[1,2],[3,4]]);
Graph( Category := SimpleGraphs, Order := 4, Size := 4, Adjacencies := 
[ [ 3, 4 ], [ 3, 4 ], [ 1, 2 ], [ 1, 2 ] ] )
\endexample


\>RemoveVertices( <G>, <V> ) O

Returns a new graph created from graph <G> by removing the vertices in list <V>.

\beginexample
gap> g:=PathGraph(5);
Graph( Category := SimpleGraphs, Order := 5, Size := 4, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 4 ] ] )
gap> RemoveVertices(g,[3]);
Graph( Category := SimpleGraphs, Order := 4, Size := 2, Adjacencies := 
[ [ 2 ], [ 1 ], [ 4 ], [ 3 ] ] )
gap> RemoveVertices(g,[1,3]);
Graph( Category := SimpleGraphs, Order := 3, Size := 1, Adjacencies := 
[ [  ], [ 3 ], [ 2 ] ] )
\endexample


\>`RGraph' V

A square with two pendant vertices attached to the same vertex of the square.

\beginexample
gap> RGraph;
Graph( Category := SimpleGraphs, Order := 6, Size := 6, Adjacencies := 
[ [ 2 ], [ 1, 3, 5, 6 ], [ 2, 4 ], [ 3, 5 ], [ 2, 4 ], [ 2 ] ] )
\endexample


\>RingGraph( <Rng>, <elms> ) O

Returns the graph G whose vertices are the elements of the ring <Rng> 
such that x is adjacent to y iff x+r=y for some r in <elms>.

\beginexample
gap> r:=FiniteField(8);Elements(r); 
GF(2^3)
[ 0*Z(2), Z(2)^0, Z(2^3), Z(2^3)^2, Z(2^3)^3, Z(2^3)^4, Z(2^3)^5, Z(2^3)^6 ]
gap> RingGraph(r,[Z(2^3),Z(2^3)^4]);
Graph( Category := SimpleGraphs, Order := 8, Size := 8, Adjacencies := 
[ [ 3, 6 ], [ 5, 7 ], [ 1, 4 ], [ 3, 6 ], [ 2, 8 ], [ 1, 4 ], [ 2, 8 ], 
  [ 5, 7 ] ] )
\endexample


\>SetCoordinates( <G>, <Coord> ) O

Sets the coordinates of the vertices of <G>, which are used to draw <G>
by `Draw( <G> )'. 

\beginexample
gap> g:=CycleGraph(4);;
gap> SetCoordinates(g,[[-10,-10 ],[-10,20],[20,-10 ], [20,20]]);
gap> Coordinates(g);
[ [ -10, -10 ], [ -10, 20 ], [ 20, -10 ], [ 20, 20 ] ]
\endexample


\>SetDefaultGraphCategory( <C> ) F

Sets the default graphs category to <C>. The default graph
category is used when constructing new graphs when no other graph category 
is indicated. New graphs are always forced to comply with the `TargetGraphCategory', 
so loops may be removed, and arrows may replaced by edges or viceversa, depending on 
the category that the new graph belongs to.

The available graph categories are:  `SimpleGraphs', `OrientedGraphs', 
`UndirectedGraphs', `LooplessGraphs', and `Graphs'.

\beginexample
gap> SetDefaultGraphCategory(Graphs);
gap> GraphByWalks([1,1],[1,2],[2,1],[3,2]);
Graph( Category := Graphs, Order := 3, Size := 4, Adjacencies := 
[ [ 1, 2 ], [ 1 ], [ 2 ] ] )
gap> SetDefaultGraphCategory(LooplessGraphs);
gap> GraphByWalks([1,1],[1,2],[2,1],[3,2]);  
Graph( Category := LooplessGraphs, Order := 3, Size := 3, Adjacencies := 
[ [ 2 ], [ 1 ], [ 2 ] ] )
gap> SetDefaultGraphCategory(UndirectedGraphs);
gap> GraphByWalks([1,1],[1,2],[2,1],[3,2]);    
Graph( Category := UndirectedGraphs, Order := 3, Size := 3, Adjacencies := 
[ [ 1, 2 ], [ 1, 3 ], [ 2 ] ] )
gap> SetDefaultGraphCategory(SimpleGraphs);    
gap> GraphByWalks([1,1],[1,2],[2,1],[3,2]);
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
gap> SetDefaultGraphCategory(OrientedGraphs);
gap> GraphByWalks([1,1],[1,2],[2,1],[3,2]);  
Graph( Category := OrientedGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [  ], [ 2 ] ] )
\endexample


\>SimpleGraphs( ) C

`SimpleGraphs' is a graph category in \YAGS. A graph in this category may 
contain edges, but no loops or arrows. The category has two parents: `LooplessGraphs' 
and `UndirectedGraphs'.

\beginexample
gap> GraphByWalks([1,1],[1,2],[2,1],[3,2]:GraphCategory:=Graphs);
Graph( Category := Graphs, Order := 3, Size := 4, Adjacencies := 
[ [ 1, 2 ], [ 1 ], [ 2 ] ] )
gap> GraphByWalks([1,1],[1,2],[2,1],[3,2]:GraphCategory:=SimpleGraphs);  
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
\endexample


\>Size( <G> ) A

Returns the number of edges of graph <G>.

\beginexample
gap> Size(Icosahedron);
30
\endexample


\>`SnubDisphenoid' V

The 1-skeleton of the 84th Johnson solid. 

\beginexample
gap> SnubDisphenoid;
Graph( Category := SimpleGraphs, Order := 8, Size := 18, Adjacencies := 
[ [ 2, 3, 4, 5, 8 ], [ 1, 3, 6, 7, 8 ], [ 1, 2, 4, 6 ], [ 1, 3, 5, 6 ], 
  [ 1, 4, 6, 7, 8 ], [ 2, 3, 4, 5, 7 ], [ 2, 5, 6, 8 ], [ 1, 2, 5, 7 ] ] )
\endexample


\>SpanningForest( <G> ) O

Returns a spanning forest of <G>.


\>SpanningForestEdges( <G> ) O

Returns the edges of a spanning forest of <G>.


\>SpikyGraph( <N> ) F

The spiky graph is constructed as follows: Take complete graph on <N> vertices, $K_N$, 
and then, for each the <N> subsets of $Vertices(K_n)$ of order <N-1>, add an additional vertex which
is adjacent precisely to this subset of $Vertices(K_n)$.

\beginexample
gap> SpikyGraph(3);
Graph( Category := SimpleGraphs, Order := 6, Size := 9, Adjacencies :=
[ [ 2, 3, 4, 5 ], [ 1, 3, 4, 6 ], [ 1, 2, 5, 6 ], [ 1, 2 ], [ 1, 3 ],
  [ 2, 3 ] ] )
\endexample


\>SunGraph( <N> ) F

Returns the <N>-Sun: A complete graph on <N> vertices, $K_N$, with a corona 
made with a zigzagging <2N>-cycle glued to a <N>-cyle of the $K_N$.

\beginexample
gap> SunGraph(3);
Graph( Category := SimpleGraphs, Order := 6, Size := 9, Adjacencies := 
[ [ 2, 6 ], [ 1, 3, 4, 6 ], [ 2, 4 ], [ 2, 3, 5, 6 ], [ 4, 6 ], 
  [ 1, 2, 4, 5 ] ] )
gap> SunGraph(4);
Graph( Category := SimpleGraphs, Order := 8, Size := 14, Adjacencies := 
[ [ 2, 8 ], [ 1, 3, 4, 6, 8 ], [ 2, 4 ], [ 2, 3, 5, 6, 8 ], [ 4, 6 ], 
  [ 2, 4, 5, 7, 8 ], [ 6, 8 ], [ 1, 2, 4, 6, 7 ] ] )
\endexample


\>Suspension( <G> ) O

Returns the suspension of graph <G>. The suspension of <G> is the graph 
obtained from <G> by adding two new vertices which are adjacent to every 
vertex of <G> but not to each other. The new vertices are the first ones 
in the new graph.

\beginexample 
gap> Suspension(CycleGraph(4));
Graph( Category := SimpleGraphs, Order := 6, Size := 12, Adjacencies := 
[ [ 3, 4, 5, 6 ], [ 3, 4, 5, 6 ], [ 1, 2, 4, 6 ], [ 1, 2, 3, 5 ], 
  [ 1, 2, 4, 6 ], [ 1, 2, 3, 5 ] ] )
\endexample


\>TargetGraphCategory( [<G>, ... ] ) F

For internal use. Returns the graph category indicated in the <options stack> if any, 
otherwise if the list of graphs provided is not empty, returns the minimal common graph 
category for the graphs in the list, else returns the default graph category.

The partial order (by inclusion) among graph categories is as follows: 
$$`SimpleGraphs' \<  `UndirectedGraphs' \< `Graphs',$$
$$`OrientedGraphs' \< `LooplessGraphs' \< `Graphs'$$  
$$`SimpleGraphs' \< `LooplessGraphs' \< `Graphs'$$
 
This function is internally called by all graph constructing operations in \YAGS\ to decide the 
graph category that the newly constructed graph is going to belong. New graphs are always 
forced to comply with the `TargetGraphCategory', so loops may be removed, and arrows may 
replaced by edges or viceversa, depending on the category that the new graph belongs to.

The <options stack> is a mechanism provided by \GAP\ to pass implicit parameters 
and is used by `TargetGraphCategory' so that the user may indicate the graph 
category she/he wants for the new graph.

\beginexample
gap> SetDefaultGraphCategory(SimpleGraphs);             
gap> g1:=CompleteGraph(2);                              
Graph( Category := SimpleGraphs, Order := 2, Size := 1, Adjacencies := 
[ [ 2 ], [ 1 ] ] )
gap> g2:=CompleteGraph(2:GraphCategory:=OrientedGraphs);
Graph( Category := OrientedGraphs, Order := 2, Size := 1, Adjacencies := 
[ [ 2 ], [  ] ] )
gap> DisjointUnion(g1,g2);
Graph( Category := LooplessGraphs, Order := 4, Size := 3, Adjacencies := 
[ [ 2 ], [ 1 ], [ 4 ], [  ] ] )
gap> DisjointUnion(g1,g2:GraphCategory:=UndirectedGraphs);
Graph( Category := UndirectedGraphs, Order := 4, Size := 2, Adjacencies := 
[ [ 2 ], [ 1 ], [ 4 ], [ 3 ] ] )
\endexample

In the previous examples, `TargetGraphCategory' was called internally exactly once for 
each new graph constructed with the following parameters:

\beginexample
gap> TargetGraphCategory();
<Operation "SimpleGraphs">
gap> TargetGraphCategory(:GraphCategory:=OrientedGraphs);
<Operation "OrientedGraphs">
gap> TargetGraphCategory([g1,g2]);                       
<Operation "LooplessGraphs">
gap> TargetGraphCategory([g1,g2]:GraphCategory:=UndirectedGraphs);
<Operation "UndirectedGraphs">
\endexample


\>`Tetrahedron' V

The 1-skeleton of Plato's tetrahedron.

\beginexample
gap> Tetrahedron;
Graph( Category := SimpleGraphs, Order := 4, Size := 6, Adjacencies :=
[ [ 2, 3, 4 ], [ 1, 3, 4 ], [ 1, 2, 4 ], [ 1, 2, 3 ] ] )
\endexample


\>TimeInSeconds( ) O

Returns the time in seconds since 1970-01-01 00:00:00 UTC as an integer.
This is useful to measure execution time. It can also be used to impose 
time constraints on the execution of algorithms. Note however that the time 
reported is the 'wall time', not necessarily the time spent in the process
you intend to measure.

\beginexample
gap> TimeInSeconds();
1415551598
gap> K:=CliqueGraph;;
gap>  t1:=TimeInSeconds();NumberOfCliques(K(K(K(K(Icosahedron)))));TimeInSeconds()-t1;
1415551608
44644
103
\endexample


\>TimesProduct( <G>, <H> ) O

Returns the times product of two graphs <G> and <H>, <G> $\times$ <H>
(also known as the tensor product).

The times product is computed as follows:

For each pair of vertices $g \in G, h \in H$ we create a vertex
$(g,h)$. Given two such vertices $(g,h)$ and $(g',h')$ they are
adjacent <iff> $g \sim g'$ and $h \sim h'$.

\beginexample
gap> g1:=PathGraph(3);g2:=CycleGraph(4);                              
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
Graph( Category := SimpleGraphs, Order := 4, Size := 4, Adjacencies := 
[ [ 2, 4 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3 ] ] )
gap> g1g2:=TimesProduct(g1,g2);         
Graph( Category := SimpleGraphs, Order := 12, Size := 16, Adjacencies := 
[ [ 6, 8 ], [ 5, 7 ], [ 6, 8 ], [ 5, 7 ], [ 2, 4, 10, 12 ], [ 1, 3, 9, 11 ], 
  [ 2, 4, 10, 12 ], [ 1, 3, 9, 11 ], [ 6, 8 ], [ 5, 7 ], [ 6, 8 ], [ 5, 7 ] ] )
gap> VertexNames(g1g2);                 
[ [ 1, 1 ], [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 2, 1 ], [ 2, 2 ], [ 2, 3 ], 
  [ 2, 4 ], [ 3, 1 ], [ 3, 2 ], [ 3, 3 ], [ 3, 4 ] ]
\endexample


\>`TrivialGraph' V

The one vertex graph.

\beginexample
gap> TrivialGraph;
Graph( Category := SimpleGraphs, Order := 1, Size := 0, Adjacencies :=
[ [  ] ] )
\endexample


\>UFFind( <UFS>, <x> ) F

For internal use. Implements the <find> operation on the <union-find structure>. 


\>UFUnite( <UFS>, <x>, <y> ) F

For internal use. Implements the <unite> operation on the <union-find structure>. 


\>UndirectedGraphs( ) C

`UndirectedGraphs' is a graph category in \YAGS. A graph in this category may 
contain edges and loops, but no arrows. The parent of this category is `Graphs'

\beginexample
gap> GraphByWalks([1,1],[1,2],[2,1],[3,2]:GraphCategory:=Graphs);
Graph( Category := Graphs, Order := 3, Size := 4, Adjacencies := 
[ [ 1, 2 ], [ 1 ], [ 2 ] ] )
gap> GraphByWalks([1,1],[1,2],[2,1],[3,2]:GraphCategory:=UndirectedGraphs);
Graph( Category := UndirectedGraphs, Order := 3, Size := 3, Adjacencies := 
[ [ 1, 2 ], [ 1, 3 ], [ 2 ] ] )
\endexample


\>UnitsRingGraph( <Rng> ) O

Returns the graph G whose vertices are the elements of <Rng> 
such that x is adjacent to y iff x+z=y for some unit z of <Rng>

\beginexample
gap> UnitsRingGraph(ZmodnZ(8));    
Graph( Category := SimpleGraphs, Order := 8, Size := 16, Adjacencies := 
[ [ 2, 4, 6, 8 ], [ 1, 3, 5, 7 ], [ 2, 4, 6, 8 ], [ 1, 3, 5, 7 ], 
  [ 2, 4, 6, 8 ], [ 1, 3, 5, 7 ], [ 2, 4, 6, 8 ], [ 1, 3, 5, 7 ] ] )
\endexample


\>VertexDegree( <G>, <v> ) O

Returns the degree of vertex <v> in Graph <G>. 

\beginexample
gap> g:=PathGraph(3);
Graph( Category := SimpleGraphs, Order := 3, Size := 2, Adjacencies := 
[ [ 2 ], [ 1, 3 ], [ 2 ] ] )
gap> VertexDegree(g,1);
1
gap> VertexDegree(g,2);
2
\endexample


\>VertexDegrees( <G> ) O

Returns the list of degrees of the vertices in graph <G>.

\beginexample
gap> g:=GemGraph;
Graph( Category := SimpleGraphs, Order := 5, Size := 7, Adjacencies := 
[ [ 2, 3, 4, 5 ], [ 1, 3 ], [ 1, 2, 4 ], [ 1, 3, 5 ], [ 1, 4 ] ] )
gap> VertexDegrees(g);
[ 4, 2, 3, 3, 2 ]
\endexample


\>VertexNames( <G> ) A

Return the list of names of the vertices of <G>. The vertices of a graph in \YAGS\ are always 
$\{1,2, \ldots, Order(G)\}$, but depending on how the graph was constructed, its vertices may 
have also some <names>, that help us identify the origin of the vertices. \YAGS\ will always try 
to store meaninful names for the vertices. For example, in the case of the LineGraph, the vertex 
names of the new graph are the edges of the old graph.

\beginexample
gap> g:=LineGraph(DiamondGraph);          
Graph( Category := SimpleGraphs, Order := 5, Size := 8, Adjacencies := 
[ [ 2, 3, 4 ], [ 1, 3, 4, 5 ], [ 1, 2, 5 ], [ 1, 2, 5 ], [ 2, 3, 4 ] ] )
gap> VertexNames(g);
[ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 2, 3 ], [ 3, 4 ] ]
gap> Edges(DiamondGraph);
[ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 2, 3 ], [ 3, 4 ] ]
\endexample


\>Vertices( <G> ) O

Returns the list [1..Order( <G> )].

\beginexample
gap> Vertices(Icosahedron);
[ 1 .. 12 ]
\endexample


\>WheelGraph( <N> ) O
\>WheelGraph( <N>, <Radius> ) O

In its first form `WheelGraph' returns the wheel graph on <N+1> vertices. This is the 
cone of a cycle: a central vertex adjacent to all the vertices of an <N>-cycle

\beginexample
WheelGraph(5);
gap> Graph( Category := SimpleGraphs, Order := 6, Size := 10, Adjacencies :=
[ [ 2, 3, 4, 5, 6 ], [ 1, 3, 6 ], [ 1, 2, 4 ], [ 1, 3, 5 ], [ 1, 4, 6 ],
 [ 1, 2, 5 ] ] )
\endexample

In its second form, `WheelGraph' returns returns the wheel graph, but adding 
<Radius-1> layers, each layer is a new <N>-cycle joined to the previous layer 
by a zigzagging <2N>-cycle. This graph is a triangulation of the disk.

\beginexample
gap> WheelGraph(5,2);
Graph( Category := SimpleGraphs, Order := 11, Size := 25, Adjacencies := 
[ [ 2, 3, 4, 5, 6 ], [ 1, 3, 6, 7, 8 ], [ 1, 2, 4, 8, 9 ], [ 1, 3, 5, 9, 10 ],
  [ 1, 4, 6, 10, 11 ], [ 1, 2, 5, 7, 11 ], [ 2, 6, 8, 11 ], [ 2, 3, 7, 9 ], 
  [ 3, 4, 8, 10 ], [ 4, 5, 9, 11 ], [ 5, 6, 7, 10 ] ] )
gap> WheelGraph(5,3);
Graph( Category := SimpleGraphs, Order := 16, Size := 40, Adjacencies := 
[ [ 2, 3, 4, 5, 6 ], [ 1, 3, 6, 7, 8 ], [ 1, 2, 4, 8, 9 ], [ 1, 3, 5, 9, 10 ],
  [ 1, 4, 6, 10, 11 ], [ 1, 2, 5, 7, 11 ], [ 2, 6, 8, 11, 12, 13 ], 
  [ 2, 3, 7, 9, 13, 14 ], [ 3, 4, 8, 10, 14, 15 ], [ 4, 5, 9, 11, 15, 16 ], 
  [ 5, 6, 7, 10, 12, 16 ], [ 7, 11, 13, 16 ], [ 7, 8, 12, 14 ], 
  [ 8, 9, 13, 15 ], [ 9, 10, 14, 16 ], [ 10, 11, 12, 15 ] ] )
\endexample


\>YagsExec( <progname>, <instring> ) O

For internal use. Calls external program <prog> located in directory 
'<yags-dir>/bin/' feeding it with <instring> as input and returning 
the output of the external program as a string. 'fail' is returned if
the program could not be located.

\beginexample
gap> YagsExec("time","");
"1415551127\n"
gap> YagsExec("nauty","l=0$=1dacn=5 g1,2,3. xbzq");
"(4,5)\n(2,3)\n[2,3,4,5,1]\n[\"cb0c\",\"484f264\",\"b0e19f1\"]\n"
\endexample


